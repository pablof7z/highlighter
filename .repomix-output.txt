This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*, .cursorrules, .cursor/rules/*, .clinerules, CLAUDE.md
- Files matching these patterns are excluded: .*.*, **/*.pbxproj, **/node_modules/**, **/dist/**, **/build/**, **/compile/**, **/*.spec.*, **/*.pyc, **/.env, **/.env.*, **/*.env, **/*.env.*, **/*.lock, **/*.lockb, **/package-lock.*, **/pnpm-lock.*, **/*.tsbuildinfo, **/certdata.txt
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    ci.yml
    testflight.yml
Highlighter.xcodeproj/
  project.xcworkspace/
    xcshareddata/
      swiftpm/
        configuration/
        Package.resolved
    contents.xcworkspacedata
  xcshareddata/
    xcschemes/
      Highlighter.xcscheme
  project.pbxproj.backup
Resources/
  Assets.xcassets/
    AccentColor.colorset/
      Contents.json
    AppIcon.appiconset/
      Contents.json
    Contents.json
Sources/
  Highlighter/
    App/
      HighlighterApp.swift
      Info.plist
    Design/
      AnimationSystem.swift
      ButtonSystem.swift
      CardSystem.swift
      DesignSystem.swift
      ModernViewModifiers.swift
      VisualEffects.swift
    Models/
      AppState.swift
      Article.swift
      ArticleCuration.swift
      Comment.swift
      FollowPack.swift
      HighlightEvent.swift
      SwarmHighlight.swift
    Preview Content/
      PreviewData.swift
    Services/
      AIHighlightEngine.swift
      BookmarkService.swift
      CommentService.swift
      DataStreamManager.swift
      EngagementService.swift
      LightningService.swift
      LNURLService.swift
      NostrWalletConnect.swift
      ProfileManager.swift
      PublishingService.swift
      ReadingProgressService.swift
    Utilities/
      AnimationExtensions.swift
      ArticleTimeEstimator.swift
      BlurHashDecoder.swift
      FormattingUtilities.swift
      HapticManager.swift
      KeychainManager.swift
      PreferenceKeys.swift
    Views/
      AIAnalysis/
      Analytics/
        EngagementVisualization.swift
      Articles/
        ArticleCards.swift
        ArticleListView.swift
        ArticleView.swift
      Audio/
        AudioPlayerView.swift
      Auth/
        ModernAuthenticationView.swift
      Components/
        CommentsSection.swift
        CommentView.swift
        EmptyHighlightsView.swift
        EnhancedAsyncProfileImage.swift
        EnhancedTabBar.swift
        ImmersiveGradientBackground.swift
        LoadingHighlightView.swift
        MeshGradientBackground.swift
        ModernFormComponents.swift
        ModernStateViews.swift
        SelectableMarkdownRenderer.swift
        SharedStyles.swift
        SwipeableHighlightCard.swift
        TappableAvatar.swift
        UnifiedCard.swift
        ZapButton.swift
      Curations/
        CreateCurationView.swift
        CurationDetailView.swift
        CurationManagementView.swift
      Discovery/
        CurationDiscoveryView.swift
        EnhancedArticleDiscoveryView.swift
        HighlightDiscoveryView.swift
        UserDiscoveryView.swift
      Feed/
        TimelineFeedView.swift
      FollowPacks/
        FollowPackDetailView.swift
      Highlights/
        CreateHighlightView.swift
        HighlightDetailView.swift
        HighlightsFeedView.swift
        ImmersiveHighlightDetailView.swift
        SwarmHeatmapView.swift
        SwarmOverlayView.swift
        TextSelectionView.swift
      Home/
        HomeDataManager.swift
        HybridFeedView.swift
        SimplifiedHybridFeedView.swift
      Import/
        ImportComponents.swift
        SmartArticleImportView.swift
        SmartContentImporter.swift
      Library/
        LibraryView.swift
      Lightning/
        LightningPaymentFlowView.swift
        LightningWalletView.swift
      Onboarding/
        OnboardingView.swift
      Profile/
        EditProfileView.swift
        EnhancedProfileView.swift
        FollowersListView.swift
        FollowingListView.swift
        UserProfileView.swift
      Search/
        AdvancedSearchView.swift
      Settings/
        SettingsView.swift
      ContentView.swift
.gitignore
build.sh
deploy.sh
ExportOptions-TestFlight.plist
ExportOptions.plist
HL_EXEC.md
HL-SPEC.md
LICENSE
project.yml
README.md
refresh-project.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/workflows/ci.yml">
name: CI
on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
env:
  XCODE_VERSION: '15.4'
jobs:
  build:
    name: Build and Test
    runs-on: macos-14
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Select Xcode
      run: sudo xcode-select -s /Applications/Xcode_15.4.app
    - name: Install dependencies
      run: |
        brew install xcodegen
        brew install xcbeautify
    - name: Generate Xcode project
      run: ./refresh-project.sh
    - name: Build for testing
      run: |
        xcodebuild build-for-testing \
          -project Highlighter.xcodeproj \
          -scheme Highlighter \
          -destination "platform=iOS Simulator,name=iPhone 15 Pro" \
          | xcbeautify
    - name: Run tests
      run: |
        xcodebuild test-without-building \
          -project Highlighter.xcodeproj \
          -scheme Highlighter \
          -destination "platform=iOS Simulator,name=iPhone 15 Pro" \
          | xcbeautify || true
EOF < /dev/null
</file>

<file path=".github/workflows/testflight.yml">
name: Deploy to TestFlight
on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
jobs:
  deploy:
    name: Deploy to TestFlight
    runs-on: macos-14
    steps:
    - uses: actions/checkout@v4
    - name: Select Xcode
      run: sudo xcode-select -s /Applications/Xcode_15.4.app
    - name: Install dependencies
      run: |
        brew install xcodegen
        brew install xcbeautify
    - name: Setup API Key
      env:
        APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}
      run: |
        mkdir -p ~/.appstoreconnect/private_keys
        echo "$APP_STORE_CONNECT_API_KEY" > ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}.p8
    - name: Generate Xcode project
      run: ./refresh-project.sh
    - name: Build and deploy
      env:
        API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
        API_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
      run: |
        xcodebuild archive \
          -project Highlighter.xcodeproj \
          -scheme Highlighter \
          -configuration Release \
          -archivePath build/Highlighter.xcarchive \
          -destination "generic/platform=iOS" \
          CODE_SIGN_STYLE=Automatic \
          DEVELOPMENT_TEAM="${{ secrets.DEVELOPMENT_TEAM }}" \
          | xcbeautify
        xcodebuild -exportArchive \
          -archivePath build/Highlighter.xcarchive \
          -exportPath build \
          -exportOptionsPlist ExportOptions-TestFlight.plist \
          | xcbeautify
        xcrun altool --upload-app \
          -f build/Highlighter.ipa \
          -t ios \
          --apiKey "$API_KEY_ID" \
          --apiIssuer "$API_ISSUER_ID"
</file>

<file path="Highlighter.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved">
{
  "originHash" : "4bbea0d3b72726fa4bd0f2e2af7ec8b45cdc1d533cb0a1a8a6dfdc1e577aac17",
  "pins" : [
    {
      "identity" : "base58",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/anquii/Base58.git",
      "state" : {
        "revision" : "7e4a1e4e6813c750ed2f9e80a0494c608eebb2ca",
        "version" : "1.0.1"
      }
    },
    {
      "identity" : "base58check",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/anquii/Base58Check.git",
      "state" : {
        "revision" : "f35a770ff7f3fd553cc44057f492c0107cc7b481",
        "version" : "1.0.1"
      }
    },
    {
      "identity" : "bigint",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/attaswift/BigInt.git",
      "state" : {
        "revision" : "0ed110f7555c34ff468e72e1686e59721f2b0da6",
        "version" : "5.3.0"
      }
    },
    {
      "identity" : "bip32",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/zeugmaster/BIP32.git",
      "state" : {
        "branch" : "main",
        "revision" : "1be94093fb7fe87dc0ccc8e2c041cc05218efff6"
      }
    },
    {
      "identity" : "bip39",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/pengpengliu/BIP39.git",
      "state" : {
        "revision" : "e79bd90275e50643cf8f97208ffa536d0def3ec7",
        "version" : "1.0.1"
      }
    },
    {
      "identity" : "cashuswift",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/zeugmaster/CashuSwift.git",
      "state" : {
        "branch" : "main",
        "revision" : "d703a9b2035d1240e4476d3c37d2cd967f0c3d75"
      }
    },
    {
      "identity" : "cryptoswiftwrapper",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/anquii/CryptoSwiftWrapper.git",
      "state" : {
        "revision" : "0d57e806de368b5d2364fabb7c789b48661ec90c",
        "version" : "1.4.3"
      }
    },
    {
      "identity" : "grdb.swift",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/groue/GRDB.swift.git",
      "state" : {
        "revision" : "2cf6c756e1e5ef6901ebae16576a7e4e4b834622",
        "version" : "6.29.3"
      }
    },
    {
      "identity" : "ndkswift",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/pablof7z/NDKSwift",
      "state" : {
        "branch" : "master",
        "revision" : "ec51893377156189cde5476faa557c0dec2c0940"
      }
    },
    {
      "identity" : "ripemd160",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/anquii/RIPEMD160.git",
      "state" : {
        "revision" : "15679c6fe1f3ae32ec1bad63bcc45aa422954f01",
        "version" : "1.0.0"
      }
    },
    {
      "identity" : "swift-bigint",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/mkrd/Swift-BigInt.git",
      "state" : {
        "revision" : "b07e961f4c999671cf8c2dc80e740899e8946013",
        "version" : "2.3.0"
      }
    },
    {
      "identity" : "swift-secp256k1",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/zeugmaster/swift-secp256k1.git",
      "state" : {
        "branch" : "main",
        "revision" : "73cf2403b7a69de8efc612d251a6e0d01211e1c4"
      }
    },
    {
      "identity" : "swiftcbor",
      "kind" : "remoteSourceControl",
      "location" : "https://github.com/myfreeweb/SwiftCBOR.git",
      "state" : {
        "revision" : "04ccff117f6549121d5721ec84fdf0162122b90e",
        "version" : "0.5.0"
      }
    }
  ],
  "version" : 3
}
</file>

<file path="Highlighter.xcodeproj/project.xcworkspace/contents.xcworkspacedata">
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>
</file>

<file path="Highlighter.xcodeproj/xcshareddata/xcschemes/Highlighter.xcscheme">
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1430"
   version = "1.7">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES"
      runPostActionsOnFailure = "NO">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "8E948B0930F062DF95681D44"
               BuildableName = "Highlighter.app"
               BlueprintName = "Highlighter"
               ReferencedContainer = "container:Highlighter.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      onlyGenerateCoverageForSpecifiedTargets = "NO">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "8E948B0930F062DF95681D44"
            BuildableName = "Highlighter.app"
            BlueprintName = "Highlighter"
            ReferencedContainer = "container:Highlighter.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
      <Testables>
      </Testables>
      <CommandLineArguments>
      </CommandLineArguments>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "8E948B0930F062DF95681D44"
            BuildableName = "Highlighter.app"
            BlueprintName = "Highlighter"
            ReferencedContainer = "container:Highlighter.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
      <CommandLineArguments>
      </CommandLineArguments>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "8E948B0930F062DF95681D44"
            BuildableName = "Highlighter.app"
            BlueprintName = "Highlighter"
            ReferencedContainer = "container:Highlighter.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
      <CommandLineArguments>
      </CommandLineArguments>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>
</file>

<file path="Highlighter.xcodeproj/project.pbxproj.backup">
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXBuildFile section */
		06F1FA7B9C3130D22B35D122 /* SwarmHighlight.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9906E08DF53F3E88E7370583 /* SwarmHighlight.swift */; };
		07E3CDA432D5B26DF5747DDD /* TextSelectionView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 340014DACEA6C5443AE37553 /* TextSelectionView.swift */; };
		0CAD93077385698E44D03486 /* LightningService.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5818E9E0A5081751B12C7A05 /* LightningService.swift */; };
		1B99932C8DCDEBA4FB239749 /* ArticleListView.swift in Sources */ = {isa = PBXBuildFile; fileRef = A89145FF0C6BCD85C2ADB6B0 /* ArticleListView.swift */; };
		218363F8C03885960CF5D248 /* AppState.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5E06D1E90D26910A32BBA586 /* AppState.swift */; };
		2207FFA98AB56815A584DDB4 /* FollowPack.swift in Sources */ = {isa = PBXBuildFile; fileRef = 03DEF9DECD6C6F4D9AF8C400 /* FollowPack.swift */; };
		224179F5F3F178E3DEFA54FF /* OnboardingView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4065018869D27C2992BD8E09 /* OnboardingView.swift */; };
		2629890795B6D0A577BF09D3 /* SelectableMarkdownRenderer.swift in Sources */ = {isa = PBXBuildFile; fileRef = 68EE862B30307430C752F295 /* SelectableMarkdownRenderer.swift */; };
		31CEBD7F410053E533CDE2BA /* CardSystem.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4E36C3396966D42A6A522C05 /* CardSystem.swift */; };
		34DF18AC7EC3EE0F46E1A1A3 /* HomeDataManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = F6C338502340BD8BE768794B /* HomeDataManager.swift */; };
		39ED8F05509F9A4FFF466557 /* LibraryView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 552D71BE7E32CED89D35A278 /* LibraryView.swift */; };
		3A1255EBF3357C89B1E648F6 /* HighlightDetailView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 842FF8B20D37A2852B7A0ED9 /* HighlightDetailView.swift */; };
		3DDAE1A8FD5B8746688B9D12 /* ArticleCuration.swift in Sources */ = {isa = PBXBuildFile; fileRef = A2CDAC5B2099CFF6ED8BE9AE /* ArticleCuration.swift */; };
		3DFA64BB9C00F7D7EDBB3E38 /* AudioPlayerView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 321C2E8C6CB80D3B280CC5CA /* AudioPlayerView.swift */; };
		410141EDC0B7B0D01CCE3452 /* ModernStateViews.swift in Sources */ = {isa = PBXBuildFile; fileRef = FA46623C808023B5D65EB473 /* ModernStateViews.swift */; };
		43920B59A88E931B495919A8 /* PublishingService.swift in Sources */ = {isa = PBXBuildFile; fileRef = 7542540C7ACFB260E24E01B2 /* PublishingService.swift */; };
		B5A2C1D9A88E931B495919A9 /* BookmarkService.swift in Sources */ = {isa = PBXBuildFile; fileRef = B5A2C1D87ACFB260E24E01B3 /* BookmarkService.swift */; };
		C3B4D2E9A88E931B495919B9 /* CommentService.swift in Sources */ = {isa = PBXBuildFile; fileRef = C3B4D2E87ACFB260E24E01B4 /* CommentService.swift */; };
		483E4645826EA9B78961A7BD /* .repomix-output.txt in Resources */ = {isa = PBXBuildFile; fileRef = 923EDFDDF5D99390303E706B /* .repomix-output.txt */; };
		4F557938220F55296A4E483F /* ContentView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 288947C11C084EEA395DB4F3 /* ContentView.swift */; };
		5328876790B7FC8B3F06147C /* AIHighlightEngine.swift in Sources */ = {isa = PBXBuildFile; fileRef = A9A59DD7DD81D1FEB67B662D /* AIHighlightEngine.swift */; };
		56884CA05833E2E75660E7E3 /* BlurHashDecoder.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5C9A8C38CB54B7E5605AF14A /* BlurHashDecoder.swift */; };
		584216E80F87025A63620635 /* ButtonSystem.swift in Sources */ = {isa = PBXBuildFile; fileRef = CC9C86787D8110767C109BBB /* ButtonSystem.swift */; };
		58CD029928844C6A40946A74 /* AnimationSystem.swift in Sources */ = {isa = PBXBuildFile; fileRef = C88288E64D986A7B021700F9 /* AnimationSystem.swift */; };
		592922A038AC7CEB7AAD35F7 /* SmartArticleImportView.swift in Sources */ = {isa = PBXBuildFile; fileRef = A4C6D9AB2A21C93E8951D6E4 /* SmartArticleImportView.swift */; };
		5D62AE907A0A91BECED7DCD4 /* DataStreamManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 47D8FA7B43386CEE13EB7B18 /* DataStreamManager.swift */; };
		63ED41BC7DD413BEE595F3A9 /* HighlightDiscoveryView.swift in Sources */ = {isa = PBXBuildFile; fileRef = B4C72655D262C9FB9C686CAF /* HighlightDiscoveryView.swift */; };
		6462DC934F3BCE00CEEE8BF8 /* HighlightCard.swift in Sources */ = {isa = PBXBuildFile; fileRef = 19C631ECAA0313B22AD50212 /* HighlightCard.swift */; };
		65B0F76A54167561B653A458 /* EditProfileView.swift in Sources */ = {isa = PBXBuildFile; fileRef = B732C4AF8ED87EBB93D6D0D5 /* EditProfileView.swift */; };
		6972D167F453E975971B28E6 /* SwarmOverlayView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 83206D6462CF11DCF490672D /* SwarmOverlayView.swift */; };
		69E892C13A2D7E562F67039A /* ArticleDiscoveryView.swift in Sources */ = {isa = PBXBuildFile; fileRef = D969455E05A9A63B81679E4A /* ArticleDiscoveryView.swift */; };
		6B3A6908C6C27D35E9C37F28 /* FormattingUtilities.swift in Sources */ = {isa = PBXBuildFile; fileRef = D01FA9F607102E7402D96CA8 /* FormattingUtilities.swift */; };
		73EF0B3EADF9149125478230 /* CreateCurationView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9FE479875030C79E23CEC371 /* CreateCurationView.swift */; };
		762E0B52E6C34458CB162E73 /* ProfileView.swift in Sources */ = {isa = PBXBuildFile; fileRef = D48EA35CD61779F2D9DC5964 /* ProfileView.swift */; };
		7686328E9D95E29C8EA0B48F /* CurationDiscoveryView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 39B251BEAE7C275E85EB1BC1 /* CurationDiscoveryView.swift */; };
		79849E68684EC926B32E78C9 /* AIAnalysisVisualizationView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9908B54604FDE004C8DED14E /* AIAnalysisVisualizationView.swift */; };
		8691D5E4EAF2824D10C0E28B /* ModernTabBar.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9831C9AF1F1938111965B8CE /* ModernTabBar.swift */; };
		8A5C45073A61569328188B21 /* FollowersListView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 08C9371F823E831254881AA4 /* FollowersListView.swift */; };
		8B1648772C86AD40FCF6602E /* DesignSystem.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1A3025E76E14FBF1C8D93736 /* DesignSystem.swift */; };
		8CC027C461CC53CF47AC2ECB /* LightningPaymentFlowView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 978B907455CE5F514DADD37A /* LightningPaymentFlowView.swift */; };
		8D5D97226F6D2C4ABE8631F3 /* ArticleView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 71A83CD10503C7B187BEE747 /* ArticleView.swift */; };
		8EE197235B1A83A04B155F56 /* VisualEffects.swift in Sources */ = {isa = PBXBuildFile; fileRef = 62A24BA9AAF6CD7CBED4A5EB /* VisualEffects.swift */; };
		91774403D5A6E567EB9879C6 /* HighlighterApp.swift in Sources */ = {isa = PBXBuildFile; fileRef = FD69175DE127E1B1E7016D16 /* HighlighterApp.swift */; };
		981A640F5DAAE1DC2566BE65 /* ModernFormComponents.swift in Sources */ = {isa = PBXBuildFile; fileRef = 96BB1CEB6B1AF8996372B0A9 /* ModernFormComponents.swift */; };
		99A884B98EA5E9A9DD9BFC8F /* SmartContentImporter.swift in Sources */ = {isa = PBXBuildFile; fileRef = 3EE49BE02AE3ECE3BD63A825 /* SmartContentImporter.swift */; };
		9A7FB11D99F1D6B0B8473534 /* HybridFeedView.swift in Sources */ = {isa = PBXBuildFile; fileRef = F3319498B3CFE8B8270ACBCC /* HybridFeedView.swift */; };
		9B5E2280A6B1D40EB14EF146 /* FollowingListView.swift in Sources */ = {isa = PBXBuildFile; fileRef = F72B83ED7201352D81B038D4 /* FollowingListView.swift */; };
		9D8D0E11AFFAEBF826CA8C35 /* ModernAuthenticationView.swift in Sources */ = {isa = PBXBuildFile; fileRef = C698E368C385A545D9B0F4C2 /* ModernAuthenticationView.swift */; };
		A06F95F603A679D35B71830C /* UnifiedCard.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5AFA2646020373D085219CD1 /* UnifiedCard.swift */; };
		A14D87798BCA853B8ADB1094 /* ProfileManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 0CD20236BF86EF8694B01BCB /* ProfileManager.swift */; };
		A25241FBBFAFEE09E8F309E6 /* HapticManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 01F9CBDB1F581FAFF82499ED /* HapticManager.swift */; };
		A511B4B1AC90D691C950B6DC /* NDKSwiftUI in Frameworks */ = {isa = PBXBuildFile; productRef = 066BFE60CA36619DDAF24249 /* NDKSwiftUI */; };
		A739FE09A2C884E11551A2BB /* EnhancedProfileView.swift in Sources */ = {isa = PBXBuildFile; fileRef = F15148C260C39965515937DF /* EnhancedProfileView.swift */; };
		AB4EF72007DE04801039B67B /* SettingsView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9D458CCB519B3373BBBAA25E /* SettingsView.swift */; };
		AF1A4BFA9BE71CF3751C398C /* LoadingEffects.swift in Sources */ = {isa = PBXBuildFile; fileRef = B74E92E048F2C0386036F8B7 /* LoadingEffects.swift */; };
		B27F8ADE7A1BC93C9447C110 /* LightningWalletView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 38C2252299BA0F18F563B8D8 /* LightningWalletView.swift */; };
		B5E8FDE244E748C0EBA0335C /* ZapButton.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5C5A696D9CC2601B91DA0191 /* ZapButton.swift */; };
		BB60DB5A67DACB9C750CA1D2 /* Article.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1218D531D7715736DC097843 /* Article.swift */; };
		BB6FCDFCD2C12203AE651B67 /* CurationManagementView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 15E27589CBE68F327B765B12 /* CurationManagementView.swift */; };
		BB95A1839717B5CFCB24CD1B /* ImportComponents.swift in Sources */ = {isa = PBXBuildFile; fileRef = D304A7FFF9887A1BBC5CD4A5 /* ImportComponents.swift */; };
		BBB5FE528CE36307A00C6870 /* FollowPackDetailView.swift in Sources */ = {isa = PBXBuildFile; fileRef = A0D6F1E556E98D164B99B869 /* FollowPackDetailView.swift */; };
		BE7B648769FD679A8E81418A /* HighlightsFeedView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8C6C4024D5AE536DD3ADC4C4 /* HighlightsFeedView.swift */; };
		BEEFC7E63EE19685B859327B /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = C3CDA726BB07F1F8F89ABF1C /* Assets.xcassets */; };
		C2AD1BBC79D059AF8C6F6DC9 /* SimplifiedHybridFeedView.swift in Sources */ = {isa = PBXBuildFile; fileRef = C1770A666CC88A1326723FA2 /* SimplifiedHybridFeedView.swift */; };
		C975491F710CDEF803054F4B /* ModernButtonStyles.swift in Sources */ = {isa = PBXBuildFile; fileRef = B4CAEDCB43E983D35EC24C74 /* ModernButtonStyles.swift */; };
		D20F6E78AD2F5EF5E0D3E7CC /* MeshGradientBackground.swift in Sources */ = {isa = PBXBuildFile; fileRef = 06EC35345A13411260DCEEF7 /* MeshGradientBackground.swift */; };
		D3BD7A0160EE2E26A8529370 /* SharedStyles.swift in Sources */ = {isa = PBXBuildFile; fileRef = D715EDA3BA34145E7508D03E /* SharedStyles.swift */; };
		D6A56128381947ACC6639CC6 /* HighlightEvent.swift in Sources */ = {isa = PBXBuildFile; fileRef = 0151014CE7E449B5BE685BE8 /* HighlightEvent.swift */; };
		D6BF6DEBA828B3B11D10832E /* CurationDetailView.swift in Sources */ = {isa = PBXBuildFile; fileRef = D807FD00E2D24A226C0CA61A /* CurationDetailView.swift */; };
		DDE1B699AD2C62049E2AF2E3 /* ModernViewModifiers.swift in Sources */ = {isa = PBXBuildFile; fileRef = CC98504899CC29F4D15C2A92 /* ModernViewModifiers.swift */; };
		DEF4ACD6D408D383F02A9C06 /* NDKSwift in Frameworks */ = {isa = PBXBuildFile; productRef = 8F0120155B5FA6FCE7E43793 /* NDKSwift */; };
		E3A00B68BDE7C21BA3CD80C2 /* UserDiscoveryView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 374EC425180288ED47940087 /* UserDiscoveryView.swift */; };
		E85CEAE60DFDAE1A4E709ED0 /* CreateHighlightView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 513F373BC7DB42A589AB44E8 /* CreateHighlightView.swift */; };
		EDF1676E64A7D57933E21659 /* SwarmHeatmapView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 2A30F0A9531B551A701C1BD7 /* SwarmHeatmapView.swift */; };
		F3882617AB54096ECD0A9CB3 /* SearchView.swift in Sources */ = {isa = PBXBuildFile; fileRef = E14D0DCA79BDAC73A9F20925 /* SearchView.swift */; };
/* End PBXBuildFile section */

/* Begin PBXFileReference section */
		0151014CE7E449B5BE685BE8 /* HighlightEvent.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HighlightEvent.swift; sourceTree = "<group>"; };
		01F9CBDB1F581FAFF82499ED /* HapticManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HapticManager.swift; sourceTree = "<group>"; };
		03DEF9DECD6C6F4D9AF8C400 /* FollowPack.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FollowPack.swift; sourceTree = "<group>"; };
		06EC35345A13411260DCEEF7 /* MeshGradientBackground.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MeshGradientBackground.swift; sourceTree = "<group>"; };
		08C9371F823E831254881AA4 /* FollowersListView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FollowersListView.swift; sourceTree = "<group>"; };
		0CD20236BF86EF8694B01BCB /* ProfileManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ProfileManager.swift; sourceTree = "<group>"; };
		1218D531D7715736DC097843 /* Article.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Article.swift; sourceTree = "<group>"; };
		15E27589CBE68F327B765B12 /* CurationManagementView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CurationManagementView.swift; sourceTree = "<group>"; };
		19C631ECAA0313B22AD50212 /* HighlightCard.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HighlightCard.swift; sourceTree = "<group>"; };
		1A3025E76E14FBF1C8D93736 /* DesignSystem.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DesignSystem.swift; sourceTree = "<group>"; };
		288947C11C084EEA395DB4F3 /* ContentView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContentView.swift; sourceTree = "<group>"; };
		2A30F0A9531B551A701C1BD7 /* SwarmHeatmapView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SwarmHeatmapView.swift; sourceTree = "<group>"; };
		321C2E8C6CB80D3B280CC5CA /* AudioPlayerView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AudioPlayerView.swift; sourceTree = "<group>"; };
		340014DACEA6C5443AE37553 /* TextSelectionView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TextSelectionView.swift; sourceTree = "<group>"; };
		374EC425180288ED47940087 /* UserDiscoveryView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = UserDiscoveryView.swift; sourceTree = "<group>"; };
		38C2252299BA0F18F563B8D8 /* LightningWalletView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LightningWalletView.swift; sourceTree = "<group>"; };
		39B251BEAE7C275E85EB1BC1 /* CurationDiscoveryView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CurationDiscoveryView.swift; sourceTree = "<group>"; };
		3EE49BE02AE3ECE3BD63A825 /* SmartContentImporter.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SmartContentImporter.swift; sourceTree = "<group>"; };
		4065018869D27C2992BD8E09 /* OnboardingView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = OnboardingView.swift; sourceTree = "<group>"; };
		47D8FA7B43386CEE13EB7B18 /* DataStreamManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = DataStreamManager.swift; sourceTree = "<group>"; };
		4CF27270F57B25E33B719EEC /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist; path = Info.plist; sourceTree = "<group>"; };
		4E36C3396966D42A6A522C05 /* CardSystem.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CardSystem.swift; sourceTree = "<group>"; };
		513F373BC7DB42A589AB44E8 /* CreateHighlightView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CreateHighlightView.swift; sourceTree = "<group>"; };
		552D71BE7E32CED89D35A278 /* LibraryView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LibraryView.swift; sourceTree = "<group>"; };
		5818E9E0A5081751B12C7A05 /* LightningService.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LightningService.swift; sourceTree = "<group>"; };
		5AFA2646020373D085219CD1 /* UnifiedCard.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = UnifiedCard.swift; sourceTree = "<group>"; };
		5C5A696D9CC2601B91DA0191 /* ZapButton.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ZapButton.swift; sourceTree = "<group>"; };
		5C9A8C38CB54B7E5605AF14A /* BlurHashDecoder.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BlurHashDecoder.swift; sourceTree = "<group>"; };
		5E06D1E90D26910A32BBA586 /* AppState.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppState.swift; sourceTree = "<group>"; };
		62A24BA9AAF6CD7CBED4A5EB /* VisualEffects.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = VisualEffects.swift; sourceTree = "<group>"; };
		68EE862B30307430C752F295 /* SelectableMarkdownRenderer.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SelectableMarkdownRenderer.swift; sourceTree = "<group>"; };
		71A83CD10503C7B187BEE747 /* ArticleView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ArticleView.swift; sourceTree = "<group>"; };
		7542540C7ACFB260E24E01B2 /* PublishingService.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PublishingService.swift; sourceTree = "<group>"; };
		B5A2C1D87ACFB260E24E01B3 /* BookmarkService.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = BookmarkService.swift; sourceTree = "<group>"; };
		C3B4D2E87ACFB260E24E01B4 /* CommentService.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CommentService.swift; sourceTree = "<group>"; };
		83206D6462CF11DCF490672D /* SwarmOverlayView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SwarmOverlayView.swift; sourceTree = "<group>"; };
		842FF8B20D37A2852B7A0ED9 /* HighlightDetailView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HighlightDetailView.swift; sourceTree = "<group>"; };
		8C6C4024D5AE536DD3ADC4C4 /* HighlightsFeedView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HighlightsFeedView.swift; sourceTree = "<group>"; };
		923EDFDDF5D99390303E706B /* .repomix-output.txt */ = {isa = PBXFileReference; lastKnownFileType = text; path = ".repomix-output.txt"; sourceTree = "<group>"; };
		96BB1CEB6B1AF8996372B0A9 /* ModernFormComponents.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ModernFormComponents.swift; sourceTree = "<group>"; };
		978B907455CE5F514DADD37A /* LightningPaymentFlowView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LightningPaymentFlowView.swift; sourceTree = "<group>"; };
		9831C9AF1F1938111965B8CE /* ModernTabBar.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ModernTabBar.swift; sourceTree = "<group>"; };
		9906E08DF53F3E88E7370583 /* SwarmHighlight.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SwarmHighlight.swift; sourceTree = "<group>"; };
		9908B54604FDE004C8DED14E /* AIAnalysisVisualizationView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AIAnalysisVisualizationView.swift; sourceTree = "<group>"; };
		9D458CCB519B3373BBBAA25E /* SettingsView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SettingsView.swift; sourceTree = "<group>"; };
		9FE479875030C79E23CEC371 /* CreateCurationView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CreateCurationView.swift; sourceTree = "<group>"; };
		A0D6F1E556E98D164B99B869 /* FollowPackDetailView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FollowPackDetailView.swift; sourceTree = "<group>"; };
		A2CDAC5B2099CFF6ED8BE9AE /* ArticleCuration.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ArticleCuration.swift; sourceTree = "<group>"; };
		A4C6D9AB2A21C93E8951D6E4 /* SmartArticleImportView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SmartArticleImportView.swift; sourceTree = "<group>"; };
		A89145FF0C6BCD85C2ADB6B0 /* ArticleListView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ArticleListView.swift; sourceTree = "<group>"; };
		A9A59DD7DD81D1FEB67B662D /* AIHighlightEngine.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AIHighlightEngine.swift; sourceTree = "<group>"; };
		B4C72655D262C9FB9C686CAF /* HighlightDiscoveryView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HighlightDiscoveryView.swift; sourceTree = "<group>"; };
		B4CAEDCB43E983D35EC24C74 /* ModernButtonStyles.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ModernButtonStyles.swift; sourceTree = "<group>"; };
		B732C4AF8ED87EBB93D6D0D5 /* EditProfileView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = EditProfileView.swift; sourceTree = "<group>"; };
		B74E92E048F2C0386036F8B7 /* LoadingEffects.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LoadingEffects.swift; sourceTree = "<group>"; };
		C1770A666CC88A1326723FA2 /* SimplifiedHybridFeedView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SimplifiedHybridFeedView.swift; sourceTree = "<group>"; };
		C3CDA726BB07F1F8F89ABF1C /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		C698E368C385A545D9B0F4C2 /* ModernAuthenticationView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ModernAuthenticationView.swift; sourceTree = "<group>"; };
		C7EB0BF21A403BF70E3A314B /* NDKSwift-z94ws0 */ = {isa = PBXFileReference; lastKnownFileType = folder; name = "NDKSwift-z94ws0"; path = ../../..; sourceTree = SOURCE_ROOT; };
		C88288E64D986A7B021700F9 /* AnimationSystem.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AnimationSystem.swift; sourceTree = "<group>"; };
		CC98504899CC29F4D15C2A92 /* ModernViewModifiers.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ModernViewModifiers.swift; sourceTree = "<group>"; };
		CC9C86787D8110767C109BBB /* ButtonSystem.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ButtonSystem.swift; sourceTree = "<group>"; };
		D01FA9F607102E7402D96CA8 /* FormattingUtilities.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FormattingUtilities.swift; sourceTree = "<group>"; };
		D304A7FFF9887A1BBC5CD4A5 /* ImportComponents.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ImportComponents.swift; sourceTree = "<group>"; };
		D48EA35CD61779F2D9DC5964 /* ProfileView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ProfileView.swift; sourceTree = "<group>"; };
		D715EDA3BA34145E7508D03E /* SharedStyles.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SharedStyles.swift; sourceTree = "<group>"; };
		D807FD00E2D24A226C0CA61A /* CurationDetailView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CurationDetailView.swift; sourceTree = "<group>"; };
		D969455E05A9A63B81679E4A /* ArticleDiscoveryView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ArticleDiscoveryView.swift; sourceTree = "<group>"; };
		E14D0DCA79BDAC73A9F20925 /* SearchView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SearchView.swift; sourceTree = "<group>"; };
		F15148C260C39965515937DF /* EnhancedProfileView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = EnhancedProfileView.swift; sourceTree = "<group>"; };
		F3319498B3CFE8B8270ACBCC /* HybridFeedView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HybridFeedView.swift; sourceTree = "<group>"; };
		F6C338502340BD8BE768794B /* HomeDataManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HomeDataManager.swift; sourceTree = "<group>"; };
		F72B83ED7201352D81B038D4 /* FollowingListView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FollowingListView.swift; sourceTree = "<group>"; };
		FA46623C808023B5D65EB473 /* ModernStateViews.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ModernStateViews.swift; sourceTree = "<group>"; };
		FC1A44A034DF17AF520B0742 /* Highlighter.app */ = {isa = PBXFileReference; includeInIndex = 0; lastKnownFileType = wrapper.application; path = Highlighter.app; sourceTree = BUILT_PRODUCTS_DIR; };
		FD69175DE127E1B1E7016D16 /* HighlighterApp.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HighlighterApp.swift; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		EBBAD177BF9F8EB2C9249922 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				DEF4ACD6D408D383F02A9C06 /* NDKSwift in Frameworks */,
				A511B4B1AC90D691C950B6DC /* NDKSwiftUI in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		19F0228E7B8B298952560FB4 /* Articles */ = {
			isa = PBXGroup;
			children = (
				A89145FF0C6BCD85C2ADB6B0 /* ArticleListView.swift */,
				71A83CD10503C7B187BEE747 /* ArticleView.swift */,
			);
			path = Articles;
			sourceTree = "<group>";
		};
		1BE6B5A8F7E606E138637834 /* Highlights */ = {
			isa = PBXGroup;
			children = (
				513F373BC7DB42A589AB44E8 /* CreateHighlightView.swift */,
				842FF8B20D37A2852B7A0ED9 /* HighlightDetailView.swift */,
				8C6C4024D5AE536DD3ADC4C4 /* HighlightsFeedView.swift */,
				2A30F0A9531B551A701C1BD7 /* SwarmHeatmapView.swift */,
				83206D6462CF11DCF490672D /* SwarmOverlayView.swift */,
				340014DACEA6C5443AE37553 /* TextSelectionView.swift */,
			);
			path = Highlights;
			sourceTree = "<group>";
		};
		1F5456C944AAF1D25D070180 /* Resources */ = {
			isa = PBXGroup;
			children = (
				C3CDA726BB07F1F8F89ABF1C /* Assets.xcassets */,
			);
			path = Resources;
			sourceTree = "<group>";
		};
		39FEB9D7BEBF39D76C295F55 /* Sources */ = {
			isa = PBXGroup;
			children = (
				5C5092D44CBD1311F16457AE /* Highlighter */,
				923EDFDDF5D99390303E706B /* .repomix-output.txt */,
			);
			path = Sources;
			sourceTree = "<group>";
		};
		3BA70AC6F11F7F5E6818AC87 /* Library */ = {
			isa = PBXGroup;
			children = (
				552D71BE7E32CED89D35A278 /* LibraryView.swift */,
			);
			path = Library;
			sourceTree = "<group>";
		};
		413D3DAEE4E538F6BE0D214D /* Lightning */ = {
			isa = PBXGroup;
			children = (
				978B907455CE5F514DADD37A /* LightningPaymentFlowView.swift */,
				38C2252299BA0F18F563B8D8 /* LightningWalletView.swift */,
			);
			path = Lightning;
			sourceTree = "<group>";
		};
		4782E11285C89DBB8E6C72D5 /* Discovery */ = {
			isa = PBXGroup;
			children = (
				D969455E05A9A63B81679E4A /* ArticleDiscoveryView.swift */,
				39B251BEAE7C275E85EB1BC1 /* CurationDiscoveryView.swift */,
				B4C72655D262C9FB9C686CAF /* HighlightDiscoveryView.swift */,
				E14D0DCA79BDAC73A9F20925 /* SearchView.swift */,
				374EC425180288ED47940087 /* UserDiscoveryView.swift */,
			);
			path = Discovery;
			sourceTree = "<group>";
		};
		4E710612FC2266FC921A8A16 /* Packages */ = {
			isa = PBXGroup;
			children = (
				C7EB0BF21A403BF70E3A314B /* NDKSwift-z94ws0 */,
			);
			name = Packages;
			sourceTree = "<group>";
		};
		5B7B339EEBD21CB543AA2E53 /* Audio */ = {
			isa = PBXGroup;
			children = (
				321C2E8C6CB80D3B280CC5CA /* AudioPlayerView.swift */,
			);
			path = Audio;
			sourceTree = "<group>";
		};
		5C5092D44CBD1311F16457AE /* Highlighter */ = {
			isa = PBXGroup;
			children = (
				5CF1AED8601BA4581B6B85AA /* App */,
				8EFCBA92733165A7AE1A2405 /* Design */,
				D6A97FFD17E8ADA86E5A981C /* Models */,
				F7E48321CF585FC04732E331 /* Services */,
				F815E3C9708A3F35B589736E /* Utilities */,
				8EC0E41A5D74B7C0C65A4FFC /* Views */,
			);
			path = Highlighter;
			sourceTree = "<group>";
		};
		5CF1AED8601BA4581B6B85AA /* App */ = {
			isa = PBXGroup;
			children = (
				FD69175DE127E1B1E7016D16 /* HighlighterApp.swift */,
				4CF27270F57B25E33B719EEC /* Info.plist */,
			);
			path = App;
			sourceTree = "<group>";
		};
		63A8F85A09AF2D4F4447244A /* Profile */ = {
			isa = PBXGroup;
			children = (
				B732C4AF8ED87EBB93D6D0D5 /* EditProfileView.swift */,
				F15148C260C39965515937DF /* EnhancedProfileView.swift */,
				08C9371F823E831254881AA4 /* FollowersListView.swift */,
				F72B83ED7201352D81B038D4 /* FollowingListView.swift */,
				D48EA35CD61779F2D9DC5964 /* ProfileView.swift */,
			);
			path = Profile;
			sourceTree = "<group>";
		};
		64A6B594727A1861B42545BA /* Onboarding */ = {
			isa = PBXGroup;
			children = (
				4065018869D27C2992BD8E09 /* OnboardingView.swift */,
			);
			path = Onboarding;
			sourceTree = "<group>";
		};
		8ABF125189E0C40627D3EAF7 /* AIAnalysis */ = {
			isa = PBXGroup;
			children = (
				9908B54604FDE004C8DED14E /* AIAnalysisVisualizationView.swift */,
			);
			path = AIAnalysis;
			sourceTree = "<group>";
		};
		8EC0E41A5D74B7C0C65A4FFC /* Views */ = {
			isa = PBXGroup;
			children = (
				8ABF125189E0C40627D3EAF7 /* AIAnalysis */,
				19F0228E7B8B298952560FB4 /* Articles */,
				5B7B339EEBD21CB543AA2E53 /* Audio */,
				90C93336BA03E29727F3F41E /* Auth */,
				BAA23907C66EADBD8573C18D /* Components */,
				B3034590C7DD7082D45C3E05 /* Curations */,
				4782E11285C89DBB8E6C72D5 /* Discovery */,
				BE975894F1EF97E8483A19C3 /* FollowPacks */,
				1BE6B5A8F7E606E138637834 /* Highlights */,
				D044A4B341EB448FA79018CE /* Home */,
				CE5B2ECC46148A6CF97F6A0B /* Import */,
				3BA70AC6F11F7F5E6818AC87 /* Library */,
				413D3DAEE4E538F6BE0D214D /* Lightning */,
				64A6B594727A1861B42545BA /* Onboarding */,
				63A8F85A09AF2D4F4447244A /* Profile */,
				AE7D045BA27B51D68995A1AB /* Settings */,
				288947C11C084EEA395DB4F3 /* ContentView.swift */,
			);
			path = Views;
			sourceTree = "<group>";
		};
		8EFCBA92733165A7AE1A2405 /* Design */ = {
			isa = PBXGroup;
			children = (
				C88288E64D986A7B021700F9 /* AnimationSystem.swift */,
				CC9C86787D8110767C109BBB /* ButtonSystem.swift */,
				4E36C3396966D42A6A522C05 /* CardSystem.swift */,
				1A3025E76E14FBF1C8D93736 /* DesignSystem.swift */,
				B74E92E048F2C0386036F8B7 /* LoadingEffects.swift */,
				CC98504899CC29F4D15C2A92 /* ModernViewModifiers.swift */,
				62A24BA9AAF6CD7CBED4A5EB /* VisualEffects.swift */,
			);
			path = Design;
			sourceTree = "<group>";
		};
		90C93336BA03E29727F3F41E /* Auth */ = {
			isa = PBXGroup;
			children = (
				C698E368C385A545D9B0F4C2 /* ModernAuthenticationView.swift */,
			);
			path = Auth;
			sourceTree = "<group>";
		};
		9288D1FF044AFA08F6DE9CC7 /* Products */ = {
			isa = PBXGroup;
			children = (
				FC1A44A034DF17AF520B0742 /* Highlighter.app */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		A041F7C169CA548DDDDDFE27 = {
			isa = PBXGroup;
			children = (
				4E710612FC2266FC921A8A16 /* Packages */,
				1F5456C944AAF1D25D070180 /* Resources */,
				39FEB9D7BEBF39D76C295F55 /* Sources */,
				9288D1FF044AFA08F6DE9CC7 /* Products */,
			);
			sourceTree = "<group>";
		};
		AE7D045BA27B51D68995A1AB /* Settings */ = {
			isa = PBXGroup;
			children = (
				9D458CCB519B3373BBBAA25E /* SettingsView.swift */,
			);
			path = Settings;
			sourceTree = "<group>";
		};
		B3034590C7DD7082D45C3E05 /* Curations */ = {
			isa = PBXGroup;
			children = (
				9FE479875030C79E23CEC371 /* CreateCurationView.swift */,
				D807FD00E2D24A226C0CA61A /* CurationDetailView.swift */,
				15E27589CBE68F327B765B12 /* CurationManagementView.swift */,
			);
			path = Curations;
			sourceTree = "<group>";
		};
		BAA23907C66EADBD8573C18D /* Components */ = {
			isa = PBXGroup;
			children = (
				D4C5E3F87ACFB260E24E01B5 /* CommentView.swift */,
				19C631ECAA0313B22AD50212 /* HighlightCard.swift */,
				06EC35345A13411260DCEEF7 /* MeshGradientBackground.swift */,
				B4CAEDCB43E983D35EC24C74 /* ModernButtonStyles.swift */,
				96BB1CEB6B1AF8996372B0A9 /* ModernFormComponents.swift */,
				FA46623C808023B5D65EB473 /* ModernStateViews.swift */,
				9831C9AF1F1938111965B8CE /* ModernTabBar.swift */,
				68EE862B30307430C752F295 /* SelectableMarkdownRenderer.swift */,
				D715EDA3BA34145E7508D03E /* SharedStyles.swift */,
				5AFA2646020373D085219CD1 /* UnifiedCard.swift */,
				5C5A696D9CC2601B91DA0191 /* ZapButton.swift */,
			);
			path = Components;
			sourceTree = "<group>";
		};
		BE975894F1EF97E8483A19C3 /* FollowPacks */ = {
			isa = PBXGroup;
			children = (
				A0D6F1E556E98D164B99B869 /* FollowPackDetailView.swift */,
			);
			path = FollowPacks;
			sourceTree = "<group>";
		};
		CE5B2ECC46148A6CF97F6A0B /* Import */ = {
			isa = PBXGroup;
			children = (
				D304A7FFF9887A1BBC5CD4A5 /* ImportComponents.swift */,
				A4C6D9AB2A21C93E8951D6E4 /* SmartArticleImportView.swift */,
				3EE49BE02AE3ECE3BD63A825 /* SmartContentImporter.swift */,
			);
			path = Import;
			sourceTree = "<group>";
		};
		D044A4B341EB448FA79018CE /* Home */ = {
			isa = PBXGroup;
			children = (
				F6C338502340BD8BE768794B /* HomeDataManager.swift */,
				F3319498B3CFE8B8270ACBCC /* HybridFeedView.swift */,
				C1770A666CC88A1326723FA2 /* SimplifiedHybridFeedView.swift */,
			);
			path = Home;
			sourceTree = "<group>";
		};
		D6A97FFD17E8ADA86E5A981C /* Models */ = {
			isa = PBXGroup;
			children = (
				5E06D1E90D26910A32BBA586 /* AppState.swift */,
				1218D531D7715736DC097843 /* Article.swift */,
				A2CDAC5B2099CFF6ED8BE9AE /* ArticleCuration.swift */,
				03DEF9DECD6C6F4D9AF8C400 /* FollowPack.swift */,
				0151014CE7E449B5BE685BE8 /* HighlightEvent.swift */,
				9906E08DF53F3E88E7370583 /* SwarmHighlight.swift */,
			);
			path = Models;
			sourceTree = "<group>";
		};
		F7E48321CF585FC04732E331 /* Services */ = {
			isa = PBXGroup;
			children = (
				A9A59DD7DD81D1FEB67B662D /* AIHighlightEngine.swift */,
				B5A2C1D87ACFB260E24E01B3 /* BookmarkService.swift */,
				C3B4D2E87ACFB260E24E01B4 /* CommentService.swift */,
				47D8FA7B43386CEE13EB7B18 /* DataStreamManager.swift */,
				5818E9E0A5081751B12C7A05 /* LightningService.swift */,
				0CD20236BF86EF8694B01BCB /* ProfileManager.swift */,
				7542540C7ACFB260E24E01B2 /* PublishingService.swift */,
			);
			path = Services;
			sourceTree = "<group>";
		};
		F815E3C9708A3F35B589736E /* Utilities */ = {
			isa = PBXGroup;
			children = (
				5C9A8C38CB54B7E5605AF14A /* BlurHashDecoder.swift */,
				D01FA9F607102E7402D96CA8 /* FormattingUtilities.swift */,
				01F9CBDB1F581FAFF82499ED /* HapticManager.swift */,
			);
			path = Utilities;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		8E948B0930F062DF95681D44 /* Highlighter */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 926740433E7A2EE00A345540 /* Build configuration list for PBXNativeTarget "Highlighter" */;
			buildPhases = (
				C0AFB726729D926CC7127A53 /* Sources */,
				281E82334AE8EE87BE5DF3A7 /* Resources */,
				EBBAD177BF9F8EB2C9249922 /* Frameworks */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = Highlighter;
			packageProductDependencies = (
				8F0120155B5FA6FCE7E43793 /* NDKSwift */,
				066BFE60CA36619DDAF24249 /* NDKSwiftUI */,
			);
			productName = Highlighter;
			productReference = FC1A44A034DF17AF520B0742 /* Highlighter.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		6906FF56AA4A1447D26D2625 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = YES;
				LastUpgradeCheck = 1430;
				TargetAttributes = {
					8E948B0930F062DF95681D44 = {
						DevelopmentTeam = "";
					};
				};
			};
			buildConfigurationList = C6B8D44965599E33DF88E458 /* Build configuration list for PBXProject "Highlighter" */;
			compatibilityVersion = "Xcode 14.0";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				Base,
				en,
			);
			mainGroup = A041F7C169CA548DDDDDFE27;
			minimizedProjectReferenceProxies = 1;
			packageReferences = (
				E2A19ADCA3C16B878073A1A5 /* XCLocalSwiftPackageReference "../../..//" */,
			);
			preferredProjectObjectVersion = 54;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				8E948B0930F062DF95681D44 /* Highlighter */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		281E82334AE8EE87BE5DF3A7 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				483E4645826EA9B78961A7BD /* .repomix-output.txt in Resources */,
				BEEFC7E63EE19685B859327B /* Assets.xcassets in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		C0AFB726729D926CC7127A53 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				79849E68684EC926B32E78C9 /* AIAnalysisVisualizationView.swift in Sources */,
				5328876790B7FC8B3F06147C /* AIHighlightEngine.swift in Sources */,
				58CD029928844C6A40946A74 /* AnimationSystem.swift in Sources */,
				218363F8C03885960CF5D248 /* AppState.swift in Sources */,
				BB60DB5A67DACB9C750CA1D2 /* Article.swift in Sources */,
				3DDAE1A8FD5B8746688B9D12 /* ArticleCuration.swift in Sources */,
				69E892C13A2D7E562F67039A /* ArticleDiscoveryView.swift in Sources */,
				1B99932C8DCDEBA4FB239749 /* ArticleListView.swift in Sources */,
				8D5D97226F6D2C4ABE8631F3 /* ArticleView.swift in Sources */,
				3DFA64BB9C00F7D7EDBB3E38 /* AudioPlayerView.swift in Sources */,
				56884CA05833E2E75660E7E3 /* BlurHashDecoder.swift in Sources */,
				584216E80F87025A63620635 /* ButtonSystem.swift in Sources */,
				31CEBD7F410053E533CDE2BA /* CardSystem.swift in Sources */,
				4F557938220F55296A4E483F /* ContentView.swift in Sources */,
				73EF0B3EADF9149125478230 /* CreateCurationView.swift in Sources */,
				E85CEAE60DFDAE1A4E709ED0 /* CreateHighlightView.swift in Sources */,
				D6BF6DEBA828B3B11D10832E /* CurationDetailView.swift in Sources */,
				7686328E9D95E29C8EA0B48F /* CurationDiscoveryView.swift in Sources */,
				BB6FCDFCD2C12203AE651B67 /* CurationManagementView.swift in Sources */,
				5D62AE907A0A91BECED7DCD4 /* DataStreamManager.swift in Sources */,
				8B1648772C86AD40FCF6602E /* DesignSystem.swift in Sources */,
				65B0F76A54167561B653A458 /* EditProfileView.swift in Sources */,
				A739FE09A2C884E11551A2BB /* EnhancedProfileView.swift in Sources */,
				2207FFA98AB56815A584DDB4 /* FollowPack.swift in Sources */,
				BBB5FE528CE36307A00C6870 /* FollowPackDetailView.swift in Sources */,
				8A5C45073A61569328188B21 /* FollowersListView.swift in Sources */,
				9B5E2280A6B1D40EB14EF146 /* FollowingListView.swift in Sources */,
				6B3A6908C6C27D35E9C37F28 /* FormattingUtilities.swift in Sources */,
				A25241FBBFAFEE09E8F309E6 /* HapticManager.swift in Sources */,
				6462DC934F3BCE00CEEE8BF8 /* HighlightCard.swift in Sources */,
				3A1255EBF3357C89B1E648F6 /* HighlightDetailView.swift in Sources */,
				63ED41BC7DD413BEE595F3A9 /* HighlightDiscoveryView.swift in Sources */,
				D6A56128381947ACC6639CC6 /* HighlightEvent.swift in Sources */,
				91774403D5A6E567EB9879C6 /* HighlighterApp.swift in Sources */,
				BE7B648769FD679A8E81418A /* HighlightsFeedView.swift in Sources */,
				34DF18AC7EC3EE0F46E1A1A3 /* HomeDataManager.swift in Sources */,
				9A7FB11D99F1D6B0B8473534 /* HybridFeedView.swift in Sources */,
				BB95A1839717B5CFCB24CD1B /* ImportComponents.swift in Sources */,
				39ED8F05509F9A4FFF466557 /* LibraryView.swift in Sources */,
				8CC027C461CC53CF47AC2ECB /* LightningPaymentFlowView.swift in Sources */,
				0CAD93077385698E44D03486 /* LightningService.swift in Sources */,
				B27F8ADE7A1BC93C9447C110 /* LightningWalletView.swift in Sources */,
				AF1A4BFA9BE71CF3751C398C /* LoadingEffects.swift in Sources */,
				D20F6E78AD2F5EF5E0D3E7CC /* MeshGradientBackground.swift in Sources */,
				9D8D0E11AFFAEBF826CA8C35 /* ModernAuthenticationView.swift in Sources */,
				C975491F710CDEF803054F4B /* ModernButtonStyles.swift in Sources */,
				981A640F5DAAE1DC2566BE65 /* ModernFormComponents.swift in Sources */,
				410141EDC0B7B0D01CCE3452 /* ModernStateViews.swift in Sources */,
				8691D5E4EAF2824D10C0E28B /* ModernTabBar.swift in Sources */,
				DDE1B699AD2C62049E2AF2E3 /* ModernViewModifiers.swift in Sources */,
				224179F5F3F178E3DEFA54FF /* OnboardingView.swift in Sources */,
				A14D87798BCA853B8ADB1094 /* ProfileManager.swift in Sources */,
				762E0B52E6C34458CB162E73 /* ProfileView.swift in Sources */,
				43920B59A88E931B495919A8 /* PublishingService.swift in Sources */,
				B5A2C1D9A88E931B495919A9 /* BookmarkService.swift in Sources */,
				C3B4D2E9A88E931B495919B9 /* CommentService.swift in Sources */,
				F3882617AB54096ECD0A9CB3 /* SearchView.swift in Sources */,
				2629890795B6D0A577BF09D3 /* SelectableMarkdownRenderer.swift in Sources */,
				AB4EF72007DE04801039B67B /* SettingsView.swift in Sources */,
				D3BD7A0160EE2E26A8529370 /* SharedStyles.swift in Sources */,
				C2AD1BBC79D059AF8C6F6DC9 /* SimplifiedHybridFeedView.swift in Sources */,
				592922A038AC7CEB7AAD35F7 /* SmartArticleImportView.swift in Sources */,
				99A884B98EA5E9A9DD9BFC8F /* SmartContentImporter.swift in Sources */,
				EDF1676E64A7D57933E21659 /* SwarmHeatmapView.swift in Sources */,
				06F1FA7B9C3130D22B35D122 /* SwarmHighlight.swift in Sources */,
				6972D167F453E975971B28E6 /* SwarmOverlayView.swift in Sources */,
				07E3CDA432D5B26DF5747DDD /* TextSelectionView.swift in Sources */,
				A06F95F603A679D35B71830C /* UnifiedCard.swift in Sources */,
				E3A00B68BDE7C21BA3CD80C2 /* UserDiscoveryView.swift in Sources */,
				8EE197235B1A83A04B155F56 /* VisualEffects.swift in Sources */,
				B5E8FDE244E748C0EBA0335C /* ZapButton.swift in Sources */,
				D4C5E3F87ACFB260E24E01B5 /* CommentView.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin XCBuildConfiguration section */
		5330ADE746DE8990CCF5809D /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_IDENTITY = "iPhone Developer";
				CURRENT_PROJECT_VERSION = 1;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				DEVELOPMENT_TEAM = "";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_PREVIEWS = YES;
				ENABLE_TESTABILITY = NO;
				GCC_OPTIMIZATION_LEVEL = s;
				GENERATE_INFOPLIST_FILE = NO;
				INFOPLIST_FILE = Sources/Highlighter/App/Info.plist;
				IPHONEOS_DEPLOYMENT_TARGET = 17.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				PRODUCT_BUNDLE_IDENTIFIER = com.highlighter.ios;
				PRODUCT_NAME = Highlighter;
				SDKROOT = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
				SWIFT_VERSION = 5.9;
				TARGETED_DEVICE_FAMILY = 1;
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		85B35509121C976A40E13889 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_IDENTITY = "iPhone Developer";
				CURRENT_PROJECT_VERSION = 1;
				DEBUG_INFORMATION_FORMAT = dwarf;
				DEVELOPMENT_TEAM = "";
				ENABLE_PREVIEWS = YES;
				ENABLE_TESTABILITY = YES;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = "DEBUG=1";
				GENERATE_INFOPLIST_FILE = NO;
				INFOPLIST_FILE = Sources/Highlighter/App/Info.plist;
				IPHONEOS_DEPLOYMENT_TARGET = 17.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0.0;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				ONLY_ACTIVE_ARCH = YES;
				PRODUCT_BUNDLE_IDENTIFIER = com.highlighter.ios;
				PRODUCT_NAME = Highlighter;
				SDKROOT = iphoneos;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.9;
				TARGETED_DEVICE_FAMILY = 1;
			};
			name = Debug;
		};
		8D9B7AF489D02D1398BB436A /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 17.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
				SWIFT_VERSION = 5.0;
			};
			name = Release;
		};
		C259E84248B1655A211B5F59 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"$(inherited)",
					"DEBUG=1",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 17.0;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = iphoneos;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
			};
			name = Debug;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		926740433E7A2EE00A345540 /* Build configuration list for PBXNativeTarget "Highlighter" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				85B35509121C976A40E13889 /* Debug */,
				5330ADE746DE8990CCF5809D /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Debug;
		};
		C6B8D44965599E33DF88E458 /* Build configuration list for PBXProject "Highlighter" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				C259E84248B1655A211B5F59 /* Debug */,
				8D9B7AF489D02D1398BB436A /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Debug;
		};
/* End XCConfigurationList section */

/* Begin XCLocalSwiftPackageReference section */
		E2A19ADCA3C16B878073A1A5 /* XCLocalSwiftPackageReference "../../..//" */ = {
			isa = XCLocalSwiftPackageReference;
			relativePath = "../../..//";
		};
/* End XCLocalSwiftPackageReference section */

/* Begin XCSwiftPackageProductDependency section */
		066BFE60CA36619DDAF24249 /* NDKSwiftUI */ = {
			isa = XCSwiftPackageProductDependency;
			productName = NDKSwiftUI;
		};
		8F0120155B5FA6FCE7E43793 /* NDKSwift */ = {
			isa = XCSwiftPackageProductDependency;
			productName = NDKSwift;
		};
/* End XCSwiftPackageProductDependency section */
	};
	rootObject = 6906FF56AA4A1447D26D2625 /* Project object */;
}
</file>

<file path="Resources/Assets.xcassets/AccentColor.colorset/Contents.json">
{
  "colors" : [
    {
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0x9A",
          "green" : "0x1B",
          "red" : "0x6A"
        }
      },
      "idiom" : "universal"
    },
    {
      "appearances" : [
        {
          "appearance" : "luminosity",
          "value" : "dark"
        }
      ],
      "color" : {
        "color-space" : "srgb",
        "components" : {
          "alpha" : "1.000",
          "blue" : "0xB8",
          "green" : "0x39",
          "red" : "0x88"
        }
      },
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="Resources/Assets.xcassets/AppIcon.appiconset/Contents.json">
{
  "images" : [
    {
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="Resources/Assets.xcassets/Contents.json">
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="Sources/Highlighter/App/HighlighterApp.swift">
import SwiftUI
import NDKSwift
@main
struct HighlighterApp: App {
    @StateObject private var appState = AppState()
    var body: some Scene {
        WindowGroup {
            ContentView()
                .environmentObject(appState)
                .task {
                    await appState.initialize()
                }
        }
    }
}
</file>

<file path="Sources/Highlighter/App/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>$(PRODUCT_BUNDLE_PACKAGE_TYPE)</string>
	<key>CFBundleShortVersionString</key>
	<string>$(MARKETING_VERSION)</string>
	<key>CFBundleVersion</key>
	<string>$(CURRENT_PROJECT_VERSION)</string>
	<key>ITSAppUsesNonExemptEncryption</key>
	<false/>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>NSAppTransportSecurity</key>
	<dict>
		<key>NSAllowsArbitraryLoads</key>
		<true/>
		<key>NSAllowsArbitraryLoadsInWebContent</key>
		<true/>
	</dict>
	<key>NSCameraUsageDescription</key>
	<string>Highlighter needs camera access to scan QR codes for Lightning payments and Nostr connections.</string>
	<key>NSFaceIDUsageDescription</key>
	<string>Highlighter uses Face ID to secure your wallet and private keys.</string>
	<key>NSMicrophoneUsageDescription</key>
	<string>Highlighter needs microphone access to create audio highlights.</string>
	<key>NSPhotoLibraryAddUsageDescription</key>
	<string>Highlighter needs photo library access to save highlight images.</string>
	<key>NSPhotoLibraryUsageDescription</key>
	<string>Highlighter needs photo library access to import images for highlights.</string>
	<key>UIApplicationSceneManifest</key>
	<dict>
		<key>UIApplicationSupportsMultipleScenes</key>
		<false/>
		<key>UISceneConfigurations</key>
		<dict>
			<key>UIWindowSceneSessionRoleApplication</key>
			<array>
				<dict>
					<key>UISceneConfigurationName</key>
					<string>Default Configuration</string>
					<key>UISceneDelegateClassName</key>
					<string>$(PRODUCT_MODULE_NAME).SceneDelegate</string>
				</dict>
			</array>
		</dict>
	</dict>
	<key>UIBackgroundModes</key>
	<array>
		<string>fetch</string>
		<string>processing</string>
		<string>remote-notification</string>
	</array>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIRequiredDeviceCapabilities</key>
	<array>
		<string>armv7</string>
	</array>
	<key>UIStatusBarStyle</key>
	<string>UIStatusBarStyleDefault</string>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
</dict>
</plist>
</file>

<file path="Sources/Highlighter/Design/AnimationSystem.swift">
import SwiftUI
// MARK: - Unified Animation System
// Consolidates all animation functionality into a single, cohesive system
// Following DRY principles to eliminate duplication across the codebase
struct AnimationSystem {
    // MARK: - Animation Curves (From DesignSystem + PremiumAnimations)
    enum Curves {
        /// Ultra-smooth spring animation for premium feel
        static let premiumSpring = Animation.interpolatingSpring(
            mass: 1.0,
            stiffness: 100,
            damping: 20,
            initialVelocity: 0
        )
        /// Subtle spring for responsive interactions
        static let springSnappy = Animation.spring(response: 0.3, dampingFraction: 0.9)
        /// Smooth spring for general animations
        static let springSmooth = Animation.spring(response: 0.4, dampingFraction: 0.85)
        /// Gentle spring for subtle interactions
        static let springBouncy = Animation.spring(response: 0.5, dampingFraction: 0.95)
        /// Minimal bounce for refined emphasis
        static let elasticBounce = Animation.interpolatingSpring(
            mass: 1.0,
            stiffness: 120,
            damping: 18,
            initialVelocity: 0
        )
        /// Standard timing curves
        static let instant = Animation.easeOut(duration: 0.15)
        static let quick = Animation.easeOut(duration: 0.2)
        static let standard = Animation.easeOut(duration: 0.25)
        static let smooth = Animation.easeOut(duration: 0.35)
        /// Quick responsive animation for immediate feedback
        static let quickResponse = Animation.timingCurve(0.2, 0.8, 0.2, 1.0, duration: 0.15)
        /// Smooth entrance animation with slight overshoot
        static let smoothEntrance = Animation.timingCurve(0.05, 0.7, 0.1, 1.05, duration: 0.4)
        /// Gentle fade with scale for content appearance
        static let gentleFadeScale = Animation.timingCurve(0.23, 1, 0.32, 1, duration: 0.5)
        /// Interactive animations
        static let interactive = Animation.interactiveSpring(response: 0.15, dampingFraction: 0.86, blendDuration: 0.25)
    }
    // MARK: - Staggered Animation Helpers
    /// Create staggered animations for list items
    static func staggered(index: Int, delay: Double = 0.1) -> Animation {
        return Curves.smoothEntrance.delay(Double(index) * delay)
    }
    /// Create wave-like staggered animations
    static func wave(index: Int, total: Int, duration: Double = 1.0) -> Animation {
        let normalizedIndex = Double(index) / Double(max(total - 1, 1))
        let waveDelay = sin(normalizedIndex * .pi) * 0.3
        return Curves.premiumSpring.delay(waveDelay)
    }
}
// MARK: - Scale Animations (Consolidating SpringyScale, HeroScale, etc.)
struct ScaleEffect: ViewModifier {
    let isActive: Bool
    let scale: CGFloat
    let animation: Animation
    let includeShadow: Bool
    init(
        isActive: Bool,
        scale: CGFloat = 1.1,
        animation: Animation = AnimationSystem.Curves.springSnappy,
        includeShadow: Bool = false
    ) {
        self.isActive = isActive
        self.scale = scale
        self.animation = animation
        self.includeShadow = includeShadow
    }
    func body(content: Content) -> some View {
        content
            .scaleEffect(isActive ? scale : 1.0)
            .shadow(
                color: includeShadow ? DesignSystem.Colors.primary.opacity(isActive ? 0.2 : 0) : Color.clear,
                radius: includeShadow && isActive ? 20 : 0,
                x: 0,
                y: includeShadow && isActive ? 10 : 0
            )
            .animation(animation, value: isActive)
    }
}
// MARK: - Slide Animations
struct SlideEffect: ViewModifier {
    let isVisible: Bool
    let edge: Edge
    let animation: Animation
    init(
        isVisible: Bool,
        edge: Edge = .bottom,
        animation: Animation = AnimationSystem.Curves.springSmooth
    ) {
        self.isVisible = isVisible
        self.edge = edge
        self.animation = animation
    }
    func body(content: Content) -> some View {
        content
            .offset(slideOffset)
            .opacity(isVisible ? 1 : 0)
            .animation(animation, value: isVisible)
    }
    private var slideOffset: CGSize {
        guard !isVisible else { return .zero }
        switch edge {
        case .top:
            return CGSize(width: 0, height: -UIScreen.main.bounds.height)
        case .bottom:
            return CGSize(width: 0, height: UIScreen.main.bounds.height)
        case .leading:
            return CGSize(width: -UIScreen.main.bounds.width, height: 0)
        case .trailing:
            return CGSize(width: UIScreen.main.bounds.width, height: 0)
        }
    }
}
// MARK: - Bounce Effect (From Animations.swift)
struct BounceEffect: ViewModifier {
    @State private var bounceScale: CGFloat = 1
    let trigger: Bool
    func body(content: Content) -> some View {
        content
            .scaleEffect(bounceScale)
            .onChange(of: trigger) { _, _ in
                withAnimation(.spring(response: 0.2, dampingFraction: 0.3)) {
                    bounceScale = 1.2
                }
                withAnimation(.spring(response: 0.3, dampingFraction: 0.6).delay(0.1)) {
                    bounceScale = 1.0
                }
            }
    }
}
// MARK: - Typewriter Effect (From Animations.swift)
struct TypewriterEffect: ViewModifier {
    let text: String
    let speed: Double
    @State private var displayedText = ""
    @State private var currentIndex = 0
    func body(content: Content) -> some View {
        Text(displayedText)
            .onAppear {
                animateText()
            }
            .onChange(of: text) { _, newValue in
                displayedText = ""
                currentIndex = 0
                animateText()
            }
    }
    private func animateText() {
        guard currentIndex < text.count else { return }
        DispatchQueue.main.asyncAfter(deadline: .now() + speed) {
            let index = text.index(text.startIndex, offsetBy: currentIndex)
            displayedText += String(text[index])
            currentIndex += 1
            animateText()
        }
    }
}
// MARK: - Morphing Card (From ModernAnimations.swift)
struct MorphingCard: ViewModifier {
    let isExpanded: Bool
    func body(content: Content) -> some View {
        content
            .scaleEffect(isExpanded ? 1.02 : 1.0)
            .shadow(
                color: Color.black.opacity(isExpanded ? 0.15 : 0.08),
                radius: isExpanded ? 20 : 10,
                x: 0,
                y: isExpanded ? 10 : 5
            )
            .animation(
                AnimationSystem.Curves.springSmooth,
                value: isExpanded
            )
    }
}
// MARK: - Parallax Effect (From ModernAnimations.swift)
struct ParallaxEffect: ViewModifier {
    let offset: CGFloat
    let multiplier: CGFloat
    init(offset: CGFloat, multiplier: CGFloat = 0.5) {
        self.offset = offset
        self.multiplier = multiplier
    }
    func body(content: Content) -> some View {
        content
            .offset(y: offset * multiplier)
    }
}
// MARK: - Ripple Effect (From ModernAnimations.swift)
struct RippleEffect: ViewModifier {
    let trigger: Bool
    @State private var scale: CGFloat = 0
    @State private var opacity: Double = 0.5
    func body(content: Content) -> some View {
        content
            .background(
                Circle()
                    .fill(DesignSystem.Colors.primary)
                    .scaleEffect(scale)
                    .opacity(opacity)
                    .animation(.easeOut(duration: 0.6), value: scale)
                    .animation(.easeOut(duration: 0.6), value: opacity)
            )
            .onChange(of: trigger) { _, _ in
                scale = 0
                opacity = 0.5
                withAnimation {
                    scale = 3
                    opacity = 0
                }
            }
    }
}
// MARK: - Premium Entrance (From PremiumAnimations.swift)
struct PremiumEntranceModifier: ViewModifier {
    let delay: Double
    @State private var isVisible = false
    init(delay: Double = 0) {
        self.delay = delay
    }
    func body(content: Content) -> some View {
        content
            .opacity(isVisible ? 1 : 0)
            .offset(y: isVisible ? 0 : 20)
            .scaleEffect(isVisible ? 1 : 0.95)
            .onAppear {
                withAnimation(AnimationSystem.Curves.smoothEntrance.delay(delay)) {
                    isVisible = true
                }
            }
    }
}
// MARK: - Premium Hover (From PremiumAnimations.swift)
struct PremiumHoverModifier: ViewModifier {
    @State private var isHovered = false
    let scale: CGFloat
    let shadowRadius: CGFloat
    init(scale: CGFloat = 1.03, shadowRadius: CGFloat = 12) {
        self.scale = scale
        self.shadowRadius = shadowRadius
    }
    func body(content: Content) -> some View {
        content
            .scaleEffect(isHovered ? scale : 1.0)
            .shadow(
                color: DesignSystem.Colors.primary.opacity(isHovered ? 0.2 : 0.1),
                radius: isHovered ? shadowRadius : 6,
                x: 0,
                y: isHovered ? 6 : 3
            )
            .animation(AnimationSystem.Curves.premiumSpring, value: isHovered)
            .onHover { hovering in
                isHovered = hovering
            }
    }
}
// MARK: - Premium Press (From PremiumAnimations.swift)
struct PremiumPressModifier: ViewModifier {
    @State private var isPressed = false
    let hapticStyle: HapticManager.ImpactStyle
    let scale: CGFloat
    init(hapticStyle: HapticManager.ImpactStyle = .light, scale: CGFloat = 0.96) {
        self.hapticStyle = hapticStyle
        self.scale = scale
    }
    func body(content: Content) -> some View {
        content
            .scaleEffect(isPressed ? scale : 1.0)
            .opacity(isPressed ? 0.8 : 1.0)
            .animation(AnimationSystem.Curves.quickResponse, value: isPressed)
            .onLongPressGesture(
                minimumDuration: 0,
                maximumDistance: .infinity,
                pressing: { pressing in
                    isPressed = pressing
                    if pressing {
                        HapticManager.shared.impact(hapticStyle)
                    }
                },
                perform: {}
            )
    }
}
// MARK: - Floating Animation (From PremiumAnimations.swift)
struct FloatingModifier: ViewModifier {
    @State private var isFloating = false
    let amplitude: CGFloat
    let duration: Double
    init(amplitude: CGFloat = 3, duration: Double = 3.0) {
        self.amplitude = amplitude
        self.duration = duration
    }
    func body(content: Content) -> some View {
        content
            .offset(y: isFloating ? -amplitude : amplitude)
            .animation(
                .easeInOut(duration: duration).repeatForever(autoreverses: true),
                value: isFloating
            )
            .onAppear {
                isFloating = true
            }
    }
}
// MARK: - Shimmer Effect (Consolidating multiple implementations)
struct ShimmerModifier: ViewModifier {
    @State private var phase: CGFloat = 0
    let duration: Double
    let brightness: Double
    init(duration: Double = 1.5, brightness: Double = 0.6) {
        self.duration = duration
        self.brightness = brightness
    }
    func body(content: Content) -> some View {
        content
            .overlay(
                Rectangle()
                    .fill(
                        LinearGradient(
                            colors: [
                                Color.clear,
                                Color.white.opacity(brightness),
                                Color.clear
                            ],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .rotationEffect(.degrees(15))
                    .offset(x: -200 + (phase * 400))
                    .animation(
                        .linear(duration: duration).repeatForever(autoreverses: false),
                        value: phase
                    )
            )
            .clipped()
            .onAppear {
                phase = 1
            }
    }
}
// MARK: - Magnetic Hover Effect (From ModernAnimations.swift)
struct MagneticHover: ViewModifier {
    @State private var offset = CGSize.zero
    @State private var isDragging = false
    func body(content: Content) -> some View {
        content
            .offset(offset)
            .scaleEffect(isDragging ? 1.05 : 1.0)
            .animation(.spring(response: 0.3, dampingFraction: 0.7), value: offset)
            .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isDragging)
            .onHover { hovering in
                if !hovering {
                    offset = .zero
                    isDragging = false
                }
            }
            .gesture(
                DragGesture(minimumDistance: 0)
                    .onChanged { value in
                        isDragging = true
                        let maxOffset: CGFloat = 10
                        offset = CGSize(
                            width: min(max(value.translation.width * 0.1, -maxOffset), maxOffset),
                            height: min(max(value.translation.height * 0.1, -maxOffset), maxOffset)
                        )
                    }
                    .onEnded { _ in
                        offset = .zero
                        isDragging = false
                    }
            )
    }
}
// MARK: - Glow Effect (From PremiumAnimations.swift)
struct GlowModifier: ViewModifier {
    let color: Color
    let radius: CGFloat
    let isActive: Bool
    init(color: Color = DesignSystem.Colors.secondary, radius: CGFloat = 8, isActive: Bool = true) {
        self.color = color
        self.radius = radius
        self.isActive = isActive
    }
    func body(content: Content) -> some View {
        content
            .background(
                content
                    .blur(radius: radius / 2)
                    .opacity(isActive ? 0.8 : 0)
                    .blendMode(.multiply)
            )
            .shadow(
                color: color.opacity(isActive ? 0.6 : 0),
                radius: radius,
                x: 0,
                y: 0
            )
            .animation(AnimationSystem.Curves.gentleFadeScale, value: isActive)
    }
}
// MARK: - Pulse Effects (Consolidating multiple pulse implementations)
struct PulseModifier: ViewModifier {
    @State private var isPulsing = false
    let style: PulseStyle
    enum PulseStyle {
        case gentle
        case standard
        case strong
        var scale: CGFloat {
            switch self {
            case .gentle: return 1.02
            case .standard: return 1.05
            case .strong: return 1.1
            }
        }
        var duration: Double {
            switch self {
            case .gentle: return 2.5
            case .standard: return 1.0
            case .strong: return 0.8
            }
        }
        var opacity: (from: Double, to: Double) {
            switch self {
            case .gentle: return (1.0, 0.9)
            case .standard: return (1.0, 1.0)
            case .strong: return (1.0, 0.8)
            }
        }
    }
    init(style: PulseStyle = .standard) {
        self.style = style
    }
    func body(content: Content) -> some View {
        content
            .scaleEffect(isPulsing ? style.scale : 1.0)
            .opacity(isPulsing ? style.opacity.to : style.opacity.from)
            .animation(
                .easeInOut(duration: style.duration).repeatForever(autoreverses: true),
                value: isPulsing
            )
            .onAppear {
                isPulsing = true
            }
    }
}
// MARK: - View Extensions (Unified from all files)
extension View {
    // Scale animations
    func scaleEffect(isActive: Bool, scale: CGFloat = 1.1, includeShadow: Bool = false) -> some View {
        modifier(ScaleEffect(isActive: isActive, scale: scale, includeShadow: includeShadow))
    }
    func heroScale(isActive: Bool, scale: CGFloat = 1.05) -> some View {
        modifier(ScaleEffect(isActive: isActive, scale: scale, includeShadow: true))
    }
    // Slide animations
    func slideEffect(isVisible: Bool, from edge: Edge = .bottom) -> some View {
        modifier(SlideEffect(isVisible: isVisible, edge: edge))
    }
    // Bounce effect
    func bounceEffect(trigger: Bool) -> some View {
        modifier(BounceEffect(trigger: trigger))
    }
    // Typewriter effect
    func typewriter(_ text: String, speed: Double = 0.05) -> some View {
        modifier(TypewriterEffect(text: text, speed: speed))
    }
    // Card animations
    func morphingCard(isExpanded: Bool) -> some View {
        modifier(MorphingCard(isExpanded: isExpanded))
    }
    // Parallax
    func parallax(offset: CGFloat, multiplier: CGFloat = 0.5) -> some View {
        modifier(ParallaxEffect(offset: offset, multiplier: multiplier))
    }
    // Ripple effect
    func rippleEffect(trigger: Bool) -> some View {
        modifier(RippleEffect(trigger: trigger))
    }
    // Premium animations
    func premiumEntrance(delay: Double = 0) -> some View {
        modifier(PremiumEntranceModifier(delay: delay))
    }
    func premiumHover(scale: CGFloat = 1.03, shadowRadius: CGFloat = 12) -> some View {
        #if os(macOS)
        modifier(PremiumHoverModifier(scale: scale, shadowRadius: shadowRadius))
        #else
        self
        #endif
    }
    func premiumPress(hapticStyle: HapticManager.ImpactStyle = .light, scale: CGFloat = 0.96) -> some View {
        modifier(PremiumPressModifier(hapticStyle: hapticStyle, scale: scale))
    }
    func floating(amplitude: CGFloat = 3, duration: Double = 3.0) -> some View {
        modifier(FloatingModifier(amplitude: amplitude, duration: duration))
    }
    func shimmer(duration: Double = 1.5, brightness: Double = 0.6) -> some View {
        modifier(ShimmerModifier(duration: duration, brightness: brightness))
    }
    func glow(color: Color = DesignSystem.Colors.secondary, radius: CGFloat = 8, isActive: Bool = true) -> some View {
        modifier(GlowModifier(color: color, radius: radius, isActive: isActive))
    }
    func pulse(style: PulseModifier.PulseStyle = .standard) -> some View {
        modifier(PulseModifier(style: style))
    }
    func magneticHover() -> some View {
        modifier(MagneticHover())
    }
    // Convenience methods
    func premiumCardInteraction() -> some View {
        self
            .premiumHover()
            .premiumPress()
    }
    func staggeredEntrance(index: Int, delay: Double = 0.1) -> some View {
        self
            .opacity(0)
            .offset(y: 20)
            .onAppear {
                withAnimation(AnimationSystem.staggered(index: index, delay: delay)) {
                    // SwiftUI automatically animates to the view's natural state
                }
            }
    }
}
// MARK: - Transition Extensions
extension AnyTransition {
    /// Premium fade with scale
    static var premiumFadeScale: AnyTransition {
        .asymmetric(
            insertion: .scale(scale: 0.9).combined(with: .opacity),
            removal: .scale(scale: 1.1).combined(with: .opacity)
        )
        .animation(AnimationSystem.Curves.gentleFadeScale)
    }
    /// Premium slide with overshoot
    static func premiumSlide(from edge: Edge) -> AnyTransition {
        .asymmetric(
            insertion: .move(edge: edge).combined(with: .opacity),
            removal: .move(edge: edge).combined(with: .opacity)
        )
        .animation(AnimationSystem.Curves.smoothEntrance)
    }
}
// MARK: - Animated Components (From ModernAnimations.swift)
// MARK: - Mesh Gradient Background
// Note: MeshGradientBackground is defined in Views/Components/MeshGradientBackground.swift
struct ModernLoadingIndicator: View {
    @State private var rotation = 0.0
    var body: some View {
        ZStack {
            ForEach(0..<3) { index in
                Circle()
                    .fill(
                        LinearGradient(
                            colors: [
                                DesignSystem.Colors.primary,
                                DesignSystem.Colors.secondary
                            ],
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )
                    .frame(width: 15, height: 15)
                    .offset(y: -25)
                    .rotationEffect(.degrees(rotation + Double(index * 120)))
                    .animation(
                        .linear(duration: 1.2)
                        .repeatForever(autoreverses: false),
                        value: rotation
                    )
            }
        }
        .onAppear {
            rotation = 360
        }
    }
}
struct ModernProgressBar: View {
    let progress: CGFloat
    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                // Background
                RoundedRectangle(cornerRadius: 10, style: .continuous)
                    .fill(DesignSystem.Colors.surfaceSecondary)
                // Progress
                RoundedRectangle(cornerRadius: 10, style: .continuous)
                    .fill(
                        LinearGradient(
                            colors: [
                                DesignSystem.Colors.primary,
                                DesignSystem.Colors.secondary
                            ],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .frame(width: geometry.size.width * progress)
                    .animation(.spring(response: 0.5, dampingFraction: 0.8), value: progress)
                // Glow effect
                if progress > 0 {
                    RoundedRectangle(cornerRadius: 10, style: .continuous)
                        .fill(
                            LinearGradient(
                                colors: [
                                    Color.white.opacity(0.4),
                                    Color.white.opacity(0.1)
                                ],
                                startPoint: .top,
                                endPoint: .bottom
                            )
                        )
                        .frame(width: geometry.size.width * progress, height: geometry.size.height * 0.5)
                        .offset(y: -geometry.size.height * 0.25)
                        .blur(radius: 2)
                }
            }
        }
        .frame(height: 20)
    }
}
// MARK: - Animated Number (From ModernAnimations.swift)
struct AnimatedNumber: View {
    let value: Int
    let duration: Double
    @State private var displayValue: Int = 0
    init(value: Int, duration: Double = 0.5) {
        self.value = value
        self.duration = duration
    }
    var body: some View {
        Text("\(displayValue)")
            .contentTransition(.numericText(countsDown: value < displayValue))
            .onAppear {
                animate()
            }
            .onChange(of: value) { _, _ in
                animate()
            }
    }
    private func animate() {
        withAnimation(.easeInOut(duration: duration)) {
            displayValue = value
        }
    }
}
// MARK: - Animated Checkmark (From Animations.swift)
struct AnimatedCheckmark: View {
    let isChecked: Bool
    var body: some View {
        ZStack {
            Circle()
                .stroke(lineWidth: 2)
                .foregroundColor(.gray.opacity(0.3))
                .frame(width: 24, height: 24)
            if isChecked {
                Circle()
                    .fill(
                        LinearGradient(
                            colors: [DesignSystem.Colors.secondary, DesignSystem.Colors.secondaryDark],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: 24, height: 24)
                    .transition(.scale.combined(with: .opacity))
                Image(systemName: "checkmark")
                    .font(.system(size: 12, weight: .bold))
                    .foregroundColor(.white)
                    .transition(.scale.combined(with: .opacity))
            }
        }
        .animation(.spring(response: 0.3, dampingFraction: 0.6), value: isChecked)
    }
}
// MARK: - Animation Preview
#Preview {
    VStack(spacing: 40) {
        Text("Unified Animation System")
            .font(.largeTitle)
            .heroScale(isActive: true)
        RoundedRectangle(cornerRadius: 20)
            .fill(DesignSystem.Colors.primary)
            .frame(width: 200, height: 100)
            .morphingCard(isExpanded: true)
        ModernLoadingIndicator()
        ModernProgressBar(progress: 0.7)
            .padding(.horizontal, 40)
        AnimatedNumber(value: 42)
            .font(.system(size: 48, weight: .bold, design: .rounded))
        AnimatedCheckmark(isChecked: true)
    }
    .padding()
}
</file>

<file path="Sources/Highlighter/Design/ButtonSystem.swift">
import SwiftUI
// MARK: - Unified Button System following DRY principles
/// Configuration for button animations and behaviors
struct ButtonConfiguration {
    let pressedScale: CGFloat
    let hapticType: HapticManager.ImpactStyle
    let animationResponse: Double
    let animationDamping: Double
    static let primary = ButtonConfiguration(
        pressedScale: 0.98,
        hapticType: .medium,
        animationResponse: 0.3,
        animationDamping: 0.7
    )
    static let secondary = ButtonConfiguration(
        pressedScale: 0.98,
        hapticType: .light,
        animationResponse: 0.2,
        animationDamping: 0.8
    )
    static let floating = ButtonConfiguration(
        pressedScale: 0.95,
        hapticType: .medium,
        animationResponse: 0.35,
        animationDamping: 0.6
    )
}
/// Base protocol for all button styles to ensure consistency
protocol ModernButtonProtocol: ButtonStyle {
    var configuration: ButtonConfiguration { get }
    var isEnabled: Bool { get }
}
extension ModernButtonProtocol {
    /// Common button press behavior
    func applyPressAnimation<Content: View>(
        to content: Content,
        isPressed: Bool
    ) -> some View {
        content
            .scaleEffect(isPressed ? configuration.pressedScale : 1.0)
            .animation(
                .spring(
                    response: configuration.animationResponse,
                    dampingFraction: configuration.animationDamping
                ),
                value: isPressed
            )
            .onChange(of: isPressed) { _, newValue in
                if newValue && isEnabled {
                    Task { @MainActor in
                        HapticManager.shared.impact(configuration.hapticType)
                    }
                }
            }
    }
    /// Common solid color background generator
    func solidBackground(
        color: Color,
        cornerRadius: CGFloat = DesignSystem.CornerRadius.medium
    ) -> some View {
        RoundedRectangle(cornerRadius: cornerRadius, style: .continuous)
            .fill(color)
            .overlay(
                RoundedRectangle(cornerRadius: cornerRadius, style: .continuous)
                    .stroke(
                        color.opacity(0.1),
                        lineWidth: 0.5
                    )
            )
    }
    /// Common shadow for buttons
    func buttonShadow(
        color: Color,
        isPressed: Bool,
        radius: CGFloat = 8,
        pressedRadius: CGFloat = 4
    ) -> some View {
        EmptyView()
            .shadow(
                color: isEnabled ? color.opacity(0.3) : Color.clear,
                radius: isPressed ? pressedRadius : radius,
                x: 0,
                y: isPressed ? pressedRadius / 2 : radius / 2
            )
    }
}
// MARK: - Refactored Button Styles using unified system
/// Primary button variant styles
enum PrimaryVariant {
    case standard
    case large
    case compact
    var padding: EdgeInsets {
        switch self {
        case .standard:
            return EdgeInsets(
                top: DesignSystem.Spacing.base,
                leading: DesignSystem.Spacing.xl,
                bottom: DesignSystem.Spacing.base,
                trailing: DesignSystem.Spacing.xl
            )
        case .large:
            return EdgeInsets(
                top: DesignSystem.Spacing.medium,
                leading: DesignSystem.Spacing.xl,
                bottom: DesignSystem.Spacing.medium,
                trailing: DesignSystem.Spacing.xl
            )
        case .compact:
            return EdgeInsets(
                top: DesignSystem.Spacing.small,
                leading: DesignSystem.Spacing.medium,
                bottom: DesignSystem.Spacing.small,
                trailing: DesignSystem.Spacing.medium
            )
        }
    }
    var font: Font {
        switch self {
        case .standard: return DesignSystem.Typography.bodyMedium
        case .large: return DesignSystem.Typography.headline
        case .compact: return DesignSystem.Typography.footnoteMedium
        }
    }
}
/// Simplified Primary Button using unified system
struct UnifiedPrimaryButton: ModernButtonProtocol {
    let configuration = ButtonConfiguration.primary
    var isEnabled: Bool = true
    var variant: PrimaryVariant = .standard
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(variant.font)
            .foregroundColor(.white)
            .padding(variant.padding)
            .background(
                solidBackground(
                    color: isEnabled ? DesignSystem.Colors.primary : DesignSystem.Colors.textTertiary
                )
            )
            .modifier(
                ButtonPressModifier(
                    buttonConfig: self.configuration,
                    isEnabled: isEnabled,
                    isPressed: configuration.isPressed,
                    shadowColor: DesignSystem.Colors.primary
                )
            )
            .disabled(!isEnabled)
    }
}
/// Simplified Secondary Button using unified system
struct UnifiedSecondaryButton: ModernButtonProtocol {
    let configuration = ButtonConfiguration.secondary
    var isEnabled: Bool = true
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(DesignSystem.Typography.bodyMedium)
            .foregroundColor(isEnabled ? DesignSystem.Colors.primary : DesignSystem.Colors.textTertiary)
            .padding(.vertical, DesignSystem.Spacing.base)
            .padding(.horizontal, DesignSystem.Spacing.xl)
            .background(
                RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.medium, style: .continuous)
                    .fill(
                        isEnabled 
                        ? DesignSystem.Colors.primary.opacity(0.05)
                        : DesignSystem.Colors.surfaceSecondary
                    )
                    .overlay(
                        RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.medium, style: .continuous)
                            .stroke(
                                isEnabled 
                                ? DesignSystem.Colors.primary.opacity(0.3)
                                : DesignSystem.Colors.border,
                                lineWidth: 1.5
                            )
                    )
            )
            .modifier(
                ButtonPressModifier(
                    buttonConfig: self.configuration,
                    isEnabled: isEnabled,
                    isPressed: configuration.isPressed,
                    shadowColor: .clear,
                    opacity: 0.8
                )
            )
            .disabled(!isEnabled)
    }
}
/// Unified button press behavior modifier
struct ButtonPressModifier: ViewModifier {
    let buttonConfig: ButtonConfiguration
    let isEnabled: Bool
    let isPressed: Bool
    let shadowColor: Color
    var opacity: CGFloat = 0.9
    func body(content: Content) -> some View {
        content
            .scaleEffect(isPressed ? buttonConfig.pressedScale : 1.0)
            .opacity(isPressed ? opacity : 1.0)
            .shadow(
                color: isEnabled ? shadowColor.opacity(0.3) : Color.clear,
                radius: isPressed ? 4 : 8,
                x: 0,
                y: isPressed ? 2 : 4
            )
            .animation(
                .spring(
                    response: buttonConfig.animationResponse,
                    dampingFraction: buttonConfig.animationDamping
                ),
                value: isPressed
            )
            .onChange(of: isPressed) { _, newValue in
                if newValue && isEnabled {
                    Task { @MainActor in
                        HapticManager.shared.impact(buttonConfig.hapticType)
                    }
                }
            }
    }
}
// MARK: - Convenience Extensions
extension View {
    /// Apply unified primary button style
    func unifiedPrimaryButton(
        enabled: Bool = true,
        variant: PrimaryVariant = .standard
    ) -> some View {
        self.buttonStyle(UnifiedPrimaryButton(isEnabled: enabled, variant: variant))
    }
    /// Apply unified secondary button style
    func unifiedSecondaryButton(enabled: Bool = true) -> some View {
        self.buttonStyle(UnifiedSecondaryButton(isEnabled: enabled))
    }
}
</file>

<file path="Sources/Highlighter/Design/CardSystem.swift">
import SwiftUI
// MARK: - Unified Card System
// This file consolidates all card-related styles and components to follow DRY principles
// MARK: - Card Configuration
struct CardConfiguration {
    let padding: CGFloat
    let cornerRadius: CGFloat
    let backgroundColor: Color
    let borderColor: Color?
    let borderWidth: CGFloat
    let shadow: ShadowConfiguration
    struct ShadowConfiguration {
        let color: Color
        let radius: CGFloat
        let x: CGFloat
        let y: CGFloat
    }
    // Predefined configurations
    static let standard = CardConfiguration(
        padding: DesignSystem.Spacing.cardPadding,
        cornerRadius: DesignSystem.CornerRadius.medium,
        backgroundColor: DesignSystem.Colors.surface,
        borderColor: nil,
        borderWidth: 0,
        shadow: ShadowConfiguration(
            color: DesignSystem.Shadow.small.color,
            radius: DesignSystem.Shadow.small.radius,
            x: DesignSystem.Shadow.small.x,
            y: DesignSystem.Shadow.small.y
        )
    )
    static let selected = CardConfiguration(
        padding: DesignSystem.Spacing.cardPadding,
        cornerRadius: DesignSystem.CornerRadius.medium,
        backgroundColor: DesignSystem.Colors.surface,
        borderColor: DesignSystem.Colors.primary,
        borderWidth: 2,
        shadow: ShadowConfiguration(
            color: DesignSystem.Colors.primary.opacity(0.3),
            radius: 12,
            x: 0,
            y: 6
        )
    )
    static let glass = CardConfiguration(
        padding: DesignSystem.Spacing.cardPadding,
        cornerRadius: DesignSystem.CornerRadius.medium,
        backgroundColor: Color.clear,
        borderColor: Color.white.opacity(0.2),
        borderWidth: 1,
        shadow: ShadowConfiguration(
            color: Color.black.opacity(0.1),
            radius: 8,
            x: 0,
            y: 4
        )
    )
    static let compact = CardConfiguration(
        padding: DesignSystem.Spacing.base,
        cornerRadius: DesignSystem.CornerRadius.small,
        backgroundColor: DesignSystem.Colors.surface,
        borderColor: nil,
        borderWidth: 0,
        shadow: ShadowConfiguration(
            color: DesignSystem.Shadow.subtle.color,
            radius: DesignSystem.Shadow.subtle.radius,
            x: DesignSystem.Shadow.subtle.x,
            y: DesignSystem.Shadow.subtle.y
        )
    )
}
// MARK: - Modern Card View Modifier (Consolidated)
struct ModernCardModifier: ViewModifier {
    let configuration: CardConfiguration
    let isInteractive: Bool
    @State private var isPressed = false
    init(configuration: CardConfiguration = .standard, isInteractive: Bool = false) {
        self.configuration = configuration
        self.isInteractive = isInteractive
    }
    func body(content: Content) -> some View {
        content
            .padding(configuration.padding)
            .background(backgroundView)
            .overlay(borderView)
            .clipShape(RoundedRectangle(cornerRadius: configuration.cornerRadius, style: .continuous))
            .shadow(
                color: configuration.shadow.color,
                radius: configuration.shadow.radius,
                x: configuration.shadow.x,
                y: configuration.shadow.y
            )
            .scaleEffect(isPressed ? 0.98 : 1.0)
            .animation(DesignSystem.Animation.quick, value: isPressed)
            .onLongPressGesture(minimumDuration: 0, maximumDistance: .infinity) {
            } onPressingChanged: { pressing in
                if isInteractive {
                    isPressed = pressing
                }
            }
    }
    @ViewBuilder
    private var backgroundView: some View {
        if configuration.backgroundColor == Color.clear {
            RoundedRectangle(cornerRadius: configuration.cornerRadius, style: .continuous)
                .fill(.ultraThinMaterial)
        } else {
            RoundedRectangle(cornerRadius: configuration.cornerRadius, style: .continuous)
                .fill(configuration.backgroundColor)
        }
    }
    @ViewBuilder
    private var borderView: some View {
        if let borderColor = configuration.borderColor, configuration.borderWidth > 0 {
            RoundedRectangle(cornerRadius: configuration.cornerRadius, style: .continuous)
                .stroke(borderColor, lineWidth: configuration.borderWidth)
        }
    }
}
// MARK: - View Extensions (Unified)
extension View {
    /// Apply modern card styling with default configuration
    func modernCard(noPadding: Bool = false, isInteractive: Bool = false) -> some View {
        var config = CardConfiguration.standard
        if noPadding {
            config = CardConfiguration(
                padding: 0,
                cornerRadius: config.cornerRadius,
                backgroundColor: config.backgroundColor,
                borderColor: config.borderColor,
                borderWidth: config.borderWidth,
                shadow: config.shadow
            )
        }
        return self.modifier(ModernCardModifier(configuration: config, isInteractive: isInteractive))
    }
    /// Apply modern card styling with selection state
    func modernCardSelected(_ isSelected: Bool) -> some View {
        self.modifier(ModernCardModifier(
            configuration: isSelected ? .selected : .standard,
            isInteractive: true
        ))
        .scaleEffect(isSelected ? 1.02 : 1.0)
        .animation(DesignSystem.Animation.springSnappy, value: isSelected)
    }
    /// Apply glass card styling
    func glassCard() -> some View {
        self.modifier(ModernCardModifier(configuration: .glass))
    }
    /// Apply compact card styling
    func compactCard() -> some View {
        self.modifier(ModernCardModifier(configuration: .compact))
    }
}
// MARK: - Backward Compatibility
// Bridge the UnifiedCard component approach with the modifier approach
extension UnifiedCard {
    /// Create a UnifiedCard using a simple modifier-style API
    static func card(
        variant: CardVariant = .standard,
        isSelected: Bool = false,
        action: (() -> Void)? = nil,
        @ViewBuilder content: () -> Content
    ) -> UnifiedCard<Content> {
        return UnifiedCard(
            variant: variant,
            isSelected: isSelected,
            action: action,
            content: content
        )
    }
}
</file>

<file path="Sources/Highlighter/Design/DesignSystem.swift">
import SwiftUI
// MARK: - Highlighter Design System
// Premium design system following app specification: purple (#6A1B9A) and orange (#FF9500)
struct DesignSystem {
    // MARK: - Colors
    enum Colors {
        // Primary - Sophisticated dark blue/indigo
        static let primary = Color(hex: "1A237E")
        static let primaryLight = Color(hex: "3949AB") 
        static let primaryDark = Color(hex: "0D1551")
        // Secondary - Elegant sage green for subtle accents
        static let secondary = Color(hex: "4A5F4E")
        static let secondaryLight = Color(hex: "6B7B6F")
        static let secondaryDark = Color(hex: "2F3F32")
        // Semantic Colors
        static let text = Color.primary
        static let textSecondary = Color.primary.opacity(0.6)
        static let textTertiary = Color.primary.opacity(0.4)
        // Backgrounds - Premium neutral tones
        static let background = Color(hex: "FAFAFA")
        static let backgroundSecondary = Color(hex: "F5F5F7")
        static let surface = Color.white
        static let surfaceSecondary = Color(hex: "F8F8FA")
        // Dark mode colors
        static let darkBackground = Color(hex: "1C1C1E")
        static let darkSurface = Color(hex: "2C2C2E")
        static let darkText = Color.white
        // Functional
        static let success = Color(hex: "4CAF50")
        static let warning = Color(hex: "FFA726")
        static let error = Color(hex: "E57373")
        // Borders & Dividers
        static let divider = Color.primary.opacity(0.08)
        static let border = Color.primary.opacity(0.12)
        // Interactive States - subtle highlights
        static let highlight = primary.opacity(0.8)
        static let highlightSubtle = primary.opacity(0.05)
    }
    // MARK: - Typography
    enum Typography {
        // Display
        static let largeTitle = Font.system(size: 32, weight: .bold, design: .default)
        static let title = Font.system(size: 24, weight: .semibold, design: .default)
        static let title2 = Font.system(size: 20, weight: .semibold, design: .default)
        static let title3 = Font.system(size: 18, weight: .medium, design: .default)
        // Body
        static let headline = Font.system(size: 16, weight: .semibold, design: .default)
        static let body = Font.system(size: 15, weight: .regular, design: .default)
        static let bodyMedium = Font.system(size: 15, weight: .medium, design: .default)
        static let callout = Font.system(size: 14, weight: .regular, design: .default)
        // Support
        static let footnote = Font.system(size: 13, weight: .regular, design: .default)
        static let footnoteMedium = Font.system(size: 13, weight: .medium, design: .default)
        static let caption = Font.system(size: 12, weight: .regular, design: .default)
        static let captionMedium = Font.system(size: 12, weight: .medium, design: .default)
        static let micro = Font.system(size: 11, weight: .regular, design: .default)
        static let calloutMedium = Font.system(size: 14, weight: .medium, design: .default)
        // Specialized fonts for Highlighter app
        static let highlighterQuote = Font.custom("Georgia", size: 18).italic()
        // Dynamic quote sizing based on content length
        static func dynamicQuote(for length: Int) -> Font {
            let size: CGFloat = length > 100 ? 16 : (length > 50 ? 17 : 18)
            return Font.custom("Georgia", size: size).italic()
        }
    }
    // MARK: - Spacing (Tighter, more modern)
    enum Spacing {
        static let nano: CGFloat = 2
        static let micro: CGFloat = 4
        static let mini: CGFloat = 6
        static let small: CGFloat = 8
        static let base: CGFloat = 12
        static let medium: CGFloat = 16
        static let large: CGFloat = 20
        static let xl: CGFloat = 24
        static let xxl: CGFloat = 32
        static let huge: CGFloat = 40
        // Specific use cases
        static let cardPadding: CGFloat = 16
        static let screenPadding: CGFloat = 16
        static let sectionSpacing: CGFloat = 24
        static let itemSpacing: CGFloat = 12
    }
    // MARK: - Corner Radius
    enum CornerRadius {
        static let micro: CGFloat = 4
        static let small: CGFloat = 8
        static let medium: CGFloat = 12
        static let large: CGFloat = 16
        static let xl: CGFloat = 20
        static let full: CGFloat = 999
    }
    // MARK: - Shadows (Subtle and sophisticated)
    enum Shadow {
        static let subtle = (
            color: Color.black.opacity(0.02),
            radius: CGFloat(1),
            x: CGFloat(0),
            y: CGFloat(0.5)
        )
        static let small = (
            color: Color.black.opacity(0.03),
            radius: CGFloat(2),
            x: CGFloat(0),
            y: CGFloat(1)
        )
        static let medium = (
            color: Color.black.opacity(0.04),
            radius: CGFloat(4),
            x: CGFloat(0),
            y: CGFloat(2)
        )
        static let large = (
            color: Color.black.opacity(0.06),
            radius: CGFloat(8),
            x: CGFloat(0),
            y: CGFloat(4)
        )
        static let elevated = (
            color: Color.black.opacity(0.08),
            radius: CGFloat(12),
            x: CGFloat(0),
            y: CGFloat(6)
        )
    }
    // MARK: - Animation (Uses AnimationSystem.Curves)
    typealias Animation = AnimationSystem.Curves
    // MARK: - Layout
    enum Layout {
        static let maxContentWidth: CGFloat = 600
        static let compactBreakpoint: CGFloat = 400
        static let regularBreakpoint: CGFloat = 768
    }
}
// MARK: - Color Hex Extension
extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 3:
            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
        case 6:
            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
        case 8:
            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
        default:
            (a, r, g, b) = (255, 0, 0, 0)
        }
        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue: Double(b) / 255,
            opacity: Double(a) / 255
        )
    }
}
// MARK: - Convenience extensions
extension Color {
    static let ds = DesignSystem.Colors.self
}
extension Font {
    static let ds = DesignSystem.Typography.self
}
extension CGFloat {
    static let ds = DesignSystem.Spacing.self
}
// Color extensions moved above to avoid duplication
// MARK: - Haptic Feedback
// Haptic feedback is handled by HapticManager.shared
// Usage: HapticManager.shared.impact(.light)
//        HapticManager.shared.notification(.success)
//        HapticManager.shared.triggerSelection()
// MARK: - Time Constants for Convenience
struct TimeConstants {
    static let minute: TimeInterval = 60
    static let hour: TimeInterval = 3600
    static let day: TimeInterval = 86400
    static let week: TimeInterval = 604800
    static let month: TimeInterval = 2_629_746 // Average month
    static let year: TimeInterval = 31_556_952 // Average year
}
// MARK: - View Extensions
extension View {
    func fadeSlide(isVisible: Bool, delay: Double = 0) -> some View {
        self
            .offset(y: isVisible ? 0 : 20)
            .opacity(isVisible ? 1 : 0)
            .animation(.easeOut(duration: 0.4).delay(delay), value: isVisible)
    }
    func glassBackground(cornerRadius: CGFloat = 16) -> some View {
        self.background {
            RoundedRectangle(cornerRadius: cornerRadius, style: .continuous)
                .fill(.ultraThinMaterial)
                .overlay {
                    RoundedRectangle(cornerRadius: cornerRadius, style: .continuous)
                        .stroke(
                            LinearGradient(
                                colors: [
                                    Color.white.opacity(0.3),
                                    Color.white.opacity(0.1)
                                ],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ),
                            lineWidth: 1
                        )
                }
                .shadow(color: .black.opacity(0.1), radius: 8, x: 0, y: 4)
        }
    }
    func pulseGently() -> some View {
        self.modifier(GentlePulseModifier())
    }
    func contextualFeedback(isActive: Bool) -> some View {
        self.modifier(ContextualFeedbackModifier(isActive: isActive))
    }
    func highlightText(_ isHighlighted: Bool, color: Color = DesignSystem.Colors.secondary) -> some View {
        self.modifier(HighlightTextEffect(isHighlighted: isHighlighted, highlightColor: color))
    }
    func enhancedHighlightCard(isSelected: Bool = false, isHighlighted: Bool = false) -> some View {
        self.modifier(EnhancedHighlightCardModifier(isSelected: isSelected, isHighlighted: isHighlighted))
    }
    func rotateAndScale(isActive: Bool) -> some View {
        self
            .scaleEffect(isActive ? 1.2 : 1.0)
            .rotationEffect(isActive ? .degrees(15) : .degrees(0))
            .animation(.spring(response: 0.3, dampingFraction: 0.6), value: isActive)
    }
    // pulse() function moved to AnimationSystem.swift
}
// MARK: - View Modifiers
struct GentlePulseModifier: ViewModifier {
    @State private var scale: CGFloat = 1
    func body(content: Content) -> some View {
        content
            .scaleEffect(scale)
            .onAppear {
                withAnimation(
                    .easeInOut(duration: 3)
                    .repeatForever(autoreverses: true)
                ) {
                    scale = 1.01
                }
            }
    }
}
struct ContextualFeedbackModifier: ViewModifier {
    let isActive: Bool
    @State private var feedbackScale: CGFloat = 1.0
    func body(content: Content) -> some View {
        content
            .scaleEffect(feedbackScale)
            .onChange(of: isActive) { _, newValue in
                if newValue {
                    withAnimation(.spring(response: 0.15, dampingFraction: 0.8)) {
                        feedbackScale = 1.02
                    }
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                        withAnimation(.spring(response: 0.2, dampingFraction: 0.7)) {
                            feedbackScale = 1.0
                        }
                    }
                    HapticManager.shared.triggerSelection()
                }
            }
    }
}
struct HighlightTextEffect: ViewModifier {
    let isHighlighted: Bool
    let highlightColor: Color
    init(isHighlighted: Bool, highlightColor: Color = DesignSystem.Colors.secondary) {
        self.isHighlighted = isHighlighted
        self.highlightColor = highlightColor
    }
    func body(content: Content) -> some View {
        content
            .background(
                RoundedRectangle(cornerRadius: 4, style: .continuous)
                    .fill(
                        isHighlighted ? 
                        highlightColor.opacity(0.15) : 
                        Color.clear
                    )
                    .animation(.easeInOut(duration: 0.2), value: isHighlighted)
            )
            .overlay(
                RoundedRectangle(cornerRadius: 4, style: .continuous)
                    .stroke(
                        isHighlighted ? 
                        highlightColor.opacity(0.3) : 
                        Color.clear,
                        lineWidth: 1
                    )
                    .animation(.easeInOut(duration: 0.2), value: isHighlighted)
            )
    }
}
struct EnhancedHighlightCardModifier: ViewModifier {
    let isSelected: Bool
    let isHighlighted: Bool
    func body(content: Content) -> some View {
        content
            .padding(.ds.cardPadding)
            .background(
                RoundedRectangle(cornerRadius: .ds.large, style: .continuous)
                    .fill(DesignSystem.Colors.surface)
                    .overlay(
                        RoundedRectangle(cornerRadius: .ds.large, style: .continuous)
                            .stroke(
                                strokeGradient,
                                lineWidth: strokeWidth
                            )
                    )
            )
            .shadow(
                color: shadowColor,
                radius: shadowRadius,
                x: 0,
                y: shadowY
            )
            .scaleEffect(isSelected ? 1.02 : 1.0)
            .opacity(isSelected ? 1.0 : 0.95)
            .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isSelected)
    }
    private var strokeGradient: LinearGradient {
        if isSelected {
            return LinearGradient(
                colors: [DesignSystem.Colors.secondary, DesignSystem.Colors.primary],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        } else if isHighlighted {
            return LinearGradient(
                colors: [DesignSystem.Colors.secondary.opacity(0.3), Color.clear],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        } else {
            return LinearGradient(
                colors: [DesignSystem.Colors.border, DesignSystem.Colors.border],
                startPoint: .top,
                endPoint: .bottom
            )
        }
    }
    private var strokeWidth: CGFloat {
        isSelected ? 2 : (isHighlighted ? 1.5 : 1)
    }
    private var shadowColor: Color {
        if isSelected {
            return DesignSystem.Colors.secondary.opacity(0.3)
        } else {
            return Color.black.opacity(0.08)
        }
    }
    private var shadowRadius: CGFloat {
        isSelected ? 12 : 8
    }
    private var shadowY: CGFloat {
        isSelected ? 6 : 4
    }
}
// PulseModifier moved to AnimationSystem.swift
// MARK: - Button Styles
struct PressButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)
            .animation(.easeInOut(duration: 0.1), value: configuration.isPressed)
    }
}
// Minimal Zap Button Style
struct EnhancedZapButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .font(DesignSystem.Typography.callout)
            .fontWeight(.medium)
            .foregroundColor(DesignSystem.Colors.primary)
            .padding(.horizontal, DesignSystem.Spacing.medium)
            .padding(.vertical, DesignSystem.Spacing.small)
            .background(
                Capsule()
                    .fill(DesignSystem.Colors.primary.opacity(0.1))
                    .overlay(
                        Capsule()
                            .stroke(DesignSystem.Colors.primary, lineWidth: 1)
                    )
            )
            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)
            .opacity(configuration.isPressed ? 0.8 : 1.0)
            .animation(.easeInOut(duration: 0.1), value: configuration.isPressed)
            .onChange(of: configuration.isPressed) { _, newValue in
                if newValue {
                    HapticManager.shared.impact(.light)
                }
            }
    }
}
// MARK: - Enhanced View Extensions for Highlighter
extension View {
    func enhancedZapButton() -> some View {
        self.buttonStyle(EnhancedZapButtonStyle())
    }
    func lazyRender(threshold: CGFloat = 100) -> some View {
        self.modifier(LazyRenderModifier(threshold: threshold))
    }
    // modernCard, modernListItem and modernPlaceholder are defined in ModernViewModifiers.swift
}
// MARK: - Additional View Modifiers for Highlighter
struct LazyRenderModifier: ViewModifier {
    let threshold: CGFloat
    @State private var isVisible = false
    init(threshold: CGFloat = 100) {
        self.threshold = threshold
        self.isVisible = false
    }
    func body(content: Content) -> some View {
        content
            .opacity(isVisible ? 1 : 0)
            .onAppear {
                withAnimation(.easeIn(duration: 0.2)) {
                    isVisible = true
                }
            }
    }
}
// ModernSectionHeader is already defined in ModernViewModifiers.swift
</file>

<file path="Sources/Highlighter/Design/ModernViewModifiers.swift">
import SwiftUI
// MARK: - Modern View Modifiers
// Clean, sophisticated components without excessive effects
// MARK: - Card Styles
// Card styles have been consolidated in CardSystem.swift to follow DRY principles
// Use .modernCard(), .modernCardSelected(), .glassCard(), or .compactCard() modifiers
// MARK: - Button Styles
// Note: Primary button styles are now defined in ModernButtonStyles.swift to avoid duplication
// MARK: - List Item Style
struct ModernListItem: ViewModifier {
    var showDivider: Bool = true
    func body(content: Content) -> some View {
        VStack(spacing: 0) {
            content
                .padding(.vertical, .ds.base)
                .padding(.horizontal, .ds.screenPadding)
            if showDivider {
                Divider()
                    .background(DesignSystem.Colors.divider)
                    .padding(.leading, .ds.screenPadding)
            }
        }
    }
}
// MARK: - Input Styles
// Note: ModernTextField is now defined in ModernFormComponents.swift to avoid duplication
// MARK: - Modern Tab Bar Item
struct ModernTabItem: View {
    let icon: String
    let title: String
    let isSelected: Bool
    var body: some View {
        VStack(spacing: 4) {
            Image(systemName: icon)
                .font(.system(size: 20, weight: .medium))
                .foregroundColor(isSelected ? DesignSystem.Colors.primary : DesignSystem.Colors.textTertiary)
                .scaleEffect(isSelected ? 1.1 : 1.0)
                .animation(DesignSystem.Animation.springSnappy, value: isSelected)
            Text(title)
                .font(.ds.micro)
                .foregroundColor(isSelected ? DesignSystem.Colors.primary : DesignSystem.Colors.textTertiary)
        }
        .frame(maxWidth: .infinity)
    }
}
// MARK: - Modern Section Header
struct ModernSectionHeader: View {
    let title: String
    var action: (() -> Void)? = nil
    var actionTitle: String? = nil
    var body: some View {
        HStack {
            Text(title)
                .font(Font.ds.title3)
                .foregroundColor(.ds.text)
            Spacer()
            if let action = action, let actionTitle = actionTitle {
                Button(action: action) {
                    Text(actionTitle)
                        .font(Font.ds.footnoteMedium)
                        .foregroundColor(Color.ds.primary)
                }
            }
        }
        .padding(.horizontal, .ds.screenPadding)
        .padding(.vertical, .ds.small)
    }
}
// MARK: - Highlight Effect (Subtle)
struct ModernHighlight: ViewModifier {
    let isHighlighted: Bool
    func body(content: Content) -> some View {
        content
            .background(
                RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.micro, style: .continuous)
                    .fill(isHighlighted ? DesignSystem.Colors.highlightSubtle : Color.clear)
                    .animation(DesignSystem.Animation.quick, value: isHighlighted)
            )
    }
}
// MARK: - Loading Placeholder
struct ModernPlaceholder: ViewModifier {
    @State private var opacity: Double = 0.5
    func body(content: Content) -> some View {
        content
            .redacted(reason: .placeholder)
            .opacity(opacity)
            .onAppear {
                withAnimation(.easeInOut(duration: 1.0).repeatForever(autoreverses: true)) {
                    opacity = 0.8
                }
            }
    }
}
// MARK: - View Extensions
extension View {
    // Card modifiers are now defined in CardSystem.swift
    func modernListItem(showDivider: Bool = true) -> some View {
        self.modifier(ModernListItem(showDivider: showDivider))
    }
    // modernTextField() extension is now in ModernFormComponents.swift
    func modernHighlight(_ isHighlighted: Bool) -> some View {
        self.modifier(ModernHighlight(isHighlighted: isHighlighted))
    }
    func modernPlaceholder() -> some View {
        self.modifier(ModernPlaceholder())
    }
}
// MARK: - Modern Empty State
struct ModernEmptyState: View {
    let icon: String
    let title: String
    let message: String
    var action: (() -> Void)? = nil
    var actionTitle: String? = nil
    var body: some View {
        VStack(spacing: .ds.medium) {
            Image(systemName: icon)
                .font(.system(size: 48, weight: .light))
                .foregroundColor(Color.ds.textTertiary)
            VStack(spacing: .ds.small) {
                Text(title)
                    .font(.ds.headline)
                    .foregroundColor(.ds.text)
                Text(message)
                    .font(.ds.body)
                    .foregroundColor(.ds.textSecondary)
                    .multilineTextAlignment(.center)
                    .fixedSize(horizontal: false, vertical: true)
            }
            if let action = action, let actionTitle = actionTitle {
                Button(action: action) {
                    Text(actionTitle)
                }
                .unifiedPrimaryButton()
                .padding(.top, .ds.small)
            }
        }
        .padding(.ds.xxl)
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}
</file>

<file path="Sources/Highlighter/Design/VisualEffects.swift">
import SwiftUI
struct GlassBackground: ViewModifier {
    let cornerRadius: CGFloat
    let shadowRadius: CGFloat
    init(cornerRadius: CGFloat = 16, shadowRadius: CGFloat = 8) {
        self.cornerRadius = cornerRadius
        self.shadowRadius = shadowRadius
    }
    func body(content: Content) -> some View {
        content
            .background {
                RoundedRectangle(cornerRadius: cornerRadius)
                    .fill(.ultraThinMaterial)
                    .overlay {
                        RoundedRectangle(cornerRadius: cornerRadius)
                            .stroke(
                                LinearGradient(
                                    colors: [
                                        Color.white.opacity(0.3),
                                        Color.white.opacity(0.1)
                                    ],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                ),
                                lineWidth: 1
                            )
                    }
                    .shadow(color: .black.opacity(0.1), radius: shadowRadius, x: 0, y: 4)
            }
    }
}
struct CardBackground: ViewModifier {
    let isSelected: Bool
    func body(content: Content) -> some View {
        content
            .background {
                RoundedRectangle(cornerRadius: 20)
                    .fill(Color(uiColor: .systemBackground))
                    .overlay {
                        RoundedRectangle(cornerRadius: 20)
                            .stroke(
                                isSelected ?
                                LinearGradient(
                                    colors: [Color.yellow, Color.orange],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                ) :
                                LinearGradient(
                                    colors: [Color.gray.opacity(0.2), Color.gray.opacity(0.1)],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                ),
                                lineWidth: isSelected ? 2 : 1
                            )
                    }
                    .shadow(
                        color: isSelected ? Color.yellow.opacity(0.3) : Color.black.opacity(0.08),
                        radius: isSelected ? 12 : 8,
                        x: 0,
                        y: isSelected ? 6 : 4
                    )
            }
            .scaleEffect(isSelected ? 1.02 : 1.0)
            .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isSelected)
    }
}
// Note: ShimmerEffect and PulseEffect have been moved to AnimationSystem.swift
// to consolidate all animation-related functionality in one place.
// Please use .shimmer() and .pulse() extensions from AnimationSystem.swift
struct SimplifiedParallaxEffect: ViewModifier {
    let magnitude: CGFloat
    func body(content: Content) -> some View {
        GeometryReader { geometry in
            content
                .offset(y: getOffset(geometry))
        }
    }
    private func getOffset(_ geometry: GeometryProxy) -> CGFloat {
        let frame = geometry.frame(in: .global)
        let screenHeight = UIScreen.main.bounds.height
        let progress = frame.minY / screenHeight
        return progress * magnitude
    }
}
extension View {
    // shimmer() method is available from AnimationSystem.swift
    // pulse() method is available from AnimationSystem.swift
    func simplifiedParallax(magnitude: CGFloat = 20) -> some View {
        modifier(SimplifiedParallaxEffect(magnitude: magnitude))
    }
}
struct FloatingActionButton: View {
    let icon: String
    let action: () -> Void
    @State private var isPressed = false
    var body: some View {
        Button(action: {
            HapticManager.shared.impact(HapticManager.ImpactStyle.light)
            action()
        }) {
            Image(systemName: icon)
                .font(.system(size: 24, weight: .semibold))
                .foregroundColor(.white)
                .frame(width: 56, height: 56)
                .background {
                    Circle()
                        .fill(
                            LinearGradient(
                                colors: [Color.yellow, Color.orange],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .shadow(color: .orange.opacity(0.3), radius: 12, x: 0, y: 8)
                }
                .scaleEffect(isPressed ? 0.9 : 1.0)
        }
        .buttonStyle(PressButtonStyle())
    }
}
</file>

<file path="Sources/Highlighter/Models/Article.swift">
import Foundation
import NDKSwift
// NIP-23: Long-form Content
struct Article: Identifiable, Equatable {
    let id: String
    let author: String
    let createdAt: Date
    let title: String
    let summary: String?
    let content: String
    let image: String?
    let blurhash: String?
    let publishedAt: Date?
    let tags: [[String]]
    let event: NDKEvent
    init(from event: NDKEvent) throws {
        guard event.kind == 30023 else {
            throw ArticleError.invalidKind
        }
        self.id = event.id
        self.author = event.pubkey
        self.createdAt = Date(timeIntervalSince1970: TimeInterval(event.createdAt))
        self.event = event
        self.tags = event.tags
        // Extract title from "title" tag
        self.title = event.tags.first(where: { $0.first == "title" })?[safe: 1] ?? "Untitled"
        // Extract summary from "summary" tag
        self.summary = event.tags.first(where: { $0.first == "summary" })?[safe: 1]
        // Extract image from "image" tag
        self.image = event.tags.first(where: { $0.first == "image" })?[safe: 1]
        // Extract blurhash from "blurhash" tag
        self.blurhash = event.tags.first(where: { $0.first == "blurhash" })?[safe: 1]
        // Extract published_at from tag
        if let publishedAtString = event.tags.first(where: { $0.first == "published_at" })?[safe: 1],
           let publishedAtTimestamp = Int64(publishedAtString) {
            self.publishedAt = Date(timeIntervalSince1970: TimeInterval(publishedAtTimestamp))
        } else {
            self.publishedAt = nil
        }
        // Content is the main event content
        self.content = event.content
    }
    var identifier: String? {
        // d tag value for replaceable events
        event.tags.first(where: { $0.first == "d" })?[safe: 1]
    }
    var hashtags: [String] {
        event.tags
            .filter { $0.first == "t" }
            .compactMap { $0[safe: 1] }
    }
    var references: [String] {
        event.tags
            .filter { $0.first == "a" || $0.first == "e" }
            .compactMap { $0[safe: 1] }
    }
    var estimatedReadingTime: Int {
        let wordsPerMinute = 200
        let wordCount = content.split(separator: " ").count
        return max(1, wordCount / wordsPerMinute)
    }
    // Convenience initializer for testing and UI previews
    init(
        id: String,
        identifier: String,
        title: String,
        summary: String?,
        content: String,
        author: String,
        publishedAt: Date?,
        image: String?,
        hashtags: [String],
        createdAt: Timestamp
    ) {
        self.id = id
        self.author = author
        self.createdAt = Date(timeIntervalSince1970: TimeInterval(createdAt))
        self.title = title
        self.summary = summary
        self.content = content
        self.image = image
        self.blurhash = nil
        self.publishedAt = publishedAt
        self.tags = []
        // Create a mock event for the convenience init
        var tags: [[String]] = [
            ["d", identifier],
            ["title", title]
        ]
        if let summary = summary {
            tags.append(["summary", summary])
        }
        if let image = image {
            tags.append(["image", image])
        }
        for hashtag in hashtags {
            tags.append(["t", hashtag])
        }
        // Create the event with all required parameters
        let event = NDKEvent(
            id: id,
            pubkey: author,
            createdAt: createdAt,
            kind: 30023,
            tags: tags,
            content: content,
            sig: "" // Empty signature for mock events
        )
        self.event = event
    }
}
enum ArticleError: Error {
    case invalidKind
    case missingRequiredFields
}
</file>

<file path="Sources/Highlighter/Models/ArticleCuration.swift">
import Foundation
import NDKSwift
/// NIP-51 Article Curation (kind:30004)
struct ArticleCuration: Identifiable, Equatable, Hashable {
    let id: String
    let event: NDKEvent
    let name: String
    let title: String
    let description: String?
    let image: String?
    let author: String
    let createdAt: Date
    let updatedAt: Date
    let articles: [ArticleReference]
    func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(title)
        hasher.combine(author)
    }
    static func == (lhs: ArticleCuration, rhs: ArticleCuration) -> Bool {
        lhs.id == rhs.id &&
        lhs.name == rhs.name &&
        lhs.title == rhs.title &&
        lhs.author == rhs.author &&
        lhs.articles == rhs.articles
    }
    // For testing/preview
    init(id: String, event: NDKEvent, name: String, title: String, description: String?, image: String?, author: String, createdAt: Date, updatedAt: Date, articles: [ArticleReference]) {
        self.id = id
        self.event = event
        self.name = name
        self.title = title
        self.description = description
        self.image = image
        self.author = author
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.articles = articles
    }
    struct ArticleReference: Equatable, Hashable {
        let url: String?
        let eventId: String?
        let eventAddress: String?
        let addedAt: Date
        init(from tag: [String]) {
            switch tag.first {
            case "r":
                self.url = tag.count > 1 ? tag[1] : nil
                self.eventId = nil
                self.eventAddress = nil
            case "e":
                self.url = nil
                self.eventId = tag.count > 1 ? tag[1] : nil
                self.eventAddress = nil
            case "a":
                self.url = nil
                self.eventId = nil
                self.eventAddress = tag.count > 1 ? tag[1] : nil
            default:
                self.url = nil
                self.eventId = nil
                self.eventAddress = nil
            }
            // Check for timestamp in tag
            if let timestampStr = tag.last,
               let timestamp = Int64(timestampStr),
               tag.count > 2 {
                self.addedAt = Date(timeIntervalSince1970: TimeInterval(timestamp))
            } else {
                self.addedAt = Date()
            }
        }
    }
    init(from event: NDKEvent) throws {
        guard event.kind == 30004 else {
            throw CurationError.invalidKind
        }
        self.id = event.id
        self.event = event
        self.author = event.pubkey
        self.createdAt = Date(timeIntervalSince1970: TimeInterval(event.createdAt))
        // Parse d tag for identifier
        let dTag = event.tags.first { $0.first == "d" }
        guard let name = dTag?.count ?? 0 > 1 ? dTag?[1] : nil else {
            throw CurationError.missingIdentifier
        }
        self.name = name
        // Parse other metadata tags
        var title: String?
        var description: String?
        var image: String?
        var updatedAt: Date?
        var articles: [ArticleReference] = []
        for tag in event.tags {
            switch tag.first {
            case "title":
                title = tag.count > 1 ? tag[1] : nil
            case "description":
                description = tag.count > 1 ? tag[1] : nil
            case "image":
                image = tag.count > 1 ? tag[1] : nil
            case "updated_at":
                if tag.count > 1,
                   let timestamp = Int64(tag[1]) {
                    updatedAt = Date(timeIntervalSince1970: TimeInterval(timestamp))
                }
            case "r", "e", "a":
                articles.append(ArticleReference(from: tag))
            default:
                break
            }
        }
        self.title = title ?? name
        self.description = description
        self.image = image
        self.updatedAt = updatedAt ?? createdAt
        self.articles = articles
    }
    static func create(
        ndk: NDK,
        name: String,
        title: String,
        description: String? = nil,
        image: String? = nil,
        articles: [(type: ArticleType, value: String)] = [],
        signer: NDKSigner
    ) async throws -> NDKEvent {
        var tags: [[String]] = [
            ["d", name],
            ["title", title]
        ]
        if let description = description {
            tags.append(["description", description])
        }
        if let image = image {
            tags.append(["image", image])
        }
        let timestamp = String(Int64(Date().timeIntervalSince1970))
        for article in articles {
            switch article.type {
            case .url:
                tags.append(["r", article.value, timestamp])
            case .event:
                tags.append(["e", article.value, timestamp])
            case .address:
                tags.append(["a", article.value, timestamp])
            }
        }
        let event = try await NDKEventBuilder(ndk: ndk)
            .kind(30004)
            .content("")
            .tags(tags)
            .build(signer: signer)
        return event
    }
    enum ArticleType {
        case url
        case event
        case address
    }
}
enum CurationError: LocalizedError {
    case invalidKind
    case missingIdentifier
    var errorDescription: String? {
        switch self {
        case .invalidKind:
            return "Event is not an article curation (kind:30004)"
        case .missingIdentifier:
            return "Missing required 'd' tag identifier"
        }
    }
}
</file>

<file path="Sources/Highlighter/Models/FollowPack.swift">
import Foundation
import NDKSwift
/// NIP-51 Follow Pack (kind:39089)
struct FollowPack: Identifiable, Equatable {
    let id: String
    let event: NDKEvent
    let name: String
    let title: String
    let description: String?
    let image: String?
    let author: String
    let createdAt: Date
    let profiles: [String] // Array of pubkeys
    // For testing/preview
    init(id: String, event: NDKEvent, name: String, title: String, description: String?, image: String?, author: String, createdAt: Date, profiles: [String]) {
        self.id = id
        self.event = event
        self.name = name
        self.title = title
        self.description = description
        self.image = image
        self.author = author
        self.createdAt = createdAt
        self.profiles = profiles
    }
    init(from event: NDKEvent) throws {
        guard event.kind == 39089 else {
            throw FollowPackError.invalidKind
        }
        self.id = event.id
        self.event = event
        self.author = event.pubkey
        self.createdAt = Date(timeIntervalSince1970: TimeInterval(event.createdAt))
        // Parse d tag for identifier
        let dTag = event.tags.first { $0.first == "d" }
        guard let name = dTag?.count ?? 0 > 1 ? dTag?[1] : nil else {
            throw FollowPackError.missingIdentifier
        }
        self.name = name
        // Parse metadata and profiles
        var title: String?
        var description: String?
        var image: String?
        var profiles: [String] = []
        for tag in event.tags {
            switch tag.first {
            case "title":
                title = tag.count > 1 ? tag[1] : nil
            case "description":
                description = tag.count > 1 ? tag[1] : nil
            case "image":
                image = tag.count > 1 ? tag[1] : nil
            case "p":
                if tag.count > 1 {
                    profiles.append(tag[1])
                }
            default:
                break
            }
        }
        self.title = title ?? name
        self.description = description
        self.image = image
        self.profiles = profiles
    }
    static func create(
        ndk: NDK,
        name: String,
        title: String,
        description: String? = nil,
        image: String? = nil,
        profiles: [String],
        signer: NDKSigner
    ) async throws -> NDKEvent {
        var tags: [[String]] = [
            ["d", name],
            ["title", title]
        ]
        if let description = description {
            tags.append(["description", description])
        }
        if let image = image {
            tags.append(["image", image])
        }
        // Add profile tags
        for profile in profiles {
            tags.append(["p", profile])
        }
        let event = try await NDKEventBuilder(ndk: ndk)
            .kind(39089)
            .content("")
            .tags(tags)
            .build(signer: signer)
        return event
    }
    /// Import a follow pack by adding its profiles to the user's follow list
    func importToFollowList(currentFollows: Set<String>) -> Set<String> {
        var updatedFollows = currentFollows
        for profile in profiles {
            updatedFollows.insert(profile)
        }
        return updatedFollows
    }
}
enum FollowPackError: LocalizedError {
    case invalidKind
    case missingIdentifier
    var errorDescription: String? {
        switch self {
        case .invalidKind:
            return "Event is not a follow pack (kind:39089)"
        case .missingIdentifier:
            return "Missing required 'd' tag identifier"
        }
    }
}
</file>

<file path="Sources/Highlighter/Models/HighlightEvent.swift">
import Foundation
import NDKSwift
/// NIP-84 Highlight Event (kind:9802)
struct HighlightEvent: Identifiable, Equatable {
    let id: String
    let event: NDKEvent
    let content: String
    let author: String
    let createdAt: Date
    // NIP-84 specific fields
    let context: String?
    let url: String?
    let referencedEvent: String?
    let attributedAuthors: [String]
    let comment: String?
    // Additional fields for publishing
    var source: String? { url }
    var pubkey: String { event.pubkey }
    // Convert to NDKEvent for use with ZapButton
    func toNostrEvent() -> NDKEvent {
        return event
    }
    // For creating new highlights
    init(content: String, context: String? = nil, source: String? = nil, author: String? = nil, comment: String? = nil) {
        self.id = UUID().uuidString
        self.event = NDKEvent(id: "", pubkey: "", createdAt: 0, kind: 9802, tags: [], content: content, sig: "")
        self.content = content
        self.author = ""
        self.createdAt = Date()
        self.context = context
        self.url = source
        self.referencedEvent = nil
        self.attributedAuthors = author != nil ? [author!] : []
        self.comment = comment
    }
    // For testing/preview
    init(id: String, event: NDKEvent, content: String, author: String, createdAt: Date, context: String?, url: String?, referencedEvent: String?, attributedAuthors: [String], comment: String?) {
        self.id = id
        self.event = event
        self.content = content
        self.author = author
        self.createdAt = createdAt
        self.context = context
        self.url = url
        self.referencedEvent = referencedEvent
        self.attributedAuthors = attributedAuthors
        self.comment = comment
    }
    init(from event: NDKEvent) throws {
        guard event.kind == 9802 else {
            throw HighlightError.invalidKind
        }
        self.id = event.id
        self.event = event
        self.content = event.content
        self.author = event.pubkey
        self.createdAt = Date(timeIntervalSince1970: TimeInterval(event.createdAt))
        // Parse NIP-84 tags
        var context: String?
        var url: String?
        var referencedEvent: String?
        var attributedAuthors: [String] = []
        var comment: String?
        for tag in event.tags {
            switch tag.first {
            case "context":
                context = tag.count > 1 ? tag[1] : nil
            case "r":
                url = tag.count > 1 ? tag[1] : nil
            case "e":
                referencedEvent = tag.count > 1 ? tag[1] : nil
            case "a":
                referencedEvent = tag.count > 1 ? tag[1] : nil
            case "p":
                if tag.count > 1 {
                    attributedAuthors.append(tag[1])
                }
            case "comment":
                comment = tag.count > 1 ? tag[1] : nil
            default:
                break
            }
        }
        self.context = context
        self.url = url
        self.referencedEvent = referencedEvent
        self.attributedAuthors = attributedAuthors
        self.comment = comment
    }
    static func create(
        ndk: NDK,
        content: String,
        context: String? = nil,
        url: String? = nil,
        referencedEvent: String? = nil,
        attributedAuthors: [String] = [],
        comment: String? = nil,
        signer: NDKSigner
    ) async throws -> NDKEvent {
        var tags: [[String]] = []
        if let context = context {
            tags.append(["context", context])
        }
        if let url = url {
            tags.append(["r", url])
        }
        if let referencedEvent = referencedEvent {
            if referencedEvent.contains(":") {
                tags.append(["a", referencedEvent])
            } else {
                tags.append(["e", referencedEvent])
            }
        }
        for author in attributedAuthors {
            tags.append(["p", author])
        }
        if let comment = comment {
            tags.append(["comment", comment])
        }
        let event = try await NDKEventBuilder(ndk: ndk)
            .kind(9802)
            .content(content)
            .tags(tags)
            .build(signer: signer)
        return event
    }
}
enum HighlightError: LocalizedError {
    case invalidKind
    case missingRequired
    var errorDescription: String? {
        switch self {
        case .invalidKind:
            return "Event is not a highlight (kind:9802)"
        case .missingRequired:
            return "Missing required fields for highlight"
        }
    }
}
</file>

<file path="Sources/Highlighter/Models/SwarmHighlight.swift">
import Foundation
import NDKSwift
struct SwarmHighlight: Identifiable, Equatable {
    let id = UUID()
    let text: String
    let range: NSRange
    let highlights: [HighlightInfo]
    static func == (lhs: SwarmHighlight, rhs: SwarmHighlight) -> Bool {
        lhs.id == rhs.id
    }
    var totalZaps: Int {
        highlights.reduce(0) { $0 + $1.zapCount }
    }
    var totalHighlighters: Int {
        highlights.count
    }
    var intensity: Double {
        // Constants for intensity calculation
        let highlighterDivisor = 10.0  // Each 10 highlighters = 1.0 base intensity
        let zapDivisor = 100.0         // Each 100 zaps = 1.0 zap boost
        let maxIntensity = 1.0         // Maximum intensity value
        let baseIntensity = Double(totalHighlighters) / highlighterDivisor
        let zapBoost = Double(totalZaps) / zapDivisor
        return min(baseIntensity + zapBoost, maxIntensity)
    }
    struct HighlightInfo: Identifiable {
        let id = UUID()
        let event: NDKEvent
        let author: NDKUser
        let profile: NDKUserProfile?
        let note: String?
        let createdAt: Date
        let zapCount: Int
    }
}
class SwarmHighlightManager: ObservableObject {
    @Published var swarmHighlights: [SwarmHighlight] = []
    @Published var isLoading = false
    var ndk: NDK
    private var dataSource: NDKDataSource<NDKEvent>?
    init(ndk: NDK) {
        self.ndk = ndk
    }
    func loadSwarmHighlights(for articleURL: String? = nil, articleEvent: String? = nil) {
        isLoading = true
        swarmHighlights = []
        Task {
            var tagsDict: [String: Set<String>] = [:]
            if let url = articleURL {
                tagsDict["r"] = [url]
            } else if let eventId = articleEvent {
                tagsDict["e"] = [eventId]
            }
            let filter = NDKFilter(
                kinds: [9802], // NIP-84 highlights
                limit: 100,
                tags: tagsDict.isEmpty ? nil : tagsDict
            )
            dataSource = await ndk.outbox.observe(filter: filter, maxAge: 3600, cachePolicy: .cacheWithNetwork)
            var highlightEvents: [NDKEvent] = []
            for await event in dataSource!.events {
                highlightEvents.append(event)
                await processHighlights(highlightEvents)
            }
        }
    }
    @MainActor
    private func processHighlights(_ events: [NDKEvent]) async {
        var highlightsByText: [String: [SwarmHighlight.HighlightInfo]] = [:]
        for event in events {
            let content = event.content
            guard !content.isEmpty else { continue }
            // Use streaming observe API to get the profile
            var profile: NDKUserProfile?
            for await p in await ndk.profileManager.observe(for: event.pubkey, maxAge: TimeConstants.hour) {
                profile = p
                break // Just get the first result
            }
            let zapCount = await fetchZapCount(for: event.id)
            let info = SwarmHighlight.HighlightInfo(
                event: event,
                author: NDKUser(pubkey: event.pubkey),
                profile: profile,
                note: event.tags.first(where: { $0.count > 1 && $0[0] == "comment" })?.dropFirst().joined(separator: " "),
                createdAt: Date(timeIntervalSince1970: TimeInterval(event.createdAt)),
                zapCount: zapCount
            )
            if highlightsByText[content] != nil {
                highlightsByText[content]?.append(info)
            } else {
                highlightsByText[content] = [info]
            }
        }
        swarmHighlights = highlightsByText.map { text, infos in
            SwarmHighlight(
                text: text,
                range: NSRange(location: 0, length: text.count),
                highlights: infos.sorted { $0.createdAt < $1.createdAt }
            )
        }.sorted { $0.totalHighlighters > $1.totalHighlighters }
        isLoading = false
    }
    private func fetchZapCount(for eventId: String) async -> Int {
        let filter = NDKFilter(
            kinds: [9735],
            events: [eventId],
            limit: 1000
        )
        let dataSource = await ndk.outbox.observe(filter: filter, maxAge: 3600, cachePolicy: .cacheWithNetwork)
        var count = 0
        // Limit zap count to prevent excessive API calls
        let maxZapCount = 100
        for await _ in dataSource.events {
            count += 1
            if count > maxZapCount { break }
        }
        return count
    }
    func findOverlappingHighlights(in text: String) -> [(range: NSRange, highlight: SwarmHighlight)] {
        var results: [(NSRange, SwarmHighlight)] = []
        for highlight in swarmHighlights {
            if let range = text.range(of: highlight.text) {
                let nsRange = NSRange(range, in: text)
                results.append((nsRange, highlight))
            }
        }
        return results
    }
}
</file>

<file path="Sources/Highlighter/Services/AIHighlightEngine.swift">
import Foundation
import NaturalLanguage
import CoreML
import NDKSwift
/// AI-powered engine for analyzing text and suggesting highlights
/// Uses NLP techniques to identify key passages, important concepts, and quotable content
actor AIHighlightEngine {
    // MARK: - Types
    enum AnalysisMode {
        case quick      // Basic keyword and sentence importance
        case balanced   // Standard NLP analysis
        case thorough   // Deep analysis with multiple passes
    }
    struct TextSegment {
        let text: String
        let range: NSRange
        let sentence: String
        let paragraph: String
        let importance: Double
        let features: TextFeatures
    }
    struct TextFeatures {
        let sentencePosition: Double      // Position in paragraph (0-1)
        let paragraphPosition: Double     // Position in document (0-1)
        let wordCount: Int
        let uniqueWordRatio: Double
        let namedEntityCount: Int
        let quotationPresent: Bool
        let statisticPresent: Bool
        let keywordDensity: Double
        let sentimentScore: Double
        let readabilityScore: Double
        let technicalTermCount: Int
        let transitionWordScore: Double
        let emphasisScore: Double         // Based on formatting, punctuation
    }
    struct AnalysisResult {
        let suggestions: [HighlightSuggestion]
        let documentMetrics: DocumentMetrics
        let keyTopics: [String]
        let readingTime: Int
        let complexityScore: Double
    }
    struct HighlightSuggestion {
        let id = UUID()
        let text: String
        let range: NSRange
        let confidence: Double
        let category: SuggestionCategory
        let reason: String
        let context: String?
        let relatedTopics: [String]
        let importance: ImportanceLevel
    }
    enum SuggestionCategory {
        case thesisStatement
        case keyInsight
        case statistic
        case quote
        case definition
        case conclusion
        case example
        case novelConcept
        case controversy
        case summary
        var displayName: String {
            switch self {
            case .thesisStatement: return "Core Argument"
            case .keyInsight: return "Key Insight"
            case .statistic: return "Important Data"
            case .quote: return "Notable Quote"
            case .definition: return "Key Definition"
            case .conclusion: return "Conclusion"
            case .example: return "Illustrative Example"
            case .novelConcept: return "New Concept"
            case .controversy: return "Point of Debate"
            case .summary: return "Summary"
            }
        }
    }
    enum ImportanceLevel: Int {
        case low = 1
        case medium = 2
        case high = 3
        case critical = 4
    }
    struct DocumentMetrics {
        let totalWords: Int
        let totalSentences: Int
        let averageSentenceLength: Double
        let lexicalDiversity: Double
        let readabilityScore: Double
        let technicalDensity: Double
        let topKeywords: [(String, Int)]
    }
    // MARK: - Properties
    private let nlpProcessor = NLPProcessor()
    private let sentimentAnalyzer = NLSentimentAnalyzer()
    private let keywordExtractor = KeywordExtractor()
    private let importanceCalculator = ImportanceCalculator()
    // Domain-specific keywords for different fields
    private let domainKeywords: [String: Set<String>] = [
        "technology": ["AI", "machine learning", "algorithm", "data", "software", "hardware", "innovation", "digital", "automation", "blockchain"],
        "science": ["hypothesis", "experiment", "research", "study", "evidence", "theory", "discovery", "analysis", "observation", "conclusion"],
        "philosophy": ["consciousness", "ethics", "morality", "existence", "knowledge", "truth", "reality", "meaning", "purpose", "free will"],
        "business": ["strategy", "market", "revenue", "growth", "innovation", "customer", "value", "competitive", "profit", "efficiency"],
        "literature": ["narrative", "metaphor", "symbolism", "theme", "character", "plot", "style", "genre", "motif", "allegory"]
    ]
    // Transition words that often precede important insights
    private let transitionIndicators = Set([
        "however", "therefore", "moreover", "furthermore", "consequently",
        "nevertheless", "thus", "hence", "accordingly", "importantly",
        "significantly", "notably", "remarkably", "interestingly",
        "in conclusion", "in summary", "to summarize", "ultimately",
        "the key is", "the point is", "essentially", "fundamentally"
    ])
    // MARK: - Public Methods
    func analyzeText(_ text: String, mode: AnalysisMode = .balanced) async throws -> AnalysisResult {
        // Pre-process text
        let cleanedText = preprocessText(text)
        // Extract document structure
        _ = extractParagraphs(from: cleanedText)
        let sentences = extractSentences(from: cleanedText)
        // Calculate document metrics
        let metrics = await calculateDocumentMetrics(text: cleanedText, sentences: sentences)
        // Identify key topics
        let topics = await identifyKeyTopics(from: cleanedText)
        // Analyze each sentence
        var segments: [TextSegment] = []
        for (index, sentence) in sentences.enumerated() {
            if let segment = await analyzeSegment(
                sentence: sentence,
                index: index,
                totalSentences: sentences.count,
                fullText: cleanedText,
                mode: mode
            ) {
                segments.append(segment)
            }
        }
        // Generate suggestions based on analysis
        let suggestions = await generateSuggestions(
            from: segments,
            topics: topics,
            mode: mode,
            metrics: metrics
        )
        // Calculate reading time (words per minute)
        let readingTime = max(1, metrics.totalWords / 200)
        // Calculate complexity score
        let complexityScore = calculateComplexityScore(metrics: metrics)
        return AnalysisResult(
            suggestions: suggestions,
            documentMetrics: metrics,
            keyTopics: topics,
            readingTime: readingTime,
            complexityScore: complexityScore
        )
    }
    // MARK: - Text Processing
    private func preprocessText(_ text: String) -> String {
        // Remove excessive whitespace while preserving paragraph structure
        let lines = text.components(separatedBy: .newlines)
        let processedLines = lines.map { line in
            line.trimmingCharacters(in: .whitespaces)
        }.filter { !$0.isEmpty }
        return processedLines.joined(separator: "\n\n")
    }
    private func extractParagraphs(from text: String) -> [String] {
        text.components(separatedBy: "\n\n")
            .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }
            .filter { !$0.isEmpty }
    }
    private func extractSentences(from text: String) -> [(sentence: String, range: NSRange)] {
        var sentences: [(String, NSRange)] = []
        let tokenizer = NLTokenizer(unit: .sentence)
        tokenizer.string = text
        tokenizer.enumerateTokens(in: text.startIndex..<text.endIndex) { range, _ in
            let sentence = String(text[range])
            let nsRange = NSRange(range, in: text)
            sentences.append((sentence, nsRange))
            return true
        }
        return sentences
    }
    // MARK: - Segment Analysis
    private func analyzeSegment(
        sentence: (sentence: String, range: NSRange),
        index: Int,
        totalSentences: Int,
        fullText: String,
        mode: AnalysisMode
    ) async -> TextSegment? {
        let text = sentence.sentence.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !text.isEmpty else { return nil }
        // Extract features
        let features = await extractFeatures(
            from: text,
            sentenceIndex: index,
            totalSentences: totalSentences,
            fullText: fullText
        )
        // Calculate importance score
        let importance = importanceCalculator.calculate(
            features: features,
            mode: mode,
            sentenceIndex: index,
            totalSentences: totalSentences
        )
        // Find containing paragraph
        let paragraph = findContainingParagraph(
            for: sentence.range,
            in: fullText
        ) ?? text
        return TextSegment(
            text: text,
            range: sentence.range,
            sentence: text,
            paragraph: paragraph,
            importance: importance,
            features: features
        )
    }
    private func extractFeatures(
        from text: String,
        sentenceIndex: Int,
        totalSentences: Int,
        fullText: String
    ) async -> TextFeatures {
        // Basic metrics
        let words = text.components(separatedBy: .whitespaces).filter { !$0.isEmpty }
        let wordCount = words.count
        let uniqueWords = Set(words.map { $0.lowercased() })
        let uniqueWordRatio = Double(uniqueWords.count) / Double(max(1, wordCount))
        // Position metrics
        let sentencePosition = Double(sentenceIndex) / Double(max(1, totalSentences - 1))
        let paragraphPosition = calculateParagraphPosition(for: text, in: fullText)
        // Named entities
        let namedEntityCount = await countNamedEntities(in: text)
        // Check for quotations
        let quotationPresent = text.contains("\"") || text.contains("\u{201C}") || text.contains("'")
        // Check for statistics
        let statisticPresent = containsStatistic(text)
        // Keyword density
        let keywordDensity = calculateKeywordDensity(text: text, words: words)
        // Sentiment analysis
        let sentimentScore = await analyzeSentiment(text)
        // Readability
        let readabilityScore = calculateReadability(text: text, wordCount: wordCount)
        // Technical terms
        let technicalTermCount = countTechnicalTerms(in: words)
        // Transition words
        let transitionWordScore = calculateTransitionScore(words: words)
        // Emphasis indicators
        let emphasisScore = calculateEmphasisScore(text: text)
        return TextFeatures(
            sentencePosition: sentencePosition,
            paragraphPosition: paragraphPosition,
            wordCount: wordCount,
            uniqueWordRatio: uniqueWordRatio,
            namedEntityCount: namedEntityCount,
            quotationPresent: quotationPresent,
            statisticPresent: statisticPresent,
            keywordDensity: keywordDensity,
            sentimentScore: sentimentScore,
            readabilityScore: readabilityScore,
            technicalTermCount: technicalTermCount,
            transitionWordScore: transitionWordScore,
            emphasisScore: emphasisScore
        )
    }
    // MARK: - Feature Extraction Helpers
    private func countNamedEntities(in text: String) async -> Int {
        return await nlpProcessor.extractNamedEntities(from: text).count
    }
    private func containsStatistic(_ text: String) -> Bool {
        // Check for percentages
        if text.range(of: #"\\d+\\.?\\d*\\s*%"#, options: .regularExpression) != nil {
            return true
        }
        // Check for numerical comparisons
        if text.range(of: #"\\d+\\.?\\d*\\s*(times|x|×)\\s+(more|less|greater|higher|lower)"#, options: [.regularExpression, .caseInsensitive]) != nil {
            return true
        }
        // Check for fractions and ratios
        if text.range(of: #"\\d+\\s*(out of|of|in)\\s*\\d+"#, options: .regularExpression) != nil {
            return true
        }
        // Check for statistical terms with numbers
        let statisticalTerms = ["average", "median", "mean", "increased", "decreased", "rose", "fell", "growth", "decline"]
        for term in statisticalTerms {
            if text.localizedCaseInsensitiveContains(term) && 
               text.range(of: #"\\d+\\.?\\d*"#, options: .regularExpression) != nil {
                return true
            }
        }
        return false
    }
    private func calculateKeywordDensity(text: String, words: [String]) -> Double {
        let lowerWords = words.map { $0.lowercased() }
        var keywordCount = 0
        for domain in domainKeywords.values {
            for keyword in domain {
                keywordCount += lowerWords.filter { $0.contains(keyword.lowercased()) }.count
            }
        }
        return Double(keywordCount) / Double(max(1, words.count))
    }
    private func analyzeSentiment(_ text: String) async -> Double {
        return await sentimentAnalyzer.analyzeSentiment(for: text)
    }
    private func calculateReadability(text: String, wordCount: Int) -> Double {
        let sentences = text.components(separatedBy: CharacterSet(charactersIn: ".!?"))
            .filter { !$0.isEmpty }
        let sentenceCount = max(1, sentences.count)
        // Simple readability based on average sentence length
        let avgSentenceLength = Double(wordCount) / Double(sentenceCount)
        // Optimal sentence length is around 15-20 words
        if avgSentenceLength >= 15 && avgSentenceLength <= 20 {
            return 1.0
        } else if avgSentenceLength < 10 || avgSentenceLength > 30 {
            return 0.5
        } else {
            return 0.75
        }
    }
    private func countTechnicalTerms(in words: [String]) -> Int {
        let technicalPatterns = [
            #".*tion$"#,
            #".*ity$"#,
            #".*ism$"#,
            #".*ology$"#,
            #".*ization$"#
        ]
        return words.filter { word in
            let lower = word.lowercased()
            return lower.count > 8 || technicalPatterns.contains { pattern in
                lower.range(of: pattern, options: .regularExpression) != nil
            }
        }.count
    }
    private func calculateTransitionScore(words: [String]) -> Double {
        let lowerWords = Set(words.map { $0.lowercased() })
        let foundTransitions = transitionIndicators.intersection(lowerWords)
        return foundTransitions.isEmpty ? 0.0 : 1.0
    }
    private func calculateEmphasisScore(text: String) -> Double {
        var score = 0.0
        // Check for emphasis punctuation
        if text.contains("!") { score += 0.3 }
        if text.contains(":") { score += 0.2 }
        if text.contains("—") || text.contains("--") { score += 0.2 }
        // Check for quoted content
        if text.contains("\"") || text.contains("\u{201C}") { score += 0.3 }
        // Check for all caps words (but not single letters)
        let words = text.components(separatedBy: .whitespaces)
        let capsWords = words.filter { $0.count > 1 && $0 == $0.uppercased() && $0.rangeOfCharacter(from: .letters) != nil }
        if !capsWords.isEmpty { score += 0.4 }
        return min(1.0, score)
    }
    private func calculateParagraphPosition(for sentence: String, in fullText: String) -> Double {
        guard let sentenceRange = fullText.range(of: sentence) else { return 0.5 }
        let position = fullText.distance(from: fullText.startIndex, to: sentenceRange.lowerBound)
        return Double(position) / Double(fullText.count)
    }
    private func findContainingParagraph(for range: NSRange, in text: String) -> String? {
        let paragraphs = extractParagraphs(from: text)
        var currentLocation = 0
        for paragraph in paragraphs {
            let paragraphLength = paragraph.count + 2 // Account for newlines
            let paragraphRange = NSRange(location: currentLocation, length: paragraph.count)
            if NSLocationInRange(range.location, paragraphRange) {
                return paragraph
            }
            currentLocation += paragraphLength
        }
        return nil
    }
    // MARK: - Suggestion Generation
    private func generateSuggestions(
        from segments: [TextSegment],
        topics: [String],
        mode: AnalysisMode,
        metrics: DocumentMetrics
    ) async -> [HighlightSuggestion] {
        var suggestions: [HighlightSuggestion] = []
        // Sort segments by importance
        let sortedSegments = segments.sorted { $0.importance > $1.importance }
        // Determine how many suggestions based on mode
        let suggestionCount: Int
        switch mode {
        case .quick:
            suggestionCount = min(5, sortedSegments.count)
        case .balanced:
            suggestionCount = min(10, sortedSegments.count)
        case .thorough:
            suggestionCount = min(15, sortedSegments.count)
        }
        // Generate suggestions for top segments
        for segment in sortedSegments.prefix(suggestionCount) {
            if let suggestion = await createSuggestion(
                from: segment,
                topics: topics,
                metrics: metrics
            ) {
                suggestions.append(suggestion)
            }
        }
        // Sort by position in document for natural reading flow
        return suggestions.sorted { $0.range.location < $1.range.location }
    }
    private func createSuggestion(
        from segment: TextSegment,
        topics: [String],
        metrics: DocumentMetrics
    ) async -> HighlightSuggestion? {
        // Determine category
        let category = categorizeSegment(segment)
        // Generate reason
        let reason = generateReason(for: segment, category: category)
        // Find related topics
        let relatedTopics = findRelatedTopics(in: segment.text, from: topics)
        // Determine importance level
        let importance = determineImportance(segment: segment, category: category)
        // Calculate confidence
        let confidence = calculateConfidence(
            segment: segment,
            category: category,
            metrics: metrics
        )
        // Extract context if needed
        let context = segment.paragraph != segment.sentence ? segment.paragraph : nil
        return HighlightSuggestion(
            text: segment.text,
            range: segment.range,
            confidence: confidence,
            category: category,
            reason: reason,
            context: context,
            relatedTopics: relatedTopics,
            importance: importance
        )
    }
    private func categorizeSegment(_ segment: TextSegment) -> SuggestionCategory {
        let features = segment.features
        // Check for thesis statement characteristics
        if features.sentencePosition < 0.2 && features.transitionWordScore > 0 {
            return .thesisStatement
        }
        // Check for conclusion
        if features.sentencePosition > 0.8 && features.transitionWordScore > 0 {
            return .conclusion
        }
        // Check for statistics
        if features.statisticPresent {
            return .statistic
        }
        // Check for quotes
        if features.quotationPresent {
            return .quote
        }
        // Check for definitions (usually contain "is" or "means")
        let text = segment.text.lowercased()
        if text.contains(" is ") || text.contains(" means ") || text.contains(" defined as ") {
            return .definition
        }
        // Check for examples
        if text.contains("for example") || text.contains("for instance") || text.contains("such as") {
            return .example
        }
        // High technical term count might indicate novel concept
        if features.technicalTermCount > 2 {
            return .novelConcept
        }
        // Strong sentiment might indicate controversy
        if abs(features.sentimentScore) > 0.7 {
            return .controversy
        }
        // Default to key insight
        return .keyInsight
    }
    private func generateReason(for segment: TextSegment, category: SuggestionCategory) -> String {
        switch category {
        case .thesisStatement:
            return "Core argument that frames the entire discussion"
        case .keyInsight:
            return segment.features.transitionWordScore > 0 ? "Important conclusion or insight" : "Key point in the argument"
        case .statistic:
            return "Data point that supports the argument"
        case .quote:
            return "Notable quotation from an authority"
        case .definition:
            return "Essential definition for understanding"
        case .conclusion:
            return "Summary of main points"
        case .example:
            return "Concrete example that illustrates the concept"
        case .novelConcept:
            return "Introduction of a new or complex idea"
        case .controversy:
            return "Point of debate or strong opinion"
        case .summary:
            return "Concise summary of key ideas"
        }
    }
    private func findRelatedTopics(in text: String, from topics: [String]) -> [String] {
        let lowerText = text.lowercased()
        return topics.filter { topic in
            lowerText.contains(topic.lowercased())
        }.prefix(3).map { $0 }
    }
    private func determineImportance(segment: TextSegment, category: SuggestionCategory) -> ImportanceLevel {
        // Category-based importance
        let categoryImportance: ImportanceLevel
        switch category {
        case .thesisStatement, .conclusion:
            categoryImportance = .critical
        case .keyInsight, .statistic, .novelConcept:
            categoryImportance = .high
        case .definition, .quote, .controversy:
            categoryImportance = .medium
        case .example, .summary:
            categoryImportance = .low
        }
        // Adjust based on segment importance score
        if segment.importance > 0.9 {
            return .critical
        } else if segment.importance > 0.7 && categoryImportance.rawValue >= ImportanceLevel.medium.rawValue {
            return ImportanceLevel(rawValue: min(categoryImportance.rawValue + 1, ImportanceLevel.critical.rawValue)) ?? categoryImportance
        }
        return categoryImportance
    }
    private func calculateConfidence(
        segment: TextSegment,
        category: SuggestionCategory,
        metrics: DocumentMetrics
    ) -> Double {
        var confidence = segment.importance
        // Boost confidence for certain categories
        switch category {
        case .statistic:
            confidence *= 1.2
        case .thesisStatement, .conclusion:
            confidence *= 1.15
        case .quote:
            confidence *= 1.1
        default:
            break
        }
        // Adjust based on document quality
        if metrics.readabilityScore > 0.7 {
            confidence *= 1.1
        }
        // Ensure confidence is between 0 and 1
        return min(1.0, max(0.0, confidence))
    }
    // MARK: - Document Analysis
    private func calculateDocumentMetrics(text: String, sentences: [(String, NSRange)]) async -> DocumentMetrics {
        let words = text.components(separatedBy: .whitespacesAndNewlines).filter { !$0.isEmpty }
        let totalWords = words.count
        let totalSentences = sentences.count
        let averageSentenceLength = Double(totalWords) / Double(max(1, totalSentences))
        // Lexical diversity (unique words / total words)
        let uniqueWords = Set(words.map { $0.lowercased() })
        let lexicalDiversity = Double(uniqueWords.count) / Double(max(1, totalWords))
        // Readability score (simplified)
        let readabilityScore = calculateOverallReadability(
            avgSentenceLength: averageSentenceLength,
            lexicalDiversity: lexicalDiversity
        )
        // Technical density
        let technicalWords = words.filter { word in
            word.count > 8 || countTechnicalTerms(in: [word]) > 0
        }
        let technicalDensity = Double(technicalWords.count) / Double(max(1, totalWords))
        // Top keywords
        let topKeywords = await keywordExtractor.extractTopKeywords(from: text, count: 10)
        return DocumentMetrics(
            totalWords: totalWords,
            totalSentences: totalSentences,
            averageSentenceLength: averageSentenceLength,
            lexicalDiversity: lexicalDiversity,
            readabilityScore: readabilityScore,
            technicalDensity: technicalDensity,
            topKeywords: topKeywords
        )
    }
    private func calculateOverallReadability(avgSentenceLength: Double, lexicalDiversity: Double) -> Double {
        // Simple readability formula
        var score = 1.0
        // Penalize very long or very short sentences
        if avgSentenceLength < 10 {
            score *= 0.8
        } else if avgSentenceLength > 25 {
            score *= 0.7
        }
        // Reward good lexical diversity
        if lexicalDiversity > 0.6 {
            score *= 1.1
        } else if lexicalDiversity < 0.3 {
            score *= 0.8
        }
        return min(1.0, max(0.0, score))
    }
    private func identifyKeyTopics(from text: String) async -> [String] {
        // Extract named entities and keywords
        let entities = await nlpProcessor.extractNamedEntities(from: text)
        let keywords = await keywordExtractor.extractTopKeywords(from: text, count: 5)
        // Combine and deduplicate
        var topics = Set<String>()
        topics.formUnion(entities.map { $0.0 })
        topics.formUnion(keywords.map { $0.0 })
        return Array(topics).prefix(8).map { $0 }
    }
    private func calculateComplexityScore(metrics: DocumentMetrics) -> Double {
        var score = 0.0
        // Factor in sentence length
        if metrics.averageSentenceLength > 20 {
            score += 0.3
        } else if metrics.averageSentenceLength > 15 {
            score += 0.2
        }
        // Factor in technical density
        score += metrics.technicalDensity * 0.4
        // Factor in lexical diversity
        if metrics.lexicalDiversity > 0.6 {
            score += 0.2
        }
        // Inverse readability contributes to complexity
        score += (1.0 - metrics.readabilityScore) * 0.1
        return min(1.0, max(0.0, score))
    }
}
// MARK: - Supporting Components
actor NLPProcessor {
    private let tagger = NLTagger(tagSchemes: [.nameType, .lexicalClass, .lemma])
    func extractNamedEntities(from text: String) async -> [(String, NLTag)] {
        var entities: [(String, NLTag)] = []
        tagger.string = text
        let options: NLTagger.Options = [.omitWhitespace, .omitPunctuation, .joinNames]
        let range = text.startIndex..<text.endIndex
        tagger.enumerateTags(in: range, unit: .word, scheme: .nameType, options: options) { tag, tokenRange in
            if let tag = tag,
               tag == .personalName || tag == .placeName || tag == .organizationName {
                let entity = String(text[tokenRange])
                entities.append((entity, tag))
            }
            return true
        }
        return entities
    }
}
actor NLSentimentAnalyzer {
    private let tagger = NLTagger(tagSchemes: [.sentimentScore])
    func analyzeSentiment(for text: String) async -> Double {
        tagger.string = text
        let (sentimentTag, _) = tagger.tag(at: text.startIndex, unit: .paragraph, scheme: .sentimentScore)
        guard let tag = sentimentTag,
              let sentimentScore = Double(tag.rawValue) else {
            return 0.0 // Neutral sentiment
        }
        // NLTagger returns sentiment scores in range [-1, 1]
        // -1 = most negative, 0 = neutral, 1 = most positive
        return sentimentScore
    }
}
actor KeywordExtractor {
    func extractTopKeywords(from text: String, count: Int) async -> [(String, Int)] {
        let words = text.components(separatedBy: .whitespacesAndNewlines)
            .map { $0.lowercased().trimmingCharacters(in: .punctuationCharacters) }
            .filter { $0.count > 3 } // Filter out short words
        // Count word frequencies
        var wordFrequencies: [String: Int] = [:]
        for word in words {
            wordFrequencies[word, default: 0] += 1
        }
        // Filter out common words (simplified stopword list)
        let stopwords = Set(["the", "and", "that", "this", "with", "from", "have", "been", "were", "they", "their", "what", "when", "where", "which", "while", "would", "could", "should", "about", "after", "before", "because", "between", "during", "through", "under", "over"])
        let filteredWords = wordFrequencies.filter { !stopwords.contains($0.key) }
        // Sort by frequency and return top N
        return Array(filteredWords.sorted { $0.value > $1.value }.prefix(count))
    }
}
struct ImportanceCalculator {
    func calculate(
        features: AIHighlightEngine.TextFeatures,
        mode: AIHighlightEngine.AnalysisMode,
        sentenceIndex: Int,
        totalSentences: Int
    ) -> Double {
        var score = 0.0
        // Position importance (beginning and end are more important)
        if features.sentencePosition < 0.2 {
            score += 0.3
        } else if features.sentencePosition > 0.8 {
            score += 0.25
        }
        // First and last sentences of paragraphs
        if sentenceIndex == 0 || sentenceIndex == totalSentences - 1 {
            score += 0.2
        }
        // Feature-based scoring
        if features.quotationPresent {
            score += 0.15
        }
        if features.statisticPresent {
            score += 0.25
        }
        if features.namedEntityCount > 0 {
            score += min(0.2, Double(features.namedEntityCount) * 0.05)
        }
        if features.transitionWordScore > 0 {
            score += 0.2
        }
        // Keyword density contribution
        score += features.keywordDensity * 0.3
        // Emphasis contribution
        score += features.emphasisScore * 0.15
        // Technical term contribution
        if features.technicalTermCount > 0 {
            score += min(0.15, Double(features.technicalTermCount) * 0.05)
        }
        // Readability bonus
        score += features.readabilityScore * 0.1
        // Uniqueness bonus
        if features.uniqueWordRatio > 0.7 {
            score += 0.1
        }
        // Normalize score
        return min(1.0, max(0.0, score))
    }
}
</file>

<file path="Sources/Highlighter/Services/BookmarkService.swift">
import Foundation
import NDKSwift
@MainActor
class BookmarkService: ObservableObject {
    @Published private(set) var bookmarkedArticles: [String: Article] = [:]
    @Published private(set) var bookmarkedHighlights: [String: HighlightEvent] = [:]
    @Published private(set) var isLoading = false
    private var ndk: NDK?
    private var signer: NDKSigner?
    private var currentUserPubkey: String?
    private var loadingTask: Task<Void, Never>?
    private var cachedBookmarkIds: BookmarkIds?
    private var bookmarkEventIds: [String: String] = [:] // Maps content ID to bookmark event ID
    // MARK: - Configuration
    func configure(with ndk: NDK, signer: NDKSigner?) {
        self.ndk = ndk
        self.signer = signer
        Task {
            if let signer = signer {
                currentUserPubkey = try? await signer.pubkey
                await loadBookmarks()
            }
        }
    }
    // MARK: - Article Bookmarks
    func isArticleBookmarked(_ articleId: String) -> Bool {
        bookmarkedArticles[articleId] != nil
    }
    func toggleArticleBookmark(_ article: Article) async throws {
        guard let ndk = ndk, let _ = signer else {
            throw BookmarkError.notConfigured
        }
        if isArticleBookmarked(article.id) {
            // Remove bookmark
            await removeArticleBookmark(article.id)
            // Publish deletion event (NIP-09)
            if let existingEventId = findBookmarkEventId(for: article.id) {
                try await publishDeletionEvent(for: existingEventId)
            }
        } else {
            // Add bookmark
            await addArticleBookmark(article)
            // Publish bookmark event (kind 30001)
            try await publishArticleBookmark(article)
        }
    }
    private func addArticleBookmark(_ article: Article) async {
        await MainActor.run {
            bookmarkedArticles[article.id] = article
        }
        saveToLocalStorage()
    }
    private func removeArticleBookmark(_ articleId: String) async {
        await MainActor.run {
            bookmarkedArticles.removeValue(forKey: articleId)
        }
        saveToLocalStorage()
    }
    // MARK: - Highlight Bookmarks
    func isHighlightBookmarked(_ highlightId: String) -> Bool {
        bookmarkedHighlights[highlightId] != nil
    }
    func toggleHighlightBookmark(_ highlight: HighlightEvent) async throws {
        guard let ndk = ndk, let _ = signer else {
            throw BookmarkError.notConfigured
        }
        if isHighlightBookmarked(highlight.id) {
            await removeHighlightBookmark(highlight.id)
            if let existingEventId = findHighlightBookmarkEventId(for: highlight.id) {
                try await publishDeletionEvent(for: existingEventId)
            }
        } else {
            await addHighlightBookmark(highlight)
            try await publishHighlightBookmark(highlight)
        }
    }
    private func addHighlightBookmark(_ highlight: HighlightEvent) async {
        await MainActor.run {
            bookmarkedHighlights[highlight.id] = highlight
        }
        saveToLocalStorage()
    }
    private func removeHighlightBookmark(_ highlightId: String) async {
        await MainActor.run {
            bookmarkedHighlights.removeValue(forKey: highlightId)
        }
        saveToLocalStorage()
    }
    // MARK: - Nostr Publishing
    private func publishArticleBookmark(_ article: Article) async throws {
        guard let ndk = ndk, let _ = signer else { return }
        // Create bookmark list event (NIP-51, kind 30001)
        let tags: [[String]] = [
            ["d", "articles"], // Replaceable event identifier
            ["name", "Bookmarked Articles"],
            ["a", "\(article.identifier)::\(article.author)", "wss://relay.damus.io", article.title]
        ]
        let contentDict: [String: Any] = [
            "bookmarked_at": ISO8601DateFormatter().string(from: Date()),
            "note": "Saved for later reading"
        ]
        let content = (try? JSONSerialization.data(withJSONObject: contentDict)).flatMap { String(data: $0, encoding: .utf8) } ?? ""
        let event = try await NDKEventBuilder(ndk: ndk)
            .kind(30001) // Bookmark list
            .content(content)
            .tags(tags)
            .build(signer: signer)
        _ = try await ndk.publish(event)
        // Track the bookmark event ID
        bookmarkEventIds[article.id] = event.id
    }
    private func publishHighlightBookmark(_ highlight: HighlightEvent) async throws {
        guard let ndk = ndk, let _ = signer else { return }
        let tags: [[String]] = [
            ["d", "highlights"],
            ["name", "Bookmarked Highlights"],
            ["e", highlight.id, "wss://relay.damus.io", "highlight"]
        ]
        let contentDict: [String: Any] = [
            "bookmarked_at": ISO8601DateFormatter().string(from: Date()),
            "highlight_content": highlight.content
        ]
        let content = (try? JSONSerialization.data(withJSONObject: contentDict)).flatMap { String(data: $0, encoding: .utf8) } ?? ""
        let event = try await NDKEventBuilder(ndk: ndk)
            .kind(30001)
            .content(content)
            .tags(tags)
            .build(signer: signer)
        _ = try await ndk.publish(event)
        // Track the bookmark event ID
        bookmarkEventIds[highlight.id] = event.id
    }
    private func publishDeletionEvent(for eventId: String) async throws {
        guard let ndk = ndk, let _ = signer else { return }
        let event = try await NDKEventBuilder(ndk: ndk)
            .kind(5) // Deletion
            .content("Removed bookmark")
            .tags([["e", eventId]])
            .build(signer: signer)
        _ = try await ndk.publish(event)
    }
    // MARK: - Loading
    private func loadBookmarks() async {
        guard let ndk = ndk, let currentUserPubkey = currentUserPubkey else { return }
        isLoading = true
        defer { isLoading = false }
        // Load from local storage first
        loadFromLocalStorage()
        // Then sync with Nostr
        let filter = NDKFilter(
            authors: [currentUserPubkey],
            kinds: [30001],
            tags: ["d": ["articles", "highlights"]]
        )
        // Use outbox to get bookmark events
        let dataSource = await ndk.outbox.observe(
            filter: filter,
            maxAge: 300 // 5 minute cache
        )
        var events: [NDKEvent] = []
        for await event in dataSource.events {
            events.append(event)
        }
        await processBookmarkEvents(events)
    }
    private func processBookmarkEvents(_ events: [NDKEvent]) async {
        for event in events {
            guard let dTag = event.tags.first(where: { $0.count > 1 && $0[0] == "d" })?[1] else {
                continue
            }
            switch dTag {
            case "articles":
                await processArticleBookmarks(from: event)
            case "highlights":
                await processHighlightBookmarks(from: event)
            default:
                break
            }
        }
    }
    private func processArticleBookmarks(from event: NDKEvent) async {
        let articleTags = event.tags.filter { $0.first == "a" }
        for tag in articleTags {
            guard tag.count >= 4 else { continue }
            let articleData = tag[1].split(separator: ":").map(String.init)
            guard articleData.count >= 2 else {
                continue
            }
            let articleId = articleData[0]
            let author = articleData[1]
            let title = tag[3]
            // Create article from bookmark data
            let article = Article(
                id: articleId,
                identifier: articleId,
                title: title,
                summary: nil,
                content: "", // Will be loaded when opened
                author: author,
                publishedAt: Date(timeIntervalSince1970: TimeInterval(event.createdAt)),
                image: nil,
                hashtags: [],
                createdAt: event.createdAt
            )
            // Track the bookmark event ID for this article
            bookmarkEventIds[articleId] = event.id
            await addArticleBookmark(article)
        }
    }
    private func processHighlightBookmarks(from event: NDKEvent) async {
        // Process highlight bookmarks from event tags
        let highlightTags = event.tags.filter { $0.first == "e" }
        for tag in highlightTags where tag.count >= 2 {
            let highlightId = tag[1]
            // Track the bookmark event ID for this highlight
            bookmarkEventIds[highlightId] = event.id
            // Fetch the actual highlight event
            if let ndk = ndk {
                let filter = NDKFilter(ids: [highlightId])
                // Use observe to get the highlight event
                let highlightDataSource = await ndk.outbox.observe(
                    filter: filter,
                    maxAge: 300 // 5 minute cache
                )
                for await highlightEvent in highlightDataSource.events {
                    // Convert to HighlightEvent
                    let highlight = HighlightEvent(
                        id: highlightId,
                        event: highlightEvent,
                        content: highlightEvent.content,
                        author: highlightEvent.pubkey,
                        createdAt: Date(timeIntervalSince1970: TimeInterval(highlightEvent.createdAt)),
                        context: nil,
                        url: highlightEvent.tags.first(where: { $0.first == "r" })?.dropFirst().first,
                        referencedEvent: highlightEvent.tags.first(where: { $0.first == "e" })?.dropFirst().first,
                        attributedAuthors: highlightEvent.tags.filter { $0.first == "p" }.compactMap { $0.dropFirst().first },
                        comment: nil
                    )
                    await addHighlightBookmark(highlight)
                    break // Only need the first event
                }
            }
        }
    }
    // MARK: - Local Storage
    private func saveToLocalStorage() {
        // For now, we'll only save the IDs since Article and HighlightEvent contain NDKEvent which isn't Codable
        let bookmarkIds = BookmarkIds(
            articleIds: Array(bookmarkedArticles.keys),
            highlightIds: Array(bookmarkedHighlights.keys)
        )
        if let encoded = try? JSONEncoder().encode(bookmarkIds) {
            UserDefaults.standard.set(encoded, forKey: "highlighter.bookmarks.ids")
        }
    }
    private func loadFromLocalStorage() {
        // Don't clear bookmarks here - they will be populated from the network
        // The local storage is just for offline reference of bookmark IDs
        guard let data = UserDefaults.standard.data(forKey: "highlighter.bookmarks.ids"),
              let bookmarkIds = try? JSONDecoder().decode(BookmarkIds.self, from: data) else {
            return
        }
        // Store the IDs for reference while we fetch from network
        // The actual bookmark objects will be populated by loadBookmarks()
        self.cachedBookmarkIds = bookmarkIds
    }
    // MARK: - Helpers
    private func findBookmarkEventId(for articleId: String) -> String? {
        return bookmarkEventIds[articleId]
    }
    private func findHighlightBookmarkEventId(for highlightId: String) -> String? {
        return bookmarkEventIds[highlightId]
    }
}
// MARK: - Supporting Types
private struct BookmarkIds: Codable {
    let articleIds: [String]
    let highlightIds: [String]
}
// NOTE: BookmarkData is kept for future use when Article and HighlightEvent are made Codable
// private struct BookmarkData: Codable {
//     let articles: [Article]
//     let highlights: [HighlightEvent]
// }
enum BookmarkError: LocalizedError {
    case notConfigured
    case publishFailed
    var errorDescription: String? {
        switch self {
        case .notConfigured:
            return "Bookmark service not configured"
        case .publishFailed:
            return "Failed to publish bookmark"
        }
    }
}
</file>

<file path="Sources/Highlighter/Services/DataStreamManager.swift">
import Foundation
import NDKSwift
import Combine
/// Manages centralized data streaming for the entire app
/// Follows SRP by focusing solely on data stream coordination and management
@MainActor
class DataStreamManager: ObservableObject {
    // MARK: - Published State
    @Published private(set) var highlights: [HighlightEvent] = []
    @Published private(set) var curations: [ArticleCuration] = []
    @Published private(set) var followPacks: [FollowPack] = []
    @Published private(set) var articles: [Article] = []
    // MARK: - Private Properties
    private weak var ndk: NDK?
    private var streamingTasks: [Task<Void, Never>] = []
    private var dataSourceRefs: [NDKDataSource<NDKEvent>] = []
    // MARK: - Initialization
    init() {}
    // MARK: - Configuration
    func configure(with ndk: NDK) {
        self.ndk = ndk
    }
    // MARK: - Stream Management
    /// Start all data streams with optimized concurrent execution
    func startAllStreams() async {
        guard let ndk = ndk else { return }
        // Stop existing streams first
        stopAllStreams()
        // Start all streams concurrently for better performance
        await withTaskGroup(of: Void.self) { group in
            group.addTask { await self.startHighlightStream(ndk: ndk) }
            group.addTask { await self.startCurationStream(ndk: ndk) }
            group.addTask { await self.startFollowPackStream(ndk: ndk) }
            group.addTask { await self.startArticleStream(ndk: ndk) }
        }
    }
    /// Stop all active streams and clean up resources
    func stopAllStreams() {
        for task in streamingTasks {
            task.cancel()
        }
        streamingTasks.removeAll()
        dataSourceRefs.removeAll()
    }
    /// Clear all cached data and restart streams
    func refresh() async {
        highlights.removeAll()
        curations.removeAll()
        followPacks.removeAll()
        articles.removeAll()
        await startAllStreams()
    }
    // MARK: - Individual Stream Methods
    private func startHighlightStream(ndk: NDK) async {
        let highlightFilter = NDKFilter(kinds: [9802], limit: 100)
        let dataSource = await ndk.outbox.observe(
            filter: highlightFilter,
            maxAge: CachePolicies.shortTerm,
            cachePolicy: .cacheWithNetwork
        )
        dataSourceRefs.append(dataSource)
        let task = Task {
            for await event in dataSource.events {
                if let highlight = try? HighlightEvent(from: event) {
                    await addHighlight(highlight)
                }
            }
        }
        streamingTasks.append(task)
    }
    private func startCurationStream(ndk: NDK) async {
        let curationFilter = NDKFilter(kinds: [30004], limit: 50)
        let dataSource = await ndk.outbox.observe(
            filter: curationFilter,
            maxAge: CachePolicies.mediumTerm,
            cachePolicy: .cacheWithNetwork
        )
        dataSourceRefs.append(dataSource)
        let task = Task {
            for await event in dataSource.events {
                if let curation = try? ArticleCuration(from: event) {
                    await addCuration(curation)
                }
            }
        }
        streamingTasks.append(task)
    }
    private func startFollowPackStream(ndk: NDK) async {
        let followPackFilter = NDKFilter(kinds: [39089], limit: 20)
        let dataSource = await ndk.outbox.observe(
            filter: followPackFilter,
            maxAge: CachePolicies.mediumTerm,
            cachePolicy: .cacheWithNetwork
        )
        dataSourceRefs.append(dataSource)
        let task = Task {
            for await event in dataSource.events {
                if let pack = try? FollowPack(from: event) {
                    await addFollowPack(pack)
                }
            }
        }
        streamingTasks.append(task)
    }
    private func startArticleStream(ndk: NDK) async {
        let articleFilter = NDKFilter(kinds: [30023], limit: 50)
        let dataSource = await ndk.outbox.observe(
            filter: articleFilter,
            maxAge: CachePolicies.mediumTerm,
            cachePolicy: .cacheWithNetwork
        )
        dataSourceRefs.append(dataSource)
        let task = Task {
            for await event in dataSource.events {
                if let article = try? Article(from: event) {
                    await addArticle(article)
                }
            }
        }
        streamingTasks.append(task)
    }
    // MARK: - Data Management
    @MainActor
    private func addHighlight(_ highlight: HighlightEvent) {
        if !highlights.contains(where: { $0.id == highlight.id }) {
            highlights.append(highlight)
            highlights.sort { $0.createdAt > $1.createdAt }
        }
    }
    @MainActor
    private func addCuration(_ curation: ArticleCuration) {
        if !curations.contains(where: { $0.id == curation.id }) {
            curations.append(curation)
            curations.sort { $0.updatedAt > $1.updatedAt }
        }
    }
    @MainActor
    private func addFollowPack(_ pack: FollowPack) {
        if !followPacks.contains(where: { $0.id == pack.id }) {
            followPacks.append(pack)
        }
    }
    @MainActor
    private func addArticle(_ article: Article) {
        if !articles.contains(where: { $0.id == article.id }) {
            articles.append(article)
            articles.sort { $0.createdAt > $1.createdAt }
        }
    }
    // MARK: - Cleanup
    deinit {
        Task { @MainActor in
            stopAllStreams()
        }
    }
}
</file>

<file path="Sources/Highlighter/Services/EngagementService.swift">
import Foundation
import NDKSwift
/// Service for tracking real engagement metrics from Nostr events
@MainActor
class EngagementService: ObservableObject {
    private weak var ndk: NDK?
    private var signer: NDKSigner?
    // MARK: - Engagement Models
    struct EngagementMetrics {
        var likes: Int = 0
        var reposts: Int = 0
        var zaps: Int = 0
        var zapAmount: Int = 0
        var comments: Int = 0
        var totalEngagement: Int {
            likes + reposts + comments + (zaps > 0 ? 1 : 0)
        }
    }
    // MARK: - Configuration
    func configure(with ndk: NDK, signer: NDKSigner?) {
        self.ndk = ndk
        self.signer = signer
    }
    // MARK: - Fetch Engagement
    /// Fetch engagement metrics for a specific event
    func fetchEngagement(for eventId: String) async -> EngagementMetrics {
        guard let ndk = ndk else { return EngagementMetrics() }
        var metrics = EngagementMetrics()
        // Fetch reactions (kind 7)
        let reactionFilter = NDKFilter(
            kinds: [7],
            tags: ["e": Set([eventId])]
        )
        // Fetch reposts (kind 6)
        let repostFilter = NDKFilter(
            kinds: [6],
            tags: ["e": Set([eventId])]
        )
        // Fetch zaps (kind 9735)
        let zapFilter = NDKFilter(
            kinds: [9735],
            tags: ["e": Set([eventId])]
        )
        // Fetch replies (kind 1 with 'e' tag referencing this event)
        let replyFilter = NDKFilter(
            kinds: [1],
            tags: ["e": Set([eventId])]
        )
        // Fetch all engagement data in parallel
        await withTaskGroup(of: Void.self) { group in
            // Fetch reactions
            group.addTask {
                let reactionSource = await ndk.outbox.observe(
                    filter: reactionFilter,
                    maxAge: CachePolicies.shortTerm,
                    cachePolicy: .cacheOnly
                )
                for await event in reactionSource.events {
                    await MainActor.run {
                        // Only count positive reactions ('+' or likes)
                        if event.content == "+" || event.content == "❤️" || event.content == "👍" {
                            metrics.likes += 1
                        }
                    }
                }
            }
            // Fetch reposts
            group.addTask {
                let repostSource = await ndk.outbox.observe(
                    filter: repostFilter,
                    maxAge: CachePolicies.shortTerm,
                    cachePolicy: .cacheOnly
                )
                for await _ in repostSource.events {
                    await MainActor.run {
                        metrics.reposts += 1
                    }
                }
            }
            // Fetch zaps
            group.addTask {
                let zapSource = await ndk.outbox.observe(
                    filter: zapFilter,
                    maxAge: CachePolicies.shortTerm,
                    cachePolicy: .cacheOnly
                )
                for await event in zapSource.events {
                    await MainActor.run {
                        metrics.zaps += 1
                        // Parse zap amount from bolt11 invoice
                        if let bolt11Tag = event.tags.first(where: { $0.count >= 2 && $0[0] == "bolt11" }),
                           let invoice = bolt11Tag[safe: 1] {
                            let amount = parseBolt11Amount(invoice) ?? 1000
                            metrics.zapAmount += amount
                        } else {
                            // Fallback to 1000 sats if no bolt11 tag
                            metrics.zapAmount += 1000
                        }
                    }
                }
            }
            // Fetch comments/replies
            group.addTask {
                let replySource = await ndk.outbox.observe(
                    filter: replyFilter,
                    maxAge: CachePolicies.shortTerm,
                    cachePolicy: .cacheOnly
                )
                for await event in replySource.events {
                    // Check if this is a root reply (not a reply to a reply)
                    let eTags = event.tags.filter { $0.first == "e" }
                    if eTags.count == 1 || (eTags.count > 1 && eTags.first?[safe: 1] == eventId) {
                        await MainActor.run {
                            metrics.comments += 1
                        }
                    }
                }
            }
        }
        return metrics
    }
    // MARK: - Batch Fetch
    /// Fetch engagement metrics for multiple events efficiently
    func fetchEngagementBatch(for eventIds: [String]) async -> [String: EngagementMetrics] {
        guard let ndk = ndk, !eventIds.isEmpty else { return [:] }
        var metricsMap: [String: EngagementMetrics] = [:]
        // Initialize metrics for all events
        for eventId in eventIds {
            metricsMap[eventId] = EngagementMetrics()
        }
        // Create filters for batch fetching
        let eventIdSet = Set(eventIds)
        let reactionFilter = NDKFilter(
            kinds: [7],
            tags: ["e": eventIdSet]
        )
        let repostFilter = NDKFilter(
            kinds: [6],
            tags: ["e": eventIdSet]
        )
        let zapFilter = NDKFilter(
            kinds: [9735],
            tags: ["e": eventIdSet]
        )
        let replyFilter = NDKFilter(
            kinds: [1],
            tags: ["e": eventIdSet]
        )
        // Fetch all engagement data
        await withTaskGroup(of: Void.self) { group in
            // Reactions
            group.addTask {
                let source = await ndk.outbox.observe(
                    filter: reactionFilter,
                    maxAge: CachePolicies.shortTerm,
                    cachePolicy: .cacheOnly
                )
                for await event in source.events {
                    if let eTag = event.tags.first(where: { $0.first == "e" })?[safe: 1],
                       eventIdSet.contains(eTag),
                       event.content == "+" || event.content == "❤️" || event.content == "👍" {
                        await MainActor.run {
                            metricsMap[eTag]?.likes += 1
                        }
                    }
                }
            }
            // Reposts
            group.addTask {
                let source = await ndk.outbox.observe(
                    filter: repostFilter,
                    maxAge: CachePolicies.shortTerm,
                    cachePolicy: .cacheOnly
                )
                for await event in source.events {
                    if let eTag = event.tags.first(where: { $0.first == "e" })?[safe: 1],
                       eventIdSet.contains(eTag) {
                        await MainActor.run {
                            metricsMap[eTag]?.reposts += 1
                        }
                    }
                }
            }
            // Zaps
            group.addTask {
                let source = await ndk.outbox.observe(
                    filter: zapFilter,
                    maxAge: CachePolicies.shortTerm,
                    cachePolicy: .cacheOnly
                )
                for await event in source.events {
                    if let eTag = event.tags.first(where: { $0.first == "e" })?[safe: 1],
                       eventIdSet.contains(eTag) {
                        await MainActor.run {
                            metricsMap[eTag]?.zaps += 1
                            // Parse zap amount from bolt11 invoice
                            if let bolt11Tag = event.tags.first(where: { $0.count >= 2 && $0[0] == "bolt11" }),
                               let invoice = bolt11Tag[safe: 1] {
                                let amount = parseBolt11Amount(invoice) ?? 1000
                                metricsMap[eTag]?.zapAmount += amount
                            } else {
                                // Fallback to 1000 sats if no bolt11 tag
                                metricsMap[eTag]?.zapAmount += 1000
                            }
                        }
                    }
                }
            }
            // Comments
            group.addTask {
                let source = await ndk.outbox.observe(
                    filter: replyFilter,
                    maxAge: CachePolicies.shortTerm,
                    cachePolicy: .cacheOnly
                )
                for await event in source.events {
                    let eTags = event.tags.filter { $0.first == "e" }
                    if let firstETag = eTags.first?[safe: 1],
                       eventIdSet.contains(firstETag),
                       eTags.count == 1 || eTags.first?[safe: 1] == firstETag {
                        await MainActor.run {
                            metricsMap[firstETag]?.comments += 1
                        }
                    }
                }
            }
        }
        return metricsMap
    }
    // MARK: - User Actions
    /// React to an event (like)
    func react(to eventId: String, reaction: String = "+") async throws {
        guard let ndk = ndk, let signer = signer else {
            throw EngagementError.notConfigured
        }
        let event = try await NDKEventBuilder(ndk: ndk)
            .kind(7)
            .content(reaction)
            .tags([["e", eventId]])
            .build(signer: signer)
        _ = try await ndk.publish(event)
    }
    /// Repost an event
    func repost(eventId: String, pubkey: String) async throws {
        guard let ndk = ndk, let signer = signer else {
            throw EngagementError.notConfigured
        }
        let event = try await NDKEventBuilder(ndk: ndk)
            .kind(6)
            .content("")
            .tags([["e", eventId], ["p", pubkey]])
            .build(signer: signer)
        _ = try await ndk.publish(event)
    }
    /// Comment on an event
    func comment(on eventId: String, content: String, author: String? = nil) async throws {
        guard let ndk = ndk, let signer = signer else {
            throw EngagementError.notConfigured
        }
        var tags = [["e", eventId, "", "root"]]
        if let author = author {
            tags.append(["p", author])
        }
        let event = try await NDKEventBuilder(ndk: ndk)
            .kind(1)
            .content(content)
            .tags(tags)
            .build(signer: signer)
        _ = try await ndk.publish(event)
    }
}
// MARK: - Errors
enum EngagementError: LocalizedError {
    case notConfigured
    var errorDescription: String? {
        switch self {
        case .notConfigured:
            return "Engagement service not properly configured"
        }
    }
}
// MARK: - Bolt11 Parsing
private func parseBolt11Amount(_ invoice: String) -> Int? {
    // Basic bolt11 parsing - extract amount in satoshis
    // Bolt11 format: lnbc<amount><multiplier>...
    // where multiplier can be m (milli), u (micro), n (nano), p (pico)
    let invoice = invoice.lowercased()
    guard invoice.hasPrefix("lnbc") || invoice.hasPrefix("lntb") || invoice.hasPrefix("lnbcrt") else {
        return nil
    }
    // Remove the prefix
    let withoutPrefix = invoice.dropFirst(4)
    // Find where the amount ends (first non-digit/multiplier character)
    var amountString = ""
    var multiplierChar: Character?
    for char in withoutPrefix {
        if char.isNumber {
            amountString.append(char)
        } else if ["m", "u", "n", "p"].contains(char) && multiplierChar == nil {
            multiplierChar = char
        } else {
            break
        }
    }
    guard let amount = Int(amountString), amount > 0 else {
        return nil
    }
    // Convert to satoshis based on multiplier
    switch multiplierChar {
    case "m": // milli-bitcoin (0.001 BTC)
        return amount * 100_000
    case "u": // micro-bitcoin (0.000001 BTC)
        return amount * 100
    case "n": // nano-bitcoin (0.000000001 BTC)
        return amount / 10
    case "p": // pico-bitcoin (0.000000000001 BTC)
        return amount / 10_000
    default: // No multiplier means BTC
        return amount * 100_000_000
    }
}
</file>

<file path="Sources/Highlighter/Services/LightningService.swift">
import Foundation
import NDKSwift
import Combine
import SwiftUI
/// Lightning service for managing payments with smart splits
@MainActor
class LightningService: ObservableObject {
    // MARK: - Published Properties
    @Published var isConnected = false
    @Published var balance: Int = 0
    @Published var recentZaps: [ZapTransaction] = []
    @Published var pendingZaps: [PendingZap] = []
    @Published var connectionError: String?
    @Published var walletInfo: WalletInfo?
    // MARK: - Properties
    private var ndk: NDK?
    private var signer: NDKSigner?
    private var nwc: NostrWalletConnect?
    private var cancellables = Set<AnyCancellable>()
    // Smart split configurations
    struct SplitConfiguration {
        var author: Double = 0.5
        var highlighter: Double = 0.3
        var curator: Double = 0.15
        var platform: Double = 0.05
        var authorPercentage: Double {
            get { author }
            set { author = newValue }
        }
        var highlighterPercentage: Double {
            get { highlighter }
            set { highlighter = newValue }
        }
        var curatorPercentage: Double {
            get { curator }
            set { curator = newValue }
        }
        var isValid: Bool {
            abs((author + highlighter + curator + platform) - 1.0) < 0.001
        }
        static let highlight = SplitConfiguration(
            author: 0.5,
            highlighter: 0.3,
            curator: 0.15,
            platform: 0.05
        )
    }
    @Published var splitConfig = SplitConfiguration()
    // MARK: - Initialization
    init() {
        loadSavedConfiguration()
    }
    // MARK: - Public Methods
    /// Connect to Lightning wallet via Nostr Wallet Connect
    func connectWallet(connectionString: String) async throws {
        guard let ndk = ndk else { throw LightningError.ndkNotInitialized }
        do {
            // Parse NWC connection string
            guard let url = URL(string: connectionString),
                  url.scheme == "nostr+walletconnect" else {
                throw LightningError.invalidConnectionString
            }
            // Initialize NWC with parsed parameters
            let nwc = try NostrWalletConnect(from: connectionString, ndk: ndk)
            self.nwc = nwc
            // Request wallet info
            let info = try await nwc.getInfo()
            await MainActor.run {
                self.walletInfo = WalletInfo(
                    alias: info.alias,
                    color: "#FF9500", // Default color for now
                    pubkey: info.pubkey,
                    network: info.network,
                    blockHeight: info.blockHeight,
                    methods: info.methods
                )
                self.isConnected = true
                self.connectionError = nil
            }
            // Start listening for balance updates
            startBalanceUpdates()
            // Save connection for future use
            saveConnectionString(connectionString)
            HapticManager.shared.notification(.success)
        } catch {
            await MainActor.run {
                self.connectionError = error.localizedDescription
                self.isConnected = false
            }
            HapticManager.shared.notification(.error)
            throw error
        }
    }
    /// Disconnect from Lightning wallet
    func disconnectWallet() {
        nwc = nil
        isConnected = false
        balance = 0
        walletInfo = nil
        clearConnectionString()
        HapticManager.shared.impact(.medium)
    }
    /// Send a zap with smart splits
    func sendSmartZap(
        amount: Int,
        to highlight: HighlightEvent,
        article: Article? = nil,
        comment: String? = nil
    ) async throws -> ZapTransaction {
        guard let nwc = nwc else { throw LightningError.walletNotConnected }
        guard ndk != nil else { throw LightningError.ndkNotInitialized }
        // Create pending zap for UI feedback
        let pendingZap = PendingZap(
            id: UUID(),
            amount: amount,
            recipientPubkey: highlight.pubkey,
            status: .calculating
        )
        await MainActor.run {
            pendingZaps.append(pendingZap)
        }
        do {
            // Calculate splits
            let splits = calculateSplits(
                totalAmount: amount,
                highlighterPubkey: highlight.pubkey,
                authorPubkey: highlight.author,
                curatorPubkey: article?.author
            )
            // Update pending zap status
            updatePendingZapStatus(pendingZap.id, status: .sending)
            // Create zap transactions for each recipient
            var transactions: [SubTransaction] = []
            for split in splits {
                if split.amount > 0 {
                    // Create zap request event
                    let zapRequest = try await createZapRequest(
                        amount: split.amount,
                        recipientPubkey: split.recipientPubkey,
                        comment: split.isOriginal ? comment : "Split payment from highlight zap",
                        highlightReference: highlight.id
                    )
                    // Send payment
                    let invoice = try await getInvoiceForZap(
                        zapRequest: zapRequest,
                        recipientPubkey: split.recipientPubkey
                    )
                    let paymentHash = try await nwc.payInvoice(invoice)
                    transactions.append(SubTransaction(
                        recipientPubkey: split.recipientPubkey,
                        amount: split.amount,
                        role: split.role,
                        paymentHash: paymentHash,
                        timestamp: Date()
                    ))
                }
            }
            // Create main transaction record
            let transaction = ZapTransaction(
                id: UUID(),
                totalAmount: amount,
                splits: transactions,
                highlightId: highlight.id,
                comment: comment,
                timestamp: Date()
            )
            // Update UI
            await MainActor.run {
                recentZaps.insert(transaction, at: 0)
                pendingZaps.removeAll { $0.id == pendingZap.id }
                // Trigger success haptics
                HapticManager.shared.notification(.success)
            }
            // Publish zap receipt events
            for (split, subTx) in zip(splits, transactions) {
                try await publishZapReceipt(
                    transaction: subTx,
                    originalEvent: highlight.id,
                    split: split
                )
            }
            return transaction
        } catch {
            updatePendingZapStatus(pendingZap.id, status: .failed(error.localizedDescription))
            // Remove failed zap after delay
            DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
                self.pendingZaps.removeAll { $0.id == pendingZap.id }
            }
            HapticManager.shared.notification(.error)
            throw error
        }
    }
    /// Send a simple zap without splits
    func sendSimpleZap(
        amount: Int,
        to pubkey: String,
        comment: String? = nil
    ) async throws {
        guard let nwc = nwc else { throw LightningError.walletNotConnected }
        guard ndk != nil else { throw LightningError.ndkNotInitialized }
        let zapRequest = try await createZapRequest(
            amount: amount,
            recipientPubkey: pubkey,
            comment: comment,
            highlightReference: nil
        )
        let invoice = try await getInvoiceForZap(
            zapRequest: zapRequest,
            recipientPubkey: pubkey
        )
        _ = try await nwc.payInvoice(invoice)
        HapticManager.shared.notification(.success)
    }
    // MARK: - Configuration
    func updateSplitConfiguration(_ config: SplitConfiguration) {
        guard config.isValid else { return }
        splitConfig = config
        saveSplitConfiguration()
        HapticManager.shared.impact(.light)
    }
    func setNDK(_ ndk: NDK, signer: NDKSigner?) {
        self.ndk = ndk
        self.signer = signer
        // Try to reconnect if we have a saved connection
        if let savedConnection = getSavedConnectionString() {
            Task {
                try? await connectWallet(connectionString: savedConnection)
            }
        }
    }
    // MARK: - Private Methods
    private func calculateSplits(
        totalAmount: Int,
        highlighterPubkey: String,
        authorPubkey: String?,
        curatorPubkey: String?
    ) -> [PaymentSplit] {
        var splits: [PaymentSplit] = []
        // Always pay the highlighter
        let highlighterAmount = Int(Double(totalAmount) * splitConfig.highlighterPercentage)
        splits.append(PaymentSplit(
            recipientPubkey: highlighterPubkey,
            amount: highlighterAmount,
            role: .highlighter,
            isOriginal: true
        ))
        // Pay author if different from highlighter
        if let authorPubkey = authorPubkey, authorPubkey != highlighterPubkey {
            let authorAmount = Int(Double(totalAmount) * splitConfig.authorPercentage)
            splits.append(PaymentSplit(
                recipientPubkey: authorPubkey,
                amount: authorAmount,
                role: .author,
                isOriginal: false
            ))
        } else {
            // If highlighter is the author, give them the author portion too
            let extraAmount = Int(Double(totalAmount) * splitConfig.authorPercentage)
            if var highlighterSplit = splits.first {
                highlighterSplit.amount += extraAmount
                splits[0] = highlighterSplit
            }
        }
        // Pay curator if exists and different
        if let curatorPubkey = curatorPubkey,
           curatorPubkey != highlighterPubkey && curatorPubkey != authorPubkey {
            let curatorAmount = Int(Double(totalAmount) * splitConfig.curatorPercentage)
            splits.append(PaymentSplit(
                recipientPubkey: curatorPubkey,
                amount: curatorAmount,
                role: .curator,
                isOriginal: false
            ))
        } else {
            // Distribute curator portion to highlighter
            let extraAmount = Int(Double(totalAmount) * splitConfig.curatorPercentage)
            if var highlighterSplit = splits.first {
                highlighterSplit.amount += extraAmount
                splits[0] = highlighterSplit
            }
        }
        return splits
    }
    private func createZapRequest(
        amount: Int,
        recipientPubkey: String,
        comment: String?,
        highlightReference: String?
    ) async throws -> NDKEvent {
        guard let ndk = ndk else {
            throw LightningError.ndkNotInitialized
        }
        guard let signer = signer else {
            throw LightningError.signerNotAvailable
        }
        var tags: [[String]] = [
            ["amount", String(amount * 1000)], // Convert sats to millisats
            ["p", recipientPubkey]
        ]
        if let highlight = highlightReference {
            tags.append(["e", highlight])
        }
        let content = comment ?? ""
        return try await NDKEventBuilder(ndk: ndk)
            .kind(9734) // Zap request
            .content(content)
            .tags(tags)
            .build(signer: signer)
    }
    private func getInvoiceForZap(zapRequest: NDKEvent, recipientPubkey: String) async throws -> String {
        guard let ndk = ndk else { throw LightningError.ndkNotInitialized }
        // Get user's lightning address
        let profileDataSource = await ndk.outbox.observe(
            filter: NDKFilter(
                authors: [recipientPubkey],
                kinds: [0]
            ),
            maxAge: 3600,
            cachePolicy: .cacheWithNetwork
        )
        var lightningAddress: String?
        for await event in profileDataSource.events {
            if let profile = JSONCoding.safeDecode(NDKUserProfile.self, from: event.content) {
                lightningAddress = profile.lud16 ?? profile.lud06
                break
            }
        }
        guard let address = lightningAddress else {
            throw LightningError.noLightningAddress
        }
        // Get amount from zap request
        var amount = 1000 // Default 1000 sats
        for tag in zapRequest.tags {
            if tag.count >= 2 && tag[0] == "amount" {
                amount = (Int(tag[1]) ?? 1000) / 1000 // Convert millisats to sats
                break
            }
        }
        // Serialize zap request for LNURL
        let encoder = JSONEncoder()
        encoder.outputFormatting = .sortedKeys
        let zapRequestData = try encoder.encode(zapRequest)
        let zapRequestString = String(data: zapRequestData, encoding: .utf8) ?? ""
        // Request invoice from LNURL service
        return try await LNURLService.getInvoice(
            for: address,
            amount: amount,
            comment: zapRequest.content.isEmpty ? nil : zapRequest.content,
            zapRequest: zapRequestString
        )
    }
    private func publishZapReceipt(
        transaction: SubTransaction,
        originalEvent: String,
        split: PaymentSplit
    ) async throws {
        guard let ndk = ndk,
              let signer = signer else { return }
        let tags: [[String]] = [
            ["p", transaction.recipientPubkey],
            ["e", originalEvent],
            ["amount", String(transaction.amount * 1000)],
            ["split-role", split.role.rawValue]
        ]
        let event = try await NDKEventBuilder(ndk: ndk)
            .kind(9735) // Zap receipt
            .tags(tags)
            .build(signer: signer)
        _ = try await ndk.publish(event)
    }
    private func startBalanceUpdates() {
        // Poll balance every 30 seconds
        Timer.publish(every: 30, on: .main, in: .common)
            .autoconnect()
            .sink { [weak self] _ in
                Task {
                    await self?.updateBalance()
                }
            }
            .store(in: &cancellables)
        // Initial balance fetch
        Task {
            await updateBalance()
        }
    }
    private func updateBalance() async {
        guard let nwc = nwc else { return }
        do {
            let balanceInfo = try await nwc.getBalance()
            await MainActor.run {
                self.balance = balanceInfo / 1000 // Convert millisats to sats
            }
        } catch {
            // Failed to update balance
        }
    }
    private func updatePendingZapStatus(_ id: UUID, status: PendingZap.Status) {
        DispatchQueue.main.async {
            if let index = self.pendingZaps.firstIndex(where: { $0.id == id }) {
                self.pendingZaps[index].status = status
            }
        }
    }
    // MARK: - Persistence
    private func saveConnectionString(_ connection: String) {
        do {
            try KeychainManager.shared.save(connection, for: KeychainManager.Keys.nwcConnection)
        } catch {
            // Failed to save NWC connection to keychain
        }
    }
    private func getSavedConnectionString() -> String? {
        do {
            return try KeychainManager.shared.retrieve(key: KeychainManager.Keys.nwcConnection)
        } catch {
            // If error is not .noData, log it
            if case KeychainManager.KeychainError.noData = error {
                // Expected when no connection saved
            } else {
                // Failed to retrieve NWC connection from keychain
            }
            return nil
        }
    }
    private func clearConnectionString() {
        do {
            try KeychainManager.shared.delete(key: KeychainManager.Keys.nwcConnection)
        } catch {
            // Failed to clear NWC connection from keychain
        }
    }
    private func saveSplitConfiguration() {
        UserDefaults.standard.set(splitConfig.authorPercentage, forKey: "highlighter.split.author")
        UserDefaults.standard.set(splitConfig.highlighterPercentage, forKey: "highlighter.split.highlighter")
        UserDefaults.standard.set(splitConfig.curatorPercentage, forKey: "highlighter.split.curator")
    }
    private func loadSavedConfiguration() {
        let author = UserDefaults.standard.double(forKey: "highlighter.split.author")
        let highlighter = UserDefaults.standard.double(forKey: "highlighter.split.highlighter")
        let curator = UserDefaults.standard.double(forKey: "highlighter.split.curator")
        if author > 0 || highlighter > 0 || curator > 0 {
            splitConfig = SplitConfiguration(
                author: author > 0 ? author : 0.5,
                highlighter: highlighter > 0 ? highlighter : 0.3,
                curator: curator > 0 ? curator : 0.2,
                platform: 0.05
            )
        }
    }
    // MARK: - Nested Types
        struct ZapTransaction: Identifiable, Equatable {
        let id: UUID
        let totalAmount: Int
        let splits: [SubTransaction]
        let highlightId: String
        let comment: String?
        let timestamp: Date
        var formattedAmount: String {
            "\(totalAmount.formatted()) sats"
        }
    }
        struct SubTransaction: Equatable {
        let recipientPubkey: String
        let amount: Int
        let role: PaymentRole
        let paymentHash: String
        let timestamp: Date
    }
        struct PaymentSplit: Identifiable {
        let id = UUID()
        let recipientPubkey: String
        var amount: Int
        let role: PaymentRole
        let isOriginal: Bool // True for the main recipient
        var type: PaymentRole { role } // Alias for compatibility
        var status: SplitStatus = .pending
        var recipientName: String {
            switch role {
            case .author: return "Author"
            case .highlighter: return "Highlighter"
            case .curator: return "Curator"
            }
        }
        var percentage: Double {
            // Default percentages based on role
            switch role {
            case .highlighter: return 0.5
            case .author: return 0.4
            case .curator: return 0.1
            }
        }
        enum SplitStatus {
            case pending
            case sending
            case completed
            case failed
        }
    }
        enum PaymentRole: String {
        case author
        case highlighter
        case curator
        var icon: String {
            switch self {
            case .author: return "person.fill"
            case .highlighter: return "highlighter"
            case .curator: return "folder.fill"
            }
        }
        var color: Color {
            switch self {
            case .author: return .purple
            case .highlighter: return .orange
            case .curator: return .blue
            }
        }
    }
        struct PendingZap: Identifiable {
        let id: UUID
        let amount: Int
        let recipientPubkey: String
        var status: Status
        enum Status {
            case calculating
            case sending
            case failed(String)
        }
    }
        struct ActivePayment: Identifiable {
        let id: UUID
        let totalAmount: Int
        let splits: [PaymentSplit]
        let highlightId: String?
        let comment: String?
        var status: PaymentStatus
        let timestamp: Date
        enum PaymentStatus: Equatable {
            case pending
            case preparing
            case processing
            case splitting
            case sending
            case completed(ZapTransaction)
            case failed(String)
        }
    }
        struct WalletInfo {
        let alias: String
        let color: String?
        let pubkey: String
        let network: String
        let blockHeight: Int
        let methods: [String]
    }
    // MARK: - Errors
        enum LightningError: LocalizedError {
        case walletNotConnected
        case ndkNotInitialized
        case signerNotAvailable
        case invalidConnectionString
        case noLightningAddress
        case lnurlNotImplemented
        case insufficientBalance
        case paymentFailed(String)
        var errorDescription: String? {
            switch self {
            case .walletNotConnected:
                return "Lightning wallet not connected"
            case .ndkNotInitialized:
                return "NDK not initialized"
            case .signerNotAvailable:
                return "No active signer available"
            case .invalidConnectionString:
                return "Invalid NWC connection string"
            case .noLightningAddress:
                return "Recipient has no Lightning address"
            case .lnurlNotImplemented:
                return "LNURL support not yet implemented"
            case .insufficientBalance:
                return "Insufficient balance"
            case .paymentFailed(let reason):
                return "Payment failed: \(reason)"
            }
        }
    }
}
// MARK: - NWC Implementation
/// Simplified NWC implementation
// NostrWalletConnect implementation has been moved to its own file
// See NostrWalletConnect.swift for the full implementation
</file>

<file path="Sources/Highlighter/Services/LNURLService.swift">
import Foundation
/// Service for handling LNURL protocol operations
@MainActor
class LNURLService {
    enum LNURLError: LocalizedError {
        case invalidAddress
        case invalidURL
        case networkError(String)
        case invalidResponse
        case amountOutOfRange(min: Int, max: Int)
        var errorDescription: String? {
            switch self {
            case .invalidAddress:
                return "Invalid Lightning address"
            case .invalidURL:
                return "Invalid LNURL"
            case .networkError(let message):
                return "Network error: \(message)"
            case .invalidResponse:
                return "Invalid response from service"
            case .amountOutOfRange(let min, let max):
                return "Amount must be between \(min) and \(max) sats"
            }
        }
    }
    struct LNURLPayResponse {
        let callback: String
        let minSendable: Int
        let maxSendable: Int
        let metadata: String
        let commentAllowed: Int?
        let tag: String
    }
    /// Resolve a Lightning address to LNURL
    static func resolveLightningAddress(_ address: String) async throws -> URL {
        let parts = address.split(separator: "@")
        guard parts.count == 2 else {
            throw LNURLError.invalidAddress
        }
        let user = parts[0]
        let domain = parts[1]
        let urlString = "https://\(domain)/.well-known/lnurlp/\(user)"
        guard let url = URL(string: urlString) else {
            throw LNURLError.invalidURL
        }
        return url
    }
    /// Fetch LNURL pay parameters
    static func fetchPayParameters(from url: URL) async throws -> LNURLPayResponse {
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.setValue("application/json", forHTTPHeaderField: "Accept")
        let (data, response) = try await URLSession.shared.data(for: request)
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            throw LNURLError.networkError("Failed to fetch LNURL parameters")
        }
        guard let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            throw LNURLError.invalidResponse
        }
        guard let callback = json["callback"] as? String,
              let minSendable = json["minSendable"] as? Int,
              let maxSendable = json["maxSendable"] as? Int,
              let metadata = json["metadata"] as? String,
              let tag = json["tag"] as? String else {
            throw LNURLError.invalidResponse
        }
        return LNURLPayResponse(
            callback: callback,
            minSendable: minSendable / 1000, // Convert millisats to sats
            maxSendable: maxSendable / 1000, // Convert millisats to sats
            metadata: metadata,
            commentAllowed: json["commentAllowed"] as? Int,
            tag: tag
        )
    }
    /// Request an invoice from LNURL service
    static func requestInvoice(
        payResponse: LNURLPayResponse,
        amount: Int,
        comment: String? = nil,
        zapRequest: String? = nil
    ) async throws -> String {
        // Validate amount
        guard amount >= payResponse.minSendable && amount <= payResponse.maxSendable else {
            throw LNURLError.amountOutOfRange(min: payResponse.minSendable, max: payResponse.maxSendable)
        }
        guard var components = URLComponents(string: payResponse.callback) else {
            throw LNURLError.invalidURL
        }
        var queryItems = [
            URLQueryItem(name: "amount", value: String(amount * 1000)) // Convert sats to millisats
        ]
        if let comment = comment,
           let commentAllowed = payResponse.commentAllowed,
           commentAllowed > 0 {
            let trimmedComment = String(comment.prefix(commentAllowed))
            queryItems.append(URLQueryItem(name: "comment", value: trimmedComment))
        }
        if let zapRequest = zapRequest {
            queryItems.append(URLQueryItem(name: "nostr", value: zapRequest))
        }
        components.queryItems = queryItems
        guard let url = components.url else {
            throw LNURLError.invalidURL
        }
        var request = URLRequest(url: url)
        request.httpMethod = "GET"
        request.setValue("application/json", forHTTPHeaderField: "Accept")
        let (data, response) = try await URLSession.shared.data(for: request)
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            throw LNURLError.networkError("Failed to get invoice")
        }
        guard let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any],
              let invoice = json["pr"] as? String else {
            throw LNURLError.invalidResponse
        }
        return invoice
    }
    /// Get invoice for a Lightning address
    static func getInvoice(
        for lightningAddress: String,
        amount: Int,
        comment: String? = nil,
        zapRequest: String? = nil
    ) async throws -> String {
        // Resolve Lightning address to LNURL
        let url = try await resolveLightningAddress(lightningAddress)
        // Fetch pay parameters
        let payResponse = try await fetchPayParameters(from: url)
        // Request invoice
        return try await requestInvoice(
            payResponse: payResponse,
            amount: amount,
            comment: comment,
            zapRequest: zapRequest
        )
    }
}
</file>

<file path="Sources/Highlighter/Services/ProfileManager.swift">
import Foundation
import NDKSwift
import Combine
/// Manages user profile loading and caching
/// Follows SRP by focusing solely on profile management operations
@MainActor
class ProfileManager: ObservableObject {
    // MARK: - Published State
    @Published private(set) var currentUserProfile: NDKUserProfile?
    @Published private(set) var cachedProfiles: [String: NDKUserProfile] = [:]
    // MARK: - Private Properties
    private weak var ndk: NDK?
    private var profileTasks: [Task<Void, Never>] = []
    // MARK: - Initialization
    init() {}
    // MARK: - Configuration
    func configure(with ndk: NDK) {
        self.ndk = ndk
    }
    // MARK: - Profile Loading
    /// Load the current user's profile
    func loadCurrentUserProfile(for signer: NDKSigner) async {
        guard let ndk = ndk else { return }
        let pubkey: String
        do {
            pubkey = try await signer.pubkey
        } catch {
            // Failed to get pubkey
            return
        }
        // Check cache first and set immediately if available
        if let cachedProfile = cachedProfiles[pubkey] {
            currentUserProfile = cachedProfile
        }
        // Always stream for updates - following "never wait, always stream" principle
        let profileTask = Task {
            for await profile in await ndk.profileManager.observe(for: pubkey, maxAge: TimeConstants.hour) {
                await MainActor.run {
                    self.currentUserProfile = profile
                    if let profile = profile {
                        self.cachedProfiles[pubkey] = profile
                    }
                }
            }
        }
        profileTasks.append(profileTask)
    }
    /// Stream profile for any pubkey with caching
    func streamProfile(for pubkey: String) {
        guard let ndk = ndk else { return }
        // Start streaming profile updates
        let task = Task {
            for await profile in await ndk.profileManager.observe(for: pubkey, maxAge: TimeConstants.hour) {
                await MainActor.run {
                    if let profile = profile {
                        self.cachedProfiles[pubkey] = profile
                    }
                }
            }
        }
        profileTasks.append(task)
    }
    /// Get cached profile if available (no waiting)
    func getCachedProfile(for pubkey: String) -> NDKUserProfile? {
        return cachedProfiles[pubkey]
    }
    /// Clear current user profile (e.g., on logout)
    func clearCurrentUserProfile() {
        currentUserProfile = nil
    }
    /// Clear all cached profiles
    func clearCache() {
        cachedProfiles.removeAll()
        currentUserProfile = nil
    }
    /// Stop all active profile loading tasks
    func stopAllTasks() {
        for task in profileTasks {
            task.cancel()
        }
        profileTasks.removeAll()
    }
    // MARK: - Utility Methods
    /// Get display name for a pubkey, with fallback to formatted pubkey
    func displayName(for pubkey: String) -> String {
        if let profile = cachedProfiles[pubkey] {
            return PubkeyFormatter.displayName(from: profile, pubkey: pubkey)
        }
        return PubkeyFormatter.formatShort(pubkey)
    }
    /// Check if profile is cached
    func isCached(_ pubkey: String) -> Bool {
        return cachedProfiles[pubkey] != nil
    }
    /// Invalidate cache for a specific user (useful after profile updates)
    func invalidateCacheForUser(_ pubkey: String) {
        cachedProfiles.removeValue(forKey: pubkey)
        // If this is the current user, clear their profile immediately
        if currentUserProfile != nil {
            // Simply clear if any profile is being invalidated
            // The profile will be reloaded when needed
            currentUserProfile = nil
        }
    }
    // MARK: - Cleanup
    deinit {
        // Tasks will be automatically cancelled when the instance is deallocated
    }
}
</file>

<file path="Sources/Highlighter/Services/PublishingService.swift">
import Foundation
import NDKSwift
import Combine
/// Handles all content publishing operations
/// Follows SRP by focusing solely on publishing and content creation
@MainActor
class PublishingService: ObservableObject {
    static let shared = PublishingService()
    // MARK: - Published State
    @Published private(set) var isPublishing = false
    @Published private(set) var lastPublishError: Error?
    // MARK: - Private Properties
    private weak var ndk: NDK?
    private var signer: NDKSigner?
    // MARK: - Initialization
    init() {}
    // MARK: - Configuration
    func configure(with ndk: NDK, signer: NDKSigner?) {
        self.ndk = ndk
        self.signer = signer
    }
    // MARK: - Publishing Methods
    /// Publish a new highlight with optimistic updates
    func publishHighlight(_ highlight: HighlightEvent) async throws {
        guard let ndk = ndk, let signer = signer else {
            throw AuthError.noSigner
        }
        isPublishing = true
        lastPublishError = nil
        do {
            var tags: [[String]] = []
            // Add content with context if available
            if let context = highlight.context, !context.isEmpty {
                tags.append(["context", context])
            }
            // Add source/URL reference
            if let source = highlight.source {
                tags.append(["r", source])
            }
            // Add author attribution from attributed authors
            for author in highlight.attributedAuthors {
                tags.append(["p", author])
            }
            // Add alt tag for clients
            let preview = highlight.content.prefix(50)
            tags.append(["alt", "Highlight: '\(preview)...'" ])
            // Build event
            let event = try await NDKEventBuilder(ndk: ndk)
                .kind(9802) // NIP-84 highlight kind
                .content(highlight.comment ?? highlight.content)
                .tags(tags)
                .build(signer: signer)
            // Publish with optimistic updates
            _ = try await ndk.publish(event)
        } catch {
            lastPublishError = error
            throw error
        }
        isPublishing = false
    }
    /// Create and publish a new article curation
    func createCuration(
        name: String,
        title: String,
        description: String?,
        image: String?
    ) async throws {
        guard let ndk = ndk, let signer = signer else {
            throw AuthError.noSigner
        }
        isPublishing = true
        lastPublishError = nil
        do {
            let event = try await ArticleCuration.create(
                ndk: ndk,
                name: name,
                title: title,
                description: description,
                image: image,
                articles: [],
                signer: signer
            )
            _ = try await ndk.publish(event)
        } catch {
            lastPublishError = error
            throw error
        }
        isPublishing = false
    }
    /// Update an existing curation with new articles
    func updateCuration(
        _ curation: ArticleCuration,
        addingArticle article: Article
    ) async throws {
        guard let ndk = ndk, let signer = signer else {
            throw AuthError.noSigner
        }
        isPublishing = true
        lastPublishError = nil
        do {
            // Create a new list of articles including the new one
            var articles = curation.articles.map { ref -> (type: ArticleCuration.ArticleType, value: String) in
                if let url = ref.url {
                    return (.url, url)
                } else if let eventId = ref.eventId {
                    return (.event, eventId)
                } else if let eventAddress = ref.eventAddress {
                    return (.address, eventAddress)
                } else {
                    return (.url, "") // Fallback, shouldn't happen
                }
            }
            // Add the new article reference
            // If the article has a source URL, use that; otherwise use the event ID
            if let sourceUrl = article.references.first {
                articles.append((.url, sourceUrl))
            } else {
                articles.append((.event, article.id))
            }
            // Create updated curation event
            let event = try await ArticleCuration.create(
                ndk: ndk,
                name: curation.name,
                title: curation.title,
                description: curation.description,
                image: curation.image,
                articles: articles,
                signer: signer
            )
            _ = try await ndk.publish(event)
        } catch {
            lastPublishError = error
            throw error
        }
        isPublishing = false
    }
    /// Publish a text note with bookstr tag
    func publishNote(_ content: String, tags: [String] = []) async throws {
        guard let ndk = ndk, let signer = signer else {
            throw AuthError.noSigner
        }
        isPublishing = true
        lastPublishError = nil
        do {
            var eventTags: [[String]] = []
            // Add bookstr tag by default
            eventTags.append(["t", "bookstr"])
            // Add additional tags
            for tag in tags {
                eventTags.append(["t", tag])
            }
            let event = try await NDKEventBuilder(ndk: ndk)
                .kind(1) // Text note
                .content(content)
                .tags(eventTags)
                .build(signer: signer)
            _ = try await ndk.publish(event)
        } catch {
            lastPublishError = error
            throw error
        }
        isPublishing = false
    }
    /// Publish a reaction to an event
    func publishReaction(to eventId: String, content: String = "🤙") async throws {
        guard let ndk = ndk, let signer = signer else {
            throw AuthError.noSigner
        }
        isPublishing = true
        lastPublishError = nil
        do {
            let event = try await NDKEventBuilder(ndk: ndk)
                .kind(7) // Reaction
                .content(content)
                .tags([["e", eventId]])
                .build(signer: signer)
            _ = try await ndk.publish(event)
        } catch {
            lastPublishError = error
            throw error
        }
        isPublishing = false
    }
    /// Delete curations by publishing deletion events
    func deleteCurations(_ curations: [ArticleCuration]) async throws {
        guard let ndk = ndk, let signer = signer else {
            throw AuthError.noSigner
        }
        isPublishing = true
        lastPublishError = nil
        do {
            // Create deletion tags for each curation
            var deletionTags: [[String]] = []
            for curation in curations {
                // Add "a" tag for the curation (kind:pubkey:d-tag format)
                let pubkey = try await signer.pubkey
                deletionTags.append(["a", "\(30004):\(pubkey):\(curation.name)"])
            }
            // Build deletion event
            let event = try await NDKEventBuilder(ndk: ndk)
                .kind(5) // Deletion event
                .content("Deleted curations")
                .tags(deletionTags)
                .build(signer: signer)
            _ = try await ndk.publish(event)
        } catch {
            lastPublishError = error
            throw error
        }
        isPublishing = false
    }
    // MARK: - State Management
    /// Clear the last publish error
    func clearError() {
        lastPublishError = nil
    }
    /// Check if service is ready to publish
    var canPublish: Bool {
        return ndk != nil && signer != nil && !isPublishing
    }
    /// Update an existing curation
    func updateCuration(_ curation: ArticleCuration) async throws {
        guard let ndk = ndk, let signer = signer else {
            throw AuthError.noSigner
        }
        isPublishing = true
        lastPublishError = nil
        do {
            // Build updated event with same identifier
            let event = try await ArticleCuration.create(
                ndk: ndk,
                name: curation.name,
                title: curation.title,
                description: curation.description,
                image: curation.image,
                articles: curation.articles.compactMap { ref in
                    if let url = ref.url {
                        return (.url, url)
                    } else if let eventId = ref.eventId {
                        return (.event, eventId)
                    } else if let eventAddress = ref.eventAddress {
                        return (.address, eventAddress)
                    }
                    return nil
                },
                signer: signer
            )
            _ = try await ndk.publish(event)
        } catch {
            lastPublishError = error
            throw error
        }
        isPublishing = false
    }
    /// Delete a single curation
    func deleteCuration(_ curation: ArticleCuration) async throws {
        try await deleteCurations([curation])
    }
}
</file>

<file path="Sources/Highlighter/Utilities/AnimationExtensions.swift">
import SwiftUI
extension View {
    func onAnimationCompleted<Value: VectorArithmetic>(for value: Value, completion: @escaping () -> Void) -> some View {
        modifier(AnimationCompletionObserver(observedValue: value, completion: completion))
    }
}
struct AnimationCompletionObserver<Value: VectorArithmetic>: AnimatableModifier {
    var animatableData: Value {
        didSet {
            completion()
        }
    }
    private let completion: () -> Void
    private let observedValue: Value
    init(observedValue: Value, completion: @escaping () -> Void) {
        self.completion = completion
        self.observedValue = observedValue
        self.animatableData = observedValue
    }
    func body(content: Content) -> some View {
        content
    }
}
</file>

<file path="Sources/Highlighter/Utilities/BlurHashDecoder.swift">
import UIKit
import SwiftUI
struct BlurHash {
    // BlurHash algorithm constants
    private enum Constants {
        static let minimumHashLength = 6
        static let componentDivisor = 9
        static let maximumValueDivisor: Float = 166
        static let headerLength = 4
        static let componentDataLength = 2
    }
    static func decode(blurhash: String, width: Int, height: Int) -> UIImage? {
        guard blurhash.count >= Constants.minimumHashLength else { return nil }
        let sizeFlag = String(blurhash[blurhash.startIndex]).decode83()
        let numY = (sizeFlag / Constants.componentDivisor) + 1
        let numX = (sizeFlag % Constants.componentDivisor) + 1
        let quantisedMaximumValue = String(blurhash[blurhash.index(blurhash.startIndex, offsetBy: 1)]).decode83()
        let maximumValue = Float(quantisedMaximumValue + 1) / Constants.maximumValueDivisor
        guard blurhash.count == Constants.headerLength + Constants.componentDataLength * numX * numY else { return nil }
        var colours: [(Float, Float, Float)] = []
        for i in 0 ..< numX * numY {
            if i == 0 {
                let value = String(blurhash[blurhash.index(blurhash.startIndex, offsetBy: 2) ..< blurhash.index(blurhash.startIndex, offsetBy: 6)]).decode83()
                colours.append(decodeDC(value))
            } else {
                let range = blurhash.index(blurhash.startIndex, offsetBy: 4 + i * 2) ..< blurhash.index(blurhash.startIndex, offsetBy: 4 + i * 2 + 2)
                let value = String(blurhash[range]).decode83()
                colours.append(decodeAC(value, maximumValue: maximumValue))
            }
        }
        // Image data constants
        let bytesPerPixel = 3  // RGB without alpha
        let bytesPerRow = width * bytesPerPixel
        let pixels = UnsafeMutablePointer<UInt8>.allocate(capacity: bytesPerRow * height)
        for y in 0 ..< height {
            for x in 0 ..< width {
                var r: Float = 0
                var g: Float = 0
                var b: Float = 0
                for j in 0 ..< numY {
                    for i in 0 ..< numX {
                        let basis = cos(Float.pi * Float(x) * Float(i) / Float(width)) * cos(Float.pi * Float(y) * Float(j) / Float(height))
                        let colour = colours[i + j * numX]
                        r += colour.0 * basis
                        g += colour.1 * basis
                        b += colour.2 * basis
                    }
                }
                let intR = UInt8(linearTosRGB(r))
                let intG = UInt8(linearTosRGB(g))
                let intB = UInt8(linearTosRGB(b))
                // RGB channel offsets
                let redOffset = 0
                let greenOffset = 1
                let blueOffset = 2
                pixels[bytesPerPixel * x + redOffset + y * bytesPerRow] = intR
                pixels[bytesPerPixel * x + greenOffset + y * bytesPerRow] = intG
                pixels[bytesPerPixel * x + blueOffset + y * bytesPerRow] = intB
            }
        }
        let bitmapInfo = CGBitmapInfo(rawValue: CGImageAlphaInfo.none.rawValue)
        guard let provider = CGDataProvider(dataInfo: nil, data: pixels, size: bytesPerRow * height, releaseData: { _, data, _ in
            data.deallocate()
        }) else { return nil }
        // Image format constants
        let bitsPerComponent = 8
        let bitsPerPixel = 24  // 8 bits × 3 channels (RGB)
        guard let cgImage = CGImage(
            width: width,
            height: height,
            bitsPerComponent: bitsPerComponent,
            bitsPerPixel: bitsPerPixel,
            bytesPerRow: bytesPerRow,
            space: CGColorSpaceCreateDeviceRGB(),
            bitmapInfo: bitmapInfo,
            provider: provider,
            decode: nil,
            shouldInterpolate: true,
            intent: .defaultIntent
        ) else { return nil }
        return UIImage(cgImage: cgImage)
    }
    // Color decoding constants
    private enum ColorConstants {
        static let redShift = 16
        static let greenShift = 8
        static let byteMask = 255
        static let quantizationFactor = 19
        static let centeringOffset: Float = 9
        static let powerExponent: Float = 2
    }
    private static func decodeDC(_ value: Int) -> (Float, Float, Float) {
        let intR = value >> ColorConstants.redShift
        let intG = (value >> ColorConstants.greenShift) & ColorConstants.byteMask
        let intB = value & ColorConstants.byteMask
        return (sRGBToLinear(intR), sRGBToLinear(intG), sRGBToLinear(intB))
    }
    private static func decodeAC(_ value: Int, maximumValue: Float) -> (Float, Float, Float) {
        let quantR = value / (ColorConstants.quantizationFactor * ColorConstants.quantizationFactor)
        let quantG = (value / ColorConstants.quantizationFactor) % ColorConstants.quantizationFactor
        let quantB = value % ColorConstants.quantizationFactor
        let rgb = (
            signPow((Float(quantR) - ColorConstants.centeringOffset) / ColorConstants.centeringOffset, ColorConstants.powerExponent) * maximumValue,
            signPow((Float(quantG) - ColorConstants.centeringOffset) / ColorConstants.centeringOffset, ColorConstants.powerExponent) * maximumValue,
            signPow((Float(quantB) - ColorConstants.centeringOffset) / ColorConstants.centeringOffset, ColorConstants.powerExponent) * maximumValue
        )
        return rgb
    }
    // sRGB color space conversion constants
    private enum SRGBConstants {
        static let maxColorValue: Float = 255
        static let linearThreshold: Float = 0.04045
        static let linearDivisor: Float = 12.92
        static let gammaOffset: Float = 0.055
        static let gammaMultiplier: Float = 1.055
        static let gammaExponent: Float = 2.4
        static let inverseLinearThreshold: Float = 0.0031308
    }
    private static func sRGBToLinear(_ value: Int) -> Float {
        let v = Float(value) / SRGBConstants.maxColorValue
        if v <= SRGBConstants.linearThreshold {
            return v / SRGBConstants.linearDivisor
        } else {
            return pow((v + SRGBConstants.gammaOffset) / SRGBConstants.gammaMultiplier, SRGBConstants.gammaExponent)
        }
    }
    private static func linearTosRGB(_ value: Float) -> Int {
        let v = max(0, min(1, value))
        if v <= SRGBConstants.inverseLinearThreshold {
            return Int(v * SRGBConstants.linearDivisor * SRGBConstants.maxColorValue + 0.5)
        } else {
            return Int((SRGBConstants.gammaMultiplier * pow(v, 1 / SRGBConstants.gammaExponent) - SRGBConstants.gammaOffset) * SRGBConstants.maxColorValue + 0.5)
        }
    }
    private static func signPow(_ value: Float, _ exp: Float) -> Float {
        return copysign(pow(abs(value), exp), value)
    }
}
private extension String {
    private static let base83Radix = 83
    func decode83() -> Int {
        var value: Int = 0
        for character in self {
            if let digit = decode83Map[character] {
                value = value * String.base83Radix + digit
            }
        }
        return value
    }
}
private let decode83Map: [Character: Int] = {
    let chars = Array("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz#$%*+,-.:;=?@[]^_{|}~")
    var dict: [Character: Int] = [:]
    for (index, character) in chars.enumerated() {
        dict[character] = index
    }
    return dict
}()
// SwiftUI View Modifier
struct BlurHashModifier: ViewModifier {
    let blurhash: String?
    let size: CGSize
    @State private var blurImage: UIImage?
    func body(content: Content) -> some View {
        content
            .background(
                Group {
                    if let blurImage = blurImage {
                        Image(uiImage: blurImage)
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                            .transition(.opacity)
                    }
                }
            )
            .onAppear {
                if let blurhash = blurhash {
                    DispatchQueue.global(qos: .userInitiated).async {
                        // Performance optimization: decode at lower resolution
                        let resolutionDivisor = 10
                        let fadeInDuration = 0.3
                        let image = BlurHash.decode(
                            blurhash: blurhash,
                            width: Int(size.width / CGFloat(resolutionDivisor)),
                            height: Int(size.height / CGFloat(resolutionDivisor))
                        )
                        DispatchQueue.main.async {
                            withAnimation(.easeIn(duration: fadeInDuration)) {
                                self.blurImage = image
                            }
                        }
                    }
                }
            }
    }
}
extension View {
    func blurhashBackground(_ blurhash: String?, size: CGSize) -> some View {
        modifier(BlurHashModifier(blurhash: blurhash, size: size))
    }
}
</file>

<file path="Sources/Highlighter/Utilities/FormattingUtilities.swift">
import SwiftUI
import NDKSwift
// MARK: - Centralized Formatting Utilities
// Following DRY principle: All formatting logic consolidated in one place
// MARK: - Pubkey Formatting
struct PubkeyFormatter {
    /// Format pubkey for display with customizable length
    /// - Parameters:
    ///   - pubkey: The public key to format
    ///   - prefixLength: Number of characters from the start (default: 8)
    ///   - suffixLength: Number of characters from the end (default: 4)
    /// - Returns: Formatted string like "npub1abc...xyz"
    static func format(_ pubkey: String, prefixLength: Int = 8, suffixLength: Int = 4) -> String {
        guard pubkey.count > prefixLength + suffixLength else {
            return pubkey
        }
        let prefix = String(pubkey.prefix(prefixLength))
        let suffix = String(pubkey.suffix(suffixLength))
        return "\(prefix)...\(suffix)"
    }
    /// Compact format for tight spaces (6 + 3 characters)
    static func formatCompact(_ pubkey: String) -> String {
        format(pubkey, prefixLength: 6, suffixLength: 3)
    }
    /// Short format for lists and cards (8 + 4 characters)
    static func formatShort(_ pubkey: String) -> String {
        format(pubkey, prefixLength: 8, suffixLength: 4)
    }
    /// Long format for profile pages (12 + 6 characters)
    static func formatLong(_ pubkey: String) -> String {
        format(pubkey, prefixLength: 12, suffixLength: 6)
    }
    /// Format for avatar initials (first 2 characters)
    static func formatForAvatar(_ pubkey: String) -> String {
        String(pubkey.prefix(2)).uppercased()
    }
    /// Format for display name with fallback options
    static func displayName(from profile: NDKUserProfile?, pubkey: String) -> String {
        if let displayName = profile?.displayName, !displayName.isEmpty {
            return displayName
        } else if let name = profile?.name, !name.isEmpty {
            return name
        } else {
            return formatShort(pubkey)
        }
    }
    /// Check if a string is a valid pubkey format
    static func isValidPubkey(_ pubkey: String) -> Bool {
        HexValidator.isValid32ByteHex(pubkey)
    }
    /// Convert hex pubkey to npub format (if needed in the future)
    static func toNpub(_ hexPubkey: String) -> String {
        // For now, just return the hex format as specified in the NDK guidance
        // "All public keys are hex encoded (not npub)"
        return hexPubkey
    }
}
// MARK: - Time Formatting
struct RelativeTimeFormatter {
    // Time interval constants in seconds
    private enum TimeIntervals {
        static let justNow: TimeInterval = 30
        static let minute: TimeInterval = 60
        static let hour: TimeInterval = 3600
        static let day: TimeInterval = 86400
        static let week: TimeInterval = 604800
        static let month: TimeInterval = 2592000  // 30 days approximation
        static let year: TimeInterval = 31536000  // 365 days
    }
    /// Format timestamp as relative time (e.g., "2 hours ago", "just now")
    /// - Parameter timestamp: NDK timestamp to format
    /// - Returns: Human-readable relative time string
    static func relativeTime(from timestamp: Timestamp) -> String {
        let date = Date(timeIntervalSince1970: TimeInterval(timestamp))
        return relativeTime(from: date)
    }
    /// Format Date as relative time
    /// - Parameter date: Date to format
    /// - Returns: Human-readable relative time string
    static func relativeTime(from date: Date) -> String {
        let now = Date()
        let interval = now.timeIntervalSince(date)
        // Future dates
        if interval < 0 {
            return "in the future"
        }
        // Just now (under 30 seconds)
        if interval < TimeIntervals.justNow {
            return "just now"
        }
        // Minutes
        if interval < TimeIntervals.hour {
            let minutes = Int(interval / TimeIntervals.minute)
            return "\(minutes) minute\(minutes == 1 ? "" : "s") ago"
        }
        // Hours (under 24 hours)
        if interval < TimeIntervals.day {
            let hours = Int(interval / TimeIntervals.hour)
            return "\(hours) hour\(hours == 1 ? "" : "s") ago"
        }
        // Days (under 7 days)
        if interval < TimeIntervals.week {
            let days = Int(interval / TimeIntervals.day)
            return "\(days) day\(days == 1 ? "" : "s") ago"
        }
        // Weeks (under 30 days)
        if interval < TimeIntervals.month {
            let weeks = Int(interval / TimeIntervals.week)
            return "\(weeks) week\(weeks == 1 ? "" : "s") ago"
        }
        // Months (under 365 days)
        if interval < TimeIntervals.year {
            let months = Int(interval / TimeIntervals.month)
            return "\(months) month\(months == 1 ? "" : "s") ago"
        }
        // Years
        let years = Int(interval / TimeIntervals.year)
        return "\(years) year\(years == 1 ? "" : "s") ago"
    }
    /// Short relative time format for compact display (e.g., "2h", "3d", "1y")
    /// - Parameter timestamp: NDK timestamp to format
    /// - Returns: Short relative time string
    static func shortRelativeTime(from timestamp: Timestamp) -> String {
        let date = Date(timeIntervalSince1970: TimeInterval(timestamp))
        return shortRelativeTime(from: date)
    }
    /// Short relative time format for compact display
    /// - Parameter date: Date to format
    /// - Returns: Short relative time string
    static func shortRelativeTime(from date: Date) -> String {
        let now = Date()
        let interval = now.timeIntervalSince(date)
        // Future dates
        if interval < 0 {
            return "future"
        }
        // Just now (under 30 seconds)
        if interval < TimeIntervals.justNow {
            return "now"
        }
        // Minutes
        if interval < TimeIntervals.hour {
            let minutes = Int(interval / TimeIntervals.minute)
            return "\(minutes)m"
        }
        // Hours (under 24 hours)
        if interval < TimeIntervals.day {
            let hours = Int(interval / TimeIntervals.hour)
            return "\(hours)h"
        }
        // Days (under 7 days)
        if interval < TimeIntervals.week {
            let days = Int(interval / TimeIntervals.day)
            return "\(days)d"
        }
        // Weeks (under 30 days)
        if interval < TimeIntervals.month {
            let weeks = Int(interval / TimeIntervals.week)
            return "\(weeks)w"
        }
        // Months (under 365 days)
        if interval < TimeIntervals.year {
            let months = Int(interval / TimeIntervals.month)
            return "\(months)mo"
        }
        // Years
        let years = Int(interval / TimeIntervals.year)
        return "\(years)y"
    }
    /// Format timestamp as exact time when needed (e.g., "Mar 15, 2024 at 3:45 PM")
    /// - Parameter timestamp: NDK timestamp to format
    /// - Returns: Formatted date and time string
    static func exactTime(from timestamp: Timestamp) -> String {
        let date = Date(timeIntervalSince1970: TimeInterval(timestamp))
        return exactTime(from: date)
    }
    /// Format Date as exact time
    /// - Parameter date: Date to format
    /// - Returns: Formatted date and time string
    static func exactTime(from date: Date) -> String {
        return DateFormatters.display.string(from: date)
    }
    /// Smart formatting that switches between relative and exact based on age
    /// Recent items show relative time, older items show exact date
    /// - Parameter timestamp: NDK timestamp to format
    /// - Returns: Contextually appropriate time string
    static func smartFormat(from timestamp: Timestamp) -> String {
        let date = Date(timeIntervalSince1970: TimeInterval(timestamp))
        let now = Date()
        let interval = now.timeIntervalSince(date)
        // Use relative time for recent items (under 7 days)
        if interval < TimeIntervals.week {
            return relativeTime(from: date)
        }
        // Use exact date for older items
        return exactTime(from: date)
    }
    /// Ultra-compact time formatting for cards (legacy compatibility)
    static func compactTime(from timestamp: Timestamp) -> String {
        return shortRelativeTime(from: timestamp)
    }
}
// MARK: - Content Formatting
struct ContentFormatter {
    /// Smart truncation of content based on context
    static func smartTruncate(_ content: String, maxLength: Int, context: TruncationContext = .general) -> String {
        guard content.count > maxLength else { return content }
        let actualLimit = max(maxLength - 3, 10) // Reserve space for ellipsis
        let truncated = String(content.prefix(actualLimit))
        // Try to break at word boundary for better readability
        if let lastSpace = truncated.lastIndex(of: " "), lastSpace > truncated.startIndex {
            let wordBoundaryTruncated = String(truncated[..<lastSpace])
            if wordBoundaryTruncated.count > actualLimit * 3 / 4 { // Only use word boundary if it's not too short
                return wordBoundaryTruncated + "..."
            }
        }
        return truncated + "..."
    }
    /// Format highlight content with proper quotes
    static func formatHighlight(_ content: String, addQuotes: Bool = true) -> String {
        let trimmed = content.trimmingCharacters(in: .whitespacesAndNewlines)
        return addQuotes ? "\"\(trimmed)\"" : trimmed
    }
    /// Extract domain from URL for display
    static func extractDomain(from urlString: String) -> String {
        guard let url = URL(string: urlString) else { return "Source" }
        return url.host ?? "Source"
    }
    /// Format sats amount with appropriate units
    static func formatSatsAmount(_ sats: Int64) -> String {
        let thousand: Int64 = 1_000
        let million: Int64 = 1_000_000
        if sats < thousand {
            return "\(sats)"
        } else if sats < million {
            let k = Double(sats) / Double(thousand)
            return String(format: "%.1fk", k)
        } else {
            let m = Double(sats) / Double(million)
            return String(format: "%.1fM", m)
        }
    }
}
// MARK: - Supporting Types
enum TruncationContext {
    case general
    case quote
    case title
    case description
    var preferredLength: Int {
        switch self {
        case .general: return 100
        case .quote: return 150
        case .title: return 50
        case .description: return 200
        }
    }
}
// MARK: - Validation Utilities
struct ValidationUtilities {
    /// Validate if a string is a valid Nostr private key (nsec)
    static func isValidNsec(_ nsec: String) -> Bool {
        return nsec.hasPrefix("nsec") && nsec.count > 10
    }
    /// Validate if a string is a valid URL
    static func isValidURL(_ urlString: String) -> Bool {
        guard let url = URL(string: urlString) else { return false }
        return url.scheme != nil && url.host != nil
    }
    /// Clean and validate highlight content
    static func cleanHighlightContent(_ content: String) -> String? {
        let cleaned = content.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !cleaned.isEmpty && cleaned.count >= 3 else { return nil }
        return cleaned
    }
}
// MARK: - SwiftUI Integration Helpers
extension View {
    /// Apply smart content truncation with consistent styling
    func smartContent(_ content: String, maxLength: Int = 100, context: TruncationContext = .general) -> some View {
        Text(ContentFormatter.smartTruncate(content, maxLength: maxLength, context: context))
    }
    /// Display relative time with consistent formatting
    func relativeTime(from timestamp: Timestamp, style: RelativeTimeStyle = .standard) -> some View {
        let timeString: String
        switch style {
        case .standard:
            timeString = RelativeTimeFormatter.relativeTime(from: timestamp)
        case .short:
            timeString = RelativeTimeFormatter.shortRelativeTime(from: timestamp)
        case .compact:
            timeString = RelativeTimeFormatter.compactTime(from: timestamp)
        }
        return Text(timeString)
    }
}
enum RelativeTimeStyle {
    case standard
    case short
    case compact
}
// MARK: - Greeting Utilities
struct GreetingFormatter {
    /// Generate time-based greeting text
    static func timeBasedGreeting() -> String {
        let hour = Calendar.current.component(.hour, from: Date())
        switch hour {
        case 0..<12: return "Good morning"
        case 12..<17: return "Good afternoon"
        default: return "Good evening"
        }
    }
    /// Format current date for display
    static func formattedDate() -> String {
        Date().formatted(.dateTime.weekday(.wide).month(.wide).day())
    }
}
// MARK: - Cache Policies
/// Common cache duration policies for consistent caching behavior across the app
struct CachePolicies {
    // Base time units
    private static let minute: TimeInterval = 60
    private static let hour: TimeInterval = 60 * minute
    private static let day: TimeInterval = 24 * hour
    /// Short-term cache for frequently changing content (5 minutes)
    /// Used for: Highlights (kind 9802) that update frequently  
    static let shortTerm: TimeInterval = 5 * minute
    /// Medium-term cache for moderately changing content (1 hour)
    /// Used for: Curations (kind 30004) and Follow Packs (kind 39089)
    static let mediumTerm: TimeInterval = hour
    /// Long-term cache for rarely changing content (24 hours)
    /// Used for: User profiles and metadata
    static let longTerm: TimeInterval = day
    /// Extended cache for very stable content (7 days)
    /// Used for: Relay lists and other configuration data
    static let extended: TimeInterval = 7 * day
}
</file>

<file path="Sources/Highlighter/Utilities/HapticManager.swift">
import UIKit
/// Centralized haptic feedback manager for consistent tactile interactions
/// Follows the Highlighter app's focus on "pixel-perfect" user experience with refined haptics
@MainActor
class HapticManager {
    static let shared = HapticManager()
    private let impactLight = UIImpactFeedbackGenerator(style: .light)
    private let impactMedium = UIImpactFeedbackGenerator(style: .medium)
    private let impactHeavy = UIImpactFeedbackGenerator(style: .heavy)
    private let selection = UISelectionFeedbackGenerator()
    private let notification = UINotificationFeedbackGenerator()
    /// Disable all haptics (for accessibility or user preference)
    var isEnabled: Bool = true
    private init() {
        // Prepare generators on initialization for faster response
        prepare()
    }
    enum ImpactStyle {
        case light, medium, heavy
    }
    enum NotificationStyle {
        case success, warning, error
    }
    func prepare() {
        impactLight.prepare()
        impactMedium.prepare()
        impactHeavy.prepare()
        selection.prepare()
        notification.prepare()
    }
    func impact(_ style: ImpactStyle) {
        guard isEnabled else { return }
        switch style {
        case .light:
            impactLight.impactOccurred()
            impactLight.prepare() // Prepare for next use
        case .medium:
            impactMedium.impactOccurred()
            impactMedium.prepare()
        case .heavy:
            impactHeavy.impactOccurred()
            impactHeavy.prepare()
        }
    }
    func triggerSelection() {
        guard isEnabled else { return }
        selection.selectionChanged()
        selection.prepare()
    }
    func notification(_ style: NotificationStyle) {
        guard isEnabled else { return }
        switch style {
        case .success:
            notification.notificationOccurred(.success)
        case .warning:
            notification.notificationOccurred(.warning)
        case .error:
            notification.notificationOccurred(.error)
        }
        notification.prepare()
    }
    // MARK: - Haptic Timing Constants
    private enum HapticDelays {
        static let shortDelay: TimeInterval = 0.1
        static let mediumDelay: TimeInterval = 0.2
        static let longDelay: TimeInterval = 0.3
    }
    // MARK: - Contextual Haptic Methods for Highlighter App
    /// Haptic for highlighting text (medium impact)
    func highlight() { impact(.medium) }
    /// Haptic for zap actions (heavy impact + success notification)
    func zap() {
        impact(.heavy)
        DispatchQueue.main.asyncAfter(deadline: .now() + HapticDelays.shortDelay) {
            self.notification(.success)
        }
    }
    /// Haptic for bookmark/save actions (light impact)
    func bookmark() { impact(.light) }
    /// Haptic for successful actions (e.g., publish highlight)
    func success() { notification(.success) }
    /// Haptic for error states
    func error() { notification(.error) }
    /// Haptic for warning states
    func warning() { notification(.warning) }
    /// Haptic for tab bar selection
    func tabSelection() { triggerSelection() }
    /// Haptic for button press with contextual feedback
    func buttonPress(style: ImpactStyle = .light) { impact(style) }
    /// Haptic for card interactions (light impact)
    func cardTap() { impact(.light) }
    /// Haptic for swipe actions
    func swipe() { impact(.light) }
    /// Haptic for long press gestures
    func longPress() { impact(.heavy) }
    /// Subtle haptic for hover/selection preview
    func preview() { impact(.light) }
    // MARK: - Complex Haptic Patterns
    /// Haptic pattern for publishing content (sequence of impacts)
    func publish() {
        impact(.medium)
        DispatchQueue.main.asyncAfter(deadline: .now() + HapticDelays.mediumDelay) {
            self.notification(.success)
        }
    }
    /// Haptic pattern for loading completion
    func loadComplete() { impact(.light) }
    /// Haptic pattern for pull-to-refresh
    func refresh() {
        impact(.light)
        DispatchQueue.main.asyncAfter(deadline: .now() + HapticDelays.longDelay) {
            self.impact(.light)
        }
    }
}
</file>

<file path="Sources/Highlighter/Utilities/KeychainManager.swift">
import Foundation
import Security
/// Secure storage manager using iOS Keychain for sensitive data
@MainActor
class KeychainManager {
    static let shared = KeychainManager()
    private let serviceName = "com.highlighter.app"
    private init() {}
    enum KeychainError: LocalizedError {
        case unhandledError(status: OSStatus)
        case noData
        case unexpectedData
        var errorDescription: String? {
            switch self {
            case .unhandledError(let status):
                return "Keychain error: \(status)"
            case .noData:
                return "No data found in keychain"
            case .unexpectedData:
                return "Unexpected data format in keychain"
            }
        }
    }
    // MARK: - Public Methods
    /// Save a string value to the keychain
    func save(_ value: String, for key: String) throws {
        guard let data = value.data(using: .utf8) else {
            throw KeychainError.unexpectedData
        }
        // Delete any existing item first
        try? delete(key: key)
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: serviceName,
            kSecAttrAccount as String: key,
            kSecValueData as String: data,
            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly
        ]
        let status = SecItemAdd(query as CFDictionary, nil)
        guard status == errSecSuccess else {
            throw KeychainError.unhandledError(status: status)
        }
    }
    /// Retrieve a string value from the keychain
    func retrieve(key: String) throws -> String {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: serviceName,
            kSecAttrAccount as String: key,
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]
        var dataTypeRef: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &dataTypeRef)
        guard status == errSecSuccess else {
            if status == errSecItemNotFound {
                throw KeychainError.noData
            }
            throw KeychainError.unhandledError(status: status)
        }
        guard let data = dataTypeRef as? Data,
              let string = String(data: data, encoding: .utf8) else {
            throw KeychainError.unexpectedData
        }
        return string
    }
    /// Delete a value from the keychain
    func delete(key: String) throws {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: serviceName,
            kSecAttrAccount as String: key
        ]
        let status = SecItemDelete(query as CFDictionary)
        guard status == errSecSuccess || status == errSecItemNotFound else {
            throw KeychainError.unhandledError(status: status)
        }
    }
    /// Check if a key exists in the keychain
    func exists(key: String) -> Bool {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: serviceName,
            kSecAttrAccount as String: key,
            kSecReturnAttributes as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]
        var dataTypeRef: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &dataTypeRef)
        return status == errSecSuccess
    }
}
// MARK: - Convenience Keys
extension KeychainManager {
    enum Keys {
        static let nwcConnection = "nwc.connection"
        static let userPrivateKey = "user.privateKey"
        static let authToken = "auth.token"
    }
}
</file>

<file path="Sources/Highlighter/Utilities/PreferenceKeys.swift">
import SwiftUI
// MARK: - Shared Preference Keys
struct ScrollOffsetPreferenceKey: PreferenceKey {
    static var defaultValue: CGFloat = 0
    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value = nextValue()
    }
}
</file>

<file path="Sources/Highlighter/Views/Analytics/EngagementVisualization.swift">
import SwiftUI
import Charts
import NDKSwift
struct EngagementVisualization: View {
    @EnvironmentObject var appState: AppState
    @State private var selectedTimeRange = TimeRange.week
    @State private var engagementData: [EngagementDataPoint] = []
    @State private var animateChart = false
    @State private var selectedMetric: MetricType = .all
    @State private var showInsights = false
    @State private var hoveredDataPoint: EngagementDataPoint?
    @State private var trendingHighlights: [HighlightEvent] = []
    enum TimeRange: String, CaseIterable {
        case day = "24h"
        case week = "7d"
        case month = "30d"
        case year = "1y"
        var title: String {
            switch self {
            case .day: return "Last 24 Hours"
            case .week: return "Last 7 Days"
            case .month: return "Last 30 Days"
            case .year: return "Last Year"
            }
        }
    }
    enum MetricType: String, CaseIterable {
        case all = "All"
        case likes = "Likes"
        case comments = "Comments"
        case zaps = "Zaps"
        case reposts = "Reposts"
        var color: Color {
            switch self {
            case .all: return .purple
            case .likes: return .red
            case .comments: return .blue
            case .zaps: return .orange
            case .reposts: return .green
            }
        }
        var icon: String {
            switch self {
            case .all: return "chart.line.uptrend.xyaxis"
            case .likes: return "heart.fill"
            case .comments: return "bubble.right.fill"
            case .zaps: return "bolt.fill"
            case .reposts: return "arrow.2.squarepath"
            }
        }
    }
    struct EngagementDataPoint: Identifiable {
        let id = UUID()
        let date: Date
        let likes: Int
        let comments: Int
        let zaps: Int
        let reposts: Int
        var total: Int {
            likes + comments + zaps + reposts
        }
        func value(for metric: MetricType) -> Int {
            switch metric {
            case .all: return total
            case .likes: return likes
            case .comments: return comments
            case .zaps: return zaps
            case .reposts: return reposts
            }
        }
    }
    var body: some View {
        ScrollView {
            VStack(spacing: DesignSystem.Spacing.xl) {
                // Header with controls
                headerSection
                // Main chart
                chartSection
                    .frame(height: 300)
                    .padding(.horizontal, DesignSystem.Spacing.large)
                // Metric cards
                metricCardsSection
                    .padding(.horizontal, DesignSystem.Spacing.large)
                // Insights section
                if showInsights {
                    insightsSection
                        .padding(.horizontal, DesignSystem.Spacing.large)
                        .transition(.asymmetric(
                            insertion: .push(from: .bottom).combined(with: .opacity),
                            removal: .push(from: .top).combined(with: .opacity)
                        ))
                }
                // Trending highlights
                trendingHighlightsSection
            }
            .padding(.vertical, DesignSystem.Spacing.large)
        }
        .background(DesignSystem.Colors.background)
        .onAppear {
            loadEngagementData()
            startAnimations()
            loadTrendingHighlights()
        }
    }
    // MARK: - Header Section
    private var headerSection: some View {
        VStack(spacing: DesignSystem.Spacing.medium) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text("Engagement Analytics")
                        .font(.system(size: 28, weight: .bold, design: .rounded))
                        .foregroundColor(DesignSystem.Colors.text)
                    Text("Track your content performance")
                        .font(.system(size: 16))
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                }
                Spacer()
                Button(action: {
                    withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                        showInsights.toggle()
                        HapticManager.shared.impact(.light)
                    }
                }) {
                    HStack(spacing: 6) {
                        Image(systemName: "lightbulb.fill")
                            .font(.system(size: 14))
                        Text("Insights")
                            .font(.system(size: 14, weight: .medium))
                    }
                    .foregroundColor(showInsights ? .white : DesignSystem.Colors.primary)
                    .padding(.horizontal, 16)
                    .padding(.vertical, 8)
                    .background(
                        Capsule()
                            .fill(showInsights ? DesignSystem.Colors.primary : DesignSystem.Colors.primary.opacity(0.1))
                    )
                }
            }
            .padding(.horizontal, DesignSystem.Spacing.large)
            // Time range selector
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: DesignSystem.Spacing.small) {
                    ForEach(TimeRange.allCases, id: \.self) { range in
                        TimeRangeButton(
                            range: range,
                            isSelected: selectedTimeRange == range,
                            action: {
                                withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                                    selectedTimeRange = range
                                    loadEngagementData()
                                    HapticManager.shared.impact(.light)
                                }
                            }
                        )
                    }
                }
                .padding(.horizontal, DesignSystem.Spacing.large)
            }
        }
    }
    // MARK: - Chart Section
    private var chartSection: some View {
        VStack(spacing: DesignSystem.Spacing.medium) {
            // Metric selector
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: DesignSystem.Spacing.small) {
                    ForEach(MetricType.allCases, id: \.self) { metric in
                        MetricButton(
                            metric: metric,
                            isSelected: selectedMetric == metric,
                            action: {
                                withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                                    selectedMetric = metric
                                    HapticManager.shared.impact(.light)
                                }
                            }
                        )
                    }
                }
            }
            // Chart
            ZStack {
                // Background gradient
                LinearGradient(
                    colors: [
                        selectedMetric.color.opacity(0.1),
                        selectedMetric.color.opacity(0.05),
                        Color.clear
                    ],
                    startPoint: .top,
                    endPoint: .bottom
                )
                .clipShape(RoundedRectangle(cornerRadius: 20, style: .continuous))
                if !engagementData.isEmpty {
                    Chart(engagementData) { dataPoint in
                        // Area chart
                        AreaMark(
                            x: .value("Date", dataPoint.date),
                            y: .value("Value", animateChart ? dataPoint.value(for: selectedMetric) : 0)
                        )
                        .foregroundStyle(
                            LinearGradient(
                                colors: [
                                    selectedMetric.color.opacity(0.6),
                                    selectedMetric.color.opacity(0.1)
                                ],
                                startPoint: .top,
                                endPoint: .bottom
                            )
                        )
                        .interpolationMethod(.catmullRom)
                        // Line chart
                        LineMark(
                            x: .value("Date", dataPoint.date),
                            y: .value("Value", animateChart ? dataPoint.value(for: selectedMetric) : 0)
                        )
                        .foregroundStyle(selectedMetric.color)
                        .lineStyle(StrokeStyle(lineWidth: 3, lineCap: .round, lineJoin: .round))
                        .interpolationMethod(.catmullRom)
                        // Points
                        PointMark(
                            x: .value("Date", dataPoint.date),
                            y: .value("Value", animateChart ? dataPoint.value(for: selectedMetric) : 0)
                        )
                        .foregroundStyle(.white)
                        .symbolSize(hoveredDataPoint?.id == dataPoint.id ? 100 : 60)
                        .annotation(position: .top) {
                            if hoveredDataPoint?.id == dataPoint.id {
                                VStack(spacing: 4) {
                                    Text("\(dataPoint.value(for: selectedMetric))")
                                        .font(.system(size: 14, weight: .bold))
                                        .foregroundColor(selectedMetric.color)
                                    Text(dataPoint.date, style: .time)
                                        .font(.system(size: 12))
                                        .foregroundColor(DesignSystem.Colors.textSecondary)
                                }
                                .padding(8)
                                .background(
                                    RoundedRectangle(cornerRadius: 8)
                                        .fill(DesignSystem.Colors.surface)
                                        .shadow(radius: 4)
                                )
                                .transition(.scale.combined(with: .opacity))
                            }
                        }
                    }
                    .chartYScale(domain: 0...maxChartValue)
                    .chartXAxis {
                        AxisMarks(preset: .aligned) { value in
                            AxisValueLabel()
                                .font(.system(size: 12))
                                .foregroundStyle(DesignSystem.Colors.textSecondary)
                        }
                    }
                    .chartYAxis {
                        AxisMarks(position: .leading) { value in
                            AxisValueLabel()
                                .font(.system(size: 12))
                                .foregroundStyle(DesignSystem.Colors.textSecondary)
                            AxisGridLine()
                                .foregroundStyle(DesignSystem.Colors.divider.opacity(0.5))
                        }
                    }
                    .animation(.spring(response: 0.8, dampingFraction: 0.8), value: animateChart)
                    .animation(.spring(response: 0.5, dampingFraction: 0.8), value: selectedMetric)
                    .onTapGesture { location in
                        // Handle tap to show data point details
                    }
                }
            }
            .padding(DesignSystem.Spacing.medium)
            .background(
                RoundedRectangle(cornerRadius: 20, style: .continuous)
                    .fill(DesignSystem.Colors.surface)
                    .shadow(color: DesignSystem.Shadow.medium.color, radius: DesignSystem.Shadow.medium.radius)
            )
        }
    }
    // MARK: - Metric Cards
    private var metricCardsSection: some View {
        VStack(spacing: DesignSystem.Spacing.medium) {
            HStack(spacing: DesignSystem.Spacing.medium) {
                AnimatedMetricCard(
                    title: "Total Engagement",
                    value: totalEngagement,
                    change: engagementChange,
                    icon: "chart.line.uptrend.xyaxis",
                    color: .purple
                )
                AnimatedMetricCard(
                    title: "Avg. per Highlight",
                    value: averageEngagement,
                    change: 0.15,
                    icon: "divide.circle.fill",
                    color: .blue
                )
            }
            HStack(spacing: DesignSystem.Spacing.medium) {
                AnimatedMetricCard(
                    title: "Best Performing",
                    value: bestPerformingCount,
                    change: 0.32,
                    icon: "trophy.fill",
                    color: .orange
                )
                AnimatedMetricCard(
                    title: "Growth Rate",
                    value: growthRate,
                    change: growthRateChange,
                    icon: "arrow.up.right.circle.fill",
                    color: .green
                )
            }
        }
    }
    // MARK: - Insights Section
    private var insightsSection: some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.medium) {
            Text("AI-Powered Insights")
                .font(.system(size: 20, weight: .semibold))
                .foregroundColor(DesignSystem.Colors.text)
            VStack(spacing: DesignSystem.Spacing.small) {
                InsightCard(
                    icon: "lightbulb.fill",
                    title: "Peak Engagement Times",
                    description: "Your highlights get 3x more engagement when posted between 2-4 PM EST",
                    color: .yellow
                )
                InsightCard(
                    icon: "person.2.fill",
                    title: "Top Audience",
                    description: "Tech enthusiasts and Bitcoin community members engage most with your content",
                    color: .blue
                )
                InsightCard(
                    icon: "quote.bubble.fill",
                    title: "Content Recommendation",
                    description: "Philosophical quotes receive 45% more zaps than technical content",
                    color: .purple
                )
            }
        }
        .padding(DesignSystem.Spacing.large)
        .background(
            RoundedRectangle(cornerRadius: 20, style: .continuous)
                .fill(
                    LinearGradient(
                        colors: [
                            DesignSystem.Colors.primary.opacity(0.05),
                            DesignSystem.Colors.secondary.opacity(0.03)
                        ],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .overlay(
                    RoundedRectangle(cornerRadius: 20, style: .continuous)
                        .stroke(DesignSystem.Colors.primary.opacity(0.2), lineWidth: 1)
                )
        )
    }
    // MARK: - Trending Highlights
    private var trendingHighlightsSection: some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.medium) {
            HStack {
                Text("Trending Highlights")
                    .font(.system(size: 24, weight: .bold))
                    .foregroundColor(DesignSystem.Colors.text)
                Spacer()
                Button(action: {}) {
                    Text("View All")
                        .font(.system(size: 14))
                        .foregroundColor(DesignSystem.Colors.primary)
                }
            }
            .padding(.horizontal, DesignSystem.Spacing.large)
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: DesignSystem.Spacing.medium) {
                    if trendingHighlights.isEmpty {
                        ForEach(0..<3) { index in
                            TrendingHighlightPlaceholder(index: index)
                                .frame(width: 280)
                        }
                    } else {
                        ForEach(Array(trendingHighlights.prefix(10).enumerated()), id: \.element.id) { index, highlight in
                            RealTrendingHighlightCard(index: index, highlight: highlight)
                                .frame(width: 280)
                        }
                    }
                }
                .padding(.horizontal, DesignSystem.Spacing.large)
            }
        }
    }
    // MARK: - Helper Properties
    private var maxChartValue: Int {
        engagementData.map { $0.value(for: selectedMetric) }.max() ?? 100
    }
    private var totalEngagement: Int {
        engagementData.reduce(0) { $0 + $1.total }
    }
    private var averageEngagement: Int {
        guard !engagementData.isEmpty else { return 0 }
        return totalEngagement / engagementData.count
    }
    private var bestPerformingCount: Int {
        engagementData.filter { $0.total > averageEngagement * 2 }.count
    }
    private var growthRate: Int {
        guard engagementData.count >= 2 else { return 0 }
        let recent = engagementData.suffix(engagementData.count / 2).reduce(0) { $0 + $1.total }
        let past = engagementData.prefix(engagementData.count / 2).reduce(0) { $0 + $1.total }
        return past > 0 ? Int(((Double(recent) / Double(past)) - 1) * 100) : 0
    }
    private var engagementChange: Double {
        guard engagementData.count >= 2 else { return 0 }
        let current = engagementData.last?.total ?? 0
        let previous = engagementData.dropLast().last?.total ?? 1
        return Double(current - previous) / Double(previous)
    }
    private var growthRateChange: Double {
        growthRate > 0 ? 0.01 * Double(growthRate) : -0.01 * Double(abs(growthRate))
    }
    // MARK: - Helper Methods
    private func loadEngagementData() {
        Task {
            guard let ndk = appState.ndk, let signer = appState.activeSigner else { return }
            do {
                let pubkey = try await signer.pubkey
                // Calculate time interval based on selected range
                let now = Date()
                let startDate: Date
                switch selectedTimeRange {
                case .day:
                    startDate = now.addingTimeInterval(-86400) // 24 hours
                case .week:
                    startDate = now.addingTimeInterval(-604800) // 7 days
                case .month:
                    startDate = now.addingTimeInterval(-2592000) // 30 days
                case .year:
                    startDate = now.addingTimeInterval(-31536000) // 365 days
                }
                // Fetch user's highlights to analyze engagement
                let highlightFilter = NDKFilter(
                    authors: [pubkey],
                    kinds: [9802], // NIP-84 highlights
                    since: Int64(startDate.timeIntervalSince1970),
                    limit: 500
                )
                let highlightDataSource = await ndk.outbox.observe(
                    filter: highlightFilter,
                    maxAge: 300,
                    cachePolicy: .cacheWithNetwork
                )
                var highlights: [NDKEvent] = []
                for await event in highlightDataSource.events {
                    highlights.append(event)
                }
                // Now fetch reactions for these highlights
                var dataPoints: [Date: EngagementDataPoint] = [:]
                // Initialize data points based on time range
                let interval: TimeInterval
                let bucketCount: Int
                switch selectedTimeRange {
                case .day:
                    interval = 3600 // 1 hour buckets
                    bucketCount = 24
                case .week:
                    interval = 86400 // 1 day buckets
                    bucketCount = 7
                case .month:
                    interval = 86400 // 1 day buckets
                    bucketCount = 30
                case .year:
                    interval = 2592000 // 30 day buckets
                    bucketCount = 12
                }
                // Initialize buckets
                for i in 0..<bucketCount {
                    let bucketDate = now.addingTimeInterval(-Double(i) * interval)
                    let normalizedDate = Date(timeIntervalSince1970: floor(bucketDate.timeIntervalSince1970 / interval) * interval)
                    dataPoints[normalizedDate] = EngagementDataPoint(
                        date: normalizedDate,
                        likes: 0,
                        comments: 0,
                        zaps: 0,
                        reposts: 0
                    )
                }
                // For each highlight, get its engagement
                for highlight in highlights {
                    let highlightDate = Date(timeIntervalSince1970: Double(highlight.createdAt))
                    let bucketDate = Date(timeIntervalSince1970: floor(highlightDate.timeIntervalSince1970 / interval) * interval)
                    // Fetch reactions for this highlight
                    var tagsFilter: [String: Set<String>] = [:]
                    tagsFilter["e"] = [highlight.id]
                    let reactionFilter = NDKFilter(
                        kinds: [7], // Reactions
                        limit: 1000,
                        tags: tagsFilter
                    )
                    let reactionDataSource = await ndk.outbox.observe(
                        filter: reactionFilter,
                        maxAge: 300,
                        cachePolicy: .cacheWithNetwork
                    )
                    var likes = 0
                    for await reaction in reactionDataSource.events {
                        if reaction.content == "🤙" || reaction.content == "+" || reaction.content == "❤️" {
                            likes += 1
                        }
                    }
                    // Count replies (kind 1 with e tag)
                    let replyFilter = NDKFilter(
                        kinds: [1], // Text notes
                        limit: 100,
                        tags: tagsFilter
                    )
                    let replyDataSource = await ndk.outbox.observe(
                        filter: replyFilter,
                        maxAge: 300,
                        cachePolicy: .cacheWithNetwork
                    )
                    var comments = 0
                    for await _ in replyDataSource.events {
                        comments += 1
                    }
                    // Count reposts
                    let repostFilter = NDKFilter(
                        kinds: [6], // Reposts
                        limit: 100,
                        tags: tagsFilter
                    )
                    let repostDataSource = await ndk.outbox.observe(
                        filter: repostFilter,
                        maxAge: 300,
                        cachePolicy: .cacheWithNetwork
                    )
                    var reposts = 0
                    for await _ in repostDataSource.events {
                        reposts += 1
                    }
                    // Count zaps (kind 9735)
                    let zapFilter = NDKFilter(
                        kinds: [9735], // Zap receipts
                        limit: 100,
                        tags: tagsFilter
                    )
                    let zapDataSource = await ndk.outbox.observe(
                        filter: zapFilter,
                        maxAge: 300,
                        cachePolicy: .cacheWithNetwork
                    )
                    var zaps = 0
                    for await _ in zapDataSource.events {
                        zaps += 1
                    }
                    // Update the data point
                    if var dataPoint = dataPoints[bucketDate] {
                        dataPoint = EngagementDataPoint(
                            date: dataPoint.date,
                            likes: dataPoint.likes + likes,
                            comments: dataPoint.comments + comments,
                            zaps: dataPoint.zaps + zaps,
                            reposts: dataPoint.reposts + reposts
                        )
                        dataPoints[bucketDate] = dataPoint
                    }
                }
                // Convert to array and sort by date
                let sortedData = dataPoints.values.sorted { $0.date < $1.date }
                await MainActor.run {
                    self.engagementData = sortedData
                }
            } catch {
                // If we can't load real data, show empty state
                await MainActor.run {
                    self.engagementData = []
                }
            }
        }
    }
    private func loadTrendingHighlights() {
        Task {
            guard let ndk = appState.ndk else { return }
            // Fetch recent highlights with high engagement
            let filter = NDKFilter(
                kinds: [9802],
                since: Timestamp(Date().addingTimeInterval(-7 * 24 * 60 * 60).timeIntervalSince1970),
                limit: 50
            )
            let dataSource = NDKDataSource(
                ndk: ndk,
                filter: filter,
                maxAge: CachePolicies.shortTerm,
                cachePolicy: .cacheWithNetwork,
                closeOnEose: true
            )
            var highlights: [HighlightEvent] = []
            for await event in dataSource.events {
                if let highlight = try? HighlightEvent(from: event) {
                    highlights.append(highlight)
                }
            }
            // Sort by engagement (approximated by recent creation time for now)
            let sortedHighlights = highlights.sorted { $0.createdAt > $1.createdAt }
            await MainActor.run {
                self.trendingHighlights = Array(sortedHighlights.prefix(10))
            }
        }
    }
    private func startAnimations() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            withAnimation(.spring(response: 0.8, dampingFraction: 0.8)) {
                animateChart = true
            }
        }
    }
}
// MARK: - Supporting Views
struct TimeRangeButton: View {
    let range: EngagementVisualization.TimeRange
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            Text(range.rawValue)
                .font(.system(size: 14, weight: isSelected ? .semibold : .regular))
                .foregroundColor(isSelected ? .white : DesignSystem.Colors.text)
                .padding(.horizontal, 16)
                .padding(.vertical, 8)
                .background(
                    Capsule()
                        .fill(isSelected ? DesignSystem.Colors.primary : DesignSystem.Colors.surfaceSecondary)
                )
        }
    }
}
struct MetricButton: View {
    let metric: EngagementVisualization.MetricType
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            HStack(spacing: 6) {
                Image(systemName: metric.icon)
                    .font(.system(size: 14))
                Text(metric.rawValue)
                    .font(.system(size: 14, weight: .medium))
            }
            .foregroundColor(isSelected ? .white : metric.color)
            .padding(.horizontal, 16)
            .padding(.vertical, 8)
            .background(
                Capsule()
                    .fill(isSelected ? metric.color : metric.color.opacity(0.1))
                    .overlay(
                        Capsule()
                            .stroke(metric.color, lineWidth: isSelected ? 0 : 1)
                    )
            )
        }
    }
}
struct AnimatedMetricCard: View {
    let title: String
    let value: Int
    let change: Double
    let icon: String
    let color: Color
    @State private var animatedValue: Int = 0
    @State private var showValue = false
    var body: some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.small) {
            HStack {
                Image(systemName: icon)
                    .font(.system(size: 20))
                    .foregroundColor(color)
                    .rotationEffect(.degrees(showValue ? 0 : -180))
                    .animation(.spring(response: 0.6, dampingFraction: 0.8), value: showValue)
                Spacer()
                HStack(spacing: 4) {
                    Image(systemName: change > 0 ? "arrow.up.right" : "arrow.down.right")
                        .font(.system(size: 12, weight: .bold))
                    Text("\(Int(abs(change * 100)))%")
                        .font(.system(size: 12, weight: .bold))
                }
                .foregroundColor(change > 0 ? .green : .red)
            }
            Text("\(animatedValue)")
                .font(.system(size: 28, weight: .bold, design: .rounded))
                .foregroundColor(DesignSystem.Colors.text)
                .contentTransition(.numericText())
                .opacity(showValue ? 1 : 0)
                .offset(y: showValue ? 0 : 20)
            Text(title)
                .font(.system(size: 14))
                .foregroundColor(DesignSystem.Colors.textSecondary)
        }
        .padding(DesignSystem.Spacing.medium)
        .frame(maxWidth: .infinity, alignment: .leading)
        .background(
            RoundedRectangle(cornerRadius: 16, style: .continuous)
                .fill(DesignSystem.Colors.surface)
                .shadow(color: DesignSystem.Shadow.small.color, radius: DesignSystem.Shadow.small.radius)
        )
        .onAppear {
            withAnimation(.spring(response: 0.6, dampingFraction: 0.8)) {
                animatedValue = value
                showValue = true
            }
        }
    }
}
struct InsightCard: View {
    let icon: String
    let title: String
    let description: String
    let color: Color
    var body: some View {
        HStack(spacing: DesignSystem.Spacing.medium) {
            Image(systemName: icon)
                .font(.system(size: 24))
                .foregroundColor(color)
                .frame(width: 40, height: 40)
                .background(
                    Circle()
                        .fill(color.opacity(0.1))
                )
            VStack(alignment: .leading, spacing: 4) {
                Text(title)
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundColor(DesignSystem.Colors.text)
                Text(description)
                    .font(.system(size: 14))
                    .foregroundColor(DesignSystem.Colors.textSecondary)
                    .lineLimit(2)
            }
            Spacer()
        }
        .padding(DesignSystem.Spacing.medium)
        .background(
            RoundedRectangle(cornerRadius: 12, style: .continuous)
                .fill(DesignSystem.Colors.surface)
        )
    }
}
struct TrendingHighlightPlaceholder: View {
    let index: Int
    var body: some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.small) {
            HStack {
                Text("#\(index + 1)")
                    .font(.system(size: 14, weight: .bold, design: .rounded))
                    .foregroundColor(DesignSystem.Colors.primary)
                Spacer()
                RoundedRectangle(cornerRadius: 4)
                    .fill(DesignSystem.Colors.textTertiary.opacity(0.3))
                    .frame(width: 60, height: 16)
            }
            VStack(alignment: .leading, spacing: 8) {
                RoundedRectangle(cornerRadius: 4)
                    .fill(DesignSystem.Colors.textTertiary.opacity(0.3))
                    .frame(height: 16)
                RoundedRectangle(cornerRadius: 4)
                    .fill(DesignSystem.Colors.textTertiary.opacity(0.3))
                    .frame(height: 16)
                RoundedRectangle(cornerRadius: 4)
                    .fill(DesignSystem.Colors.textTertiary.opacity(0.3))
                    .frame(width: 180, height: 16)
            }
            HStack(spacing: DesignSystem.Spacing.medium) {
                ForEach(0..<3) { _ in
                    RoundedRectangle(cornerRadius: 4)
                        .fill(DesignSystem.Colors.textTertiary.opacity(0.3))
                        .frame(width: 50, height: 14)
                }
            }
        }
        .padding(DesignSystem.Spacing.medium)
        .background(
            RoundedRectangle(cornerRadius: 16, style: .continuous)
                .fill(DesignSystem.Colors.surface)
                .shadow(color: DesignSystem.Shadow.small.color, radius: DesignSystem.Shadow.small.radius)
        )
        .redacted(reason: .placeholder)
    }
}
struct RealTrendingHighlightCard: View {
    let index: Int
    let highlight: HighlightEvent
    @State private var reactions: [String: Int] = [:]
    @EnvironmentObject var appState: AppState
    var body: some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.small) {
            HStack {
                Text("#\(index + 1)")
                    .font(.system(size: 14, weight: .bold, design: .rounded))
                    .foregroundColor(DesignSystem.Colors.primary)
                Spacer()
                Label("Trending", systemImage: "flame.fill")
                    .font(.system(size: 12, weight: .medium))
                    .foregroundColor(.orange)
            }
            Text(highlight.content)
                .font(.system(size: 16, weight: .medium))
                .foregroundColor(DesignSystem.Colors.text)
                .lineLimit(3)
                .multilineTextAlignment(.leading)
            HStack {
                Text(PubkeyFormatter.formatCompact(highlight.author))
                    .font(.system(size: 12))
                    .foregroundColor(DesignSystem.Colors.textSecondary)
                Text("·")
                    .foregroundColor(DesignSystem.Colors.textTertiary)
                Text(RelativeTimeFormatter.relativeTime(from: highlight.createdAt))
                    .font(.system(size: 12))
                    .foregroundColor(DesignSystem.Colors.textTertiary)
                Spacer()
                if highlight.context != nil {
                    Image(systemName: "text.bubble")
                        .font(.system(size: 12))
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                }
            }
        }
        .padding(DesignSystem.Spacing.medium)
        .background(
            RoundedRectangle(cornerRadius: 16, style: .continuous)
                .fill(DesignSystem.Colors.surface)
                .shadow(color: DesignSystem.Shadow.small.color, radius: DesignSystem.Shadow.small.radius)
        )
    }
}
#Preview {
    NavigationStack {
        EngagementVisualization()
            .environmentObject(AppState())
    }
}
</file>

<file path="Sources/Highlighter/Views/Audio/AudioPlayerView.swift">
import SwiftUI
import AVFoundation
import NDKSwift
struct AudioPlayerView: View {
    let highlight: HighlightEvent
    var article: Article? = nil
    @StateObject private var audioManager = AudioPlayerManager()
    @State private var showSatStreaming = false
    @State private var satStreamAmount: Int = 21
    @State private var waveformAnimation: [CGFloat] = Array(repeating: 0.5, count: 40)
    @State private var glowAnimation = false
    @State private var pulseAnimation = false
    @State private var particleSystem: [AudioParticle] = []
    @State private var rotationAngle: Double = 0
    @State private var expandedView = false
    @State private var showSpeedControl = false
    @State private var selectedVoice: AVSpeechSynthesisVoice?
    @State private var satStreamTimer: Timer?
    @Namespace private var animation
    @Environment(\.colorScheme) var colorScheme
    @EnvironmentObject var appState: AppState
    var body: some View {
        VStack(spacing: 0) {
            if expandedView {
                expandedPlayer
                    .transition(.asymmetric(
                        insertion: .scale(scale: 0.95).combined(with: .opacity),
                        removal: .scale(scale: 0.95).combined(with: .opacity)
                    ))
            } else {
                compactPlayer
                    .transition(.asymmetric(
                        insertion: .scale(scale: 0.95).combined(with: .opacity),
                        removal: .scale(scale: 0.95).combined(with: .opacity)
                    ))
            }
        }
        .background(playerBackground)
        .clipShape(RoundedRectangle(cornerRadius: expandedView ? 24 : 16))
        .overlay(
            RoundedRectangle(cornerRadius: expandedView ? 24 : 16)
                .stroke(
                    LinearGradient(
                        colors: [
                            Color.orange.opacity(audioManager.isPlaying ? 0.6 : 0.3),
                            Color.purple.opacity(audioManager.isPlaying ? 0.4 : 0.2)
                        ],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    ),
                    lineWidth: audioManager.isPlaying ? 2 : 1
                )
                .blur(radius: audioManager.isPlaying ? 1 : 0)
        )
        .shadow(
            color: audioManager.isPlaying ? Color.orange.opacity(0.3) : Color.black.opacity(0.1),
            radius: audioManager.isPlaying ? 20 : 10,
            y: 5
        )
        .scaleEffect(pulseAnimation ? 1.02 : 1.0)
        .onAppear {
            audioManager.setupSpeech(for: highlight)
            startAnimations()
            generateParticles()
        }
        .onChange(of: audioManager.isPlaying) { _, playing in
            if playing {
                startPlayingAnimations()
            } else {
                stopPlayingAnimations()
            }
        }
    }
    @ViewBuilder
    private var compactPlayer: some View {
        HStack(spacing: 16) {
            // Play/Pause button with animated ring
            playPauseButton(size: 44)
            // Waveform visualization
            HStack(spacing: 2) {
                ForEach(0..<20) { index in
                    Capsule()
                        .fill(
                            LinearGradient(
                                colors: [
                                    Color.orange.opacity(0.8),
                                    Color.purple.opacity(0.6)
                                ],
                                startPoint: .top,
                                endPoint: .bottom
                            )
                        )
                        .frame(width: 3, height: waveformAnimation[index] * 30)
                        .animation(
                            audioManager.isPlaying ?
                                .easeInOut(duration: Double.random(in: 0.3...0.6))
                                .repeatForever(autoreverses: true) :
                                .easeOut(duration: 0.3),
                            value: waveformAnimation[index]
                        )
                }
            }
            .frame(height: 30)
            Spacer()
            // Speed control
            Button(action: {
                HapticManager.shared.impact(.light)
                withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                    showSpeedControl.toggle()
                }
            }) {
                Label("\(String(format: "%.1fx", audioManager.speechRate))", systemImage: "gauge")
                    .font(.caption.weight(.medium))
                    .foregroundColor(.orange)
            }
            // Expand button
            Button(action: {
                HapticManager.shared.impact(.light)
                withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                    expandedView = true
                }
            }) {
                Image(systemName: "arrow.up.left.and.arrow.down.right")
                    .font(.caption.weight(.bold))
                    .foregroundColor(.orange)
                    .padding(8)
                    .background(Color.orange.opacity(0.1))
                    .clipShape(Circle())
            }
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 12)
        if showSpeedControl {
            speedControlView
                .transition(.asymmetric(
                    insertion: .push(from: .top).combined(with: .opacity),
                    removal: .push(from: .bottom).combined(with: .opacity)
                ))
        }
    }
    @ViewBuilder
    private var expandedPlayer: some View {
        VStack(spacing: 24) {
            // Header with minimize button
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text("Text-to-Speech")
                        .font(.headline)
                    Text("\(highlight.content.split(separator: " ").count) words")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                Spacer()
                Button(action: {
                    HapticManager.shared.impact(.light)
                    withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                        expandedView = false
                    }
                }) {
                    Image(systemName: "arrow.down.right.and.arrow.up.left")
                        .font(.caption.weight(.bold))
                        .foregroundColor(.orange)
                        .padding(8)
                        .background(Color.orange.opacity(0.1))
                        .clipShape(Circle())
                }
            }
            .padding(.horizontal, 20)
            .padding(.top, 20)
            // Main visualization area
            ZStack {
                // Particle system background
                ForEach(particleSystem) { particle in
                    AudioParticleView(particle: particle, isPlaying: audioManager.isPlaying)
                }
                // Central play button with rings
                centralPlayButton
            }
            .frame(height: 200)
            // Progress bar
            progressBar
                .padding(.horizontal, 20)
            // Waveform visualization
            waveformVisualization
                .frame(height: 60)
                .padding(.horizontal, 20)
            // Controls
            VStack(spacing: 16) {
                // Speed control
                speedControlView
                // Voice selection
                voiceSelectionView
                // Sat streaming toggle
                satStreamingView
            }
            .padding(.horizontal, 20)
            .padding(.bottom, 20)
        }
    }
    @ViewBuilder
    private var centralPlayButton: some View {
        ZStack {
            // Animated rings
            ForEach(0..<3) { index in
                Circle()
                    .stroke(
                        AngularGradient(
                            colors: [
                                Color.orange.opacity(0.3 - Double(index) * 0.1),
                                Color.purple.opacity(0.2 - Double(index) * 0.05),
                                Color.orange.opacity(0.3 - Double(index) * 0.1)
                            ],
                            center: .center,
                            angle: .degrees(rotationAngle + Double(index) * 120)
                        ),
                        lineWidth: 2
                    )
                    .frame(
                        width: 100 + CGFloat(index) * 40,
                        height: 100 + CGFloat(index) * 40
                    )
                    .blur(radius: audioManager.isPlaying ? 1 : 0)
                    .scaleEffect(audioManager.isPlaying ? 1.1 : 1.0)
                    .opacity(audioManager.isPlaying ? 0.8 : 0.4)
            }
            // Main button
            playPauseButton(size: 80)
        }
    }
    @ViewBuilder
    private func playPauseButton(size: CGFloat) -> some View {
        Button(action: {
            HapticManager.shared.impact(.medium)
            audioManager.togglePlayPause()
        }) {
            ZStack {
                // Glow background
                Circle()
                    .fill(
                        RadialGradient(
                            colors: [
                                Color.orange.opacity(glowAnimation ? 0.4 : 0.2),
                                Color.orange.opacity(0)
                            ],
                            center: .center,
                            startRadius: 0,
                            endRadius: size
                        )
                    )
                    .frame(width: size * 2, height: size * 2)
                    .blur(radius: 10)
                // Button background
                Circle()
                    .fill(
                        LinearGradient(
                            colors: [Color.orange, Color.orange.opacity(0.8)],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: size, height: size)
                // Icon
                Image(systemName: audioManager.isPlaying ? "pause.fill" : "play.fill")
                    .font(.system(size: size * 0.4, weight: .bold))
                    .foregroundColor(.white)
                    .offset(x: audioManager.isPlaying ? 0 : 2)
            }
        }
        .buttonStyle(.plain)
    }
    @ViewBuilder
    private var progressBar: some View {
        VStack(spacing: 8) {
            // Time labels
            HStack {
                Text(formatTime(audioManager.currentTime))
                    .font(.caption.monospacedDigit())
                    .foregroundColor(.secondary)
                Spacer()
                Text(formatTime(audioManager.duration))
                    .font(.caption.monospacedDigit())
                    .foregroundColor(.secondary)
            }
            // Progress slider
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    // Background track
                    Capsule()
                        .fill(Color.gray.opacity(0.2))
                        .frame(height: 4)
                    // Progress fill
                    Capsule()
                        .fill(
                            LinearGradient(
                                colors: [Color.orange, Color.purple],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .frame(width: geometry.size.width * audioManager.progress, height: 4)
                    // Glow effect
                    Capsule()
                        .fill(Color.orange.opacity(0.5))
                        .frame(width: geometry.size.width * audioManager.progress, height: 4)
                        .blur(radius: 4)
                    // Draggable thumb
                    Circle()
                        .fill(Color.white)
                        .frame(width: 16, height: 16)
                        .shadow(color: Color.black.opacity(0.2), radius: 2, y: 1)
                        .overlay(
                            Circle()
                                .fill(Color.orange)
                                .frame(width: 8, height: 8)
                        )
                        .position(x: geometry.size.width * audioManager.progress, y: 2)
                        .gesture(
                            DragGesture()
                                .onChanged { value in
                                    let progress = min(max(0, value.location.x / geometry.size.width), 1)
                                    audioManager.seek(to: progress)
                                }
                        )
                }
            }
            .frame(height: 4)
        }
    }
    @ViewBuilder
    private var waveformVisualization: some View {
        HStack(spacing: 2) {
            ForEach(0..<40) { index in
                Capsule()
                    .fill(
                        LinearGradient(
                            colors: [
                                Color.orange.opacity(0.8),
                                Color.purple.opacity(0.6)
                            ],
                            startPoint: .top,
                            endPoint: .bottom
                        )
                    )
                    .frame(width: 4, height: waveformAnimation[index] * 60)
                    .animation(
                        audioManager.isPlaying ?
                            .easeInOut(duration: Double.random(in: 0.3...0.6))
                            .repeatForever(autoreverses: true) :
                            .easeOut(duration: 0.3),
                        value: waveformAnimation[index]
                    )
            }
        }
    }
    @ViewBuilder
    private var speedControlView: some View {
        VStack(spacing: 8) {
            HStack {
                Text("Playback Speed")
                    .font(.caption.weight(.medium))
                    .foregroundColor(.secondary)
                Spacer()
                Text("\(String(format: "%.1fx", audioManager.speechRate))")
                    .font(.caption.weight(.bold).monospacedDigit())
                    .foregroundColor(.orange)
            }
            HStack(spacing: 12) {
                ForEach([0.5, 0.75, 1.0, 1.25, 1.5, 2.0], id: \.self) { speed in
                    Button(action: {
                        HapticManager.shared.impact(.light)
                        audioManager.setSpeechRate(Float(speed))
                    }) {
                        Text("\(String(format: "%.1fx", speed))")
                            .font(.caption.weight(.medium))
                            .foregroundColor(audioManager.speechRate == Float(speed) ? .white : .orange)
                            .padding(.horizontal, 12)
                            .padding(.vertical, 6)
                            .background(
                                Capsule()
                                    .fill(audioManager.speechRate == Float(speed) ? Color.orange : Color.orange.opacity(0.1))
                            )
                    }
                }
            }
        }
        .padding(16)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.gray.opacity(0.1))
        )
    }
    @ViewBuilder
    private var voiceSelectionView: some View {
        VStack(spacing: 8) {
            HStack {
                Text("Voice")
                    .font(.caption.weight(.medium))
                    .foregroundColor(.secondary)
                Spacer()
                Text(selectedVoice?.name ?? "Default")
                    .font(.caption.weight(.medium))
                    .foregroundColor(.orange)
            }
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 8) {
                    ForEach(AVSpeechSynthesisVoice.speechVoices().prefix(6), id: \.identifier) { voice in
                        Button(action: {
                            HapticManager.shared.impact(.light)
                            selectedVoice = voice
                            audioManager.setVoice(voice)
                        }) {
                            VStack(spacing: 4) {
                                Image(systemName: "person.wave.2")
                                    .font(.title3)
                                    .foregroundColor(selectedVoice?.identifier == voice.identifier ? .white : .orange)
                                Text(voice.name.components(separatedBy: " ").first ?? "Voice")
                                    .font(.caption2)
                                    .foregroundColor(selectedVoice?.identifier == voice.identifier ? .white : .orange)
                            }
                            .frame(width: 60, height: 60)
                            .background(
                                RoundedRectangle(cornerRadius: 12)
                                    .fill(selectedVoice?.identifier == voice.identifier ? Color.orange : Color.orange.opacity(0.1))
                            )
                        }
                    }
                }
            }
        }
        .padding(16)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.gray.opacity(0.1))
        )
    }
    @ViewBuilder
    private var satStreamingView: some View {
        VStack(spacing: 12) {
            HStack {
                Label("Sat Streaming", systemImage: "bolt.fill")
                    .font(.caption.weight(.medium))
                    .foregroundColor(.orange)
                Spacer()
                Toggle("", isOn: $showSatStreaming)
                    .toggleStyle(SwitchToggleStyle(tint: .orange))
                    .scaleEffect(0.8)
            }
            if showSatStreaming {
                VStack(spacing: 8) {
                    HStack {
                        Text("Stream amount")
                            .font(.caption)
                            .foregroundColor(.secondary)
                        Spacer()
                        Text("\(satStreamAmount) sats/min")
                            .font(.caption.weight(.bold).monospacedDigit())
                            .foregroundColor(.orange)
                    }
                    HStack(spacing: 8) {
                        ForEach([1, 5, 10, 21, 50, 100], id: \.self) { amount in
                            Button(action: {
                                HapticManager.shared.impact(.light)
                                satStreamAmount = amount
                            }) {
                                Text("\(amount)")
                                    .font(.caption.weight(.medium))
                                    .foregroundColor(satStreamAmount == amount ? .white : .orange)
                                    .padding(.horizontal, 10)
                                    .padding(.vertical, 6)
                                    .background(
                                        Capsule()
                                            .fill(satStreamAmount == amount ? Color.orange : Color.orange.opacity(0.1))
                                    )
                            }
                        }
                    }
                    if audioManager.isPlaying {
                        HStack(spacing: 8) {
                            Image(systemName: "bolt.fill")
                                .font(.caption)
                                .foregroundColor(.orange)
                                .symbolEffect(.pulse)
                            Text("Streaming \(satStreamAmount) sats/min to author")
                                .font(.caption)
                                .foregroundColor(.secondary)
                            Spacer()
                        }
                        .padding(8)
                        .background(
                            RoundedRectangle(cornerRadius: 8)
                                .fill(Color.orange.opacity(0.1))
                        )
                    }
                }
                .transition(.asymmetric(
                    insertion: .push(from: .top).combined(with: .opacity),
                    removal: .push(from: .bottom).combined(with: .opacity)
                ))
            }
        }
        .padding(16)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.gray.opacity(0.1))
        )
    }
    @ViewBuilder
    private var playerBackground: some View {
        ZStack {
            // Base background
            if colorScheme == .dark {
                Color.black.opacity(0.95)
            } else {
                Color.white.opacity(0.98)
            }
            // Gradient overlay
            LinearGradient(
                colors: [
                    Color.orange.opacity(0.05),
                    Color.purple.opacity(0.03)
                ],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            // Animated mesh gradient (iOS 18+)
            if #available(iOS 18.0, *) {
                MeshGradient(
                    width: 3,
                    height: 3,
                    points: [
                        [0, 0], [0.5, 0], [1, 0],
                        [0, 0.5], [0.5, 0.5], [1, 0.5],
                        [0, 1], [0.5, 1], [1, 1]
                    ],
                    colors: [
                        .orange.opacity(0.1), .purple.opacity(0.05), .orange.opacity(0.1),
                        .purple.opacity(0.05), .clear, .purple.opacity(0.05),
                        .orange.opacity(0.1), .purple.opacity(0.05), .orange.opacity(0.1)
                    ]
                )
                .blur(radius: 20)
                .opacity(glowAnimation ? 0.8 : 0.3)
            }
        }
    }
    private func formatTime(_ time: TimeInterval) -> String {
        let minutes = Int(time) / 60
        let seconds = Int(time) % 60
        return String(format: "%d:%02d", minutes, seconds)
    }
    private func startAnimations() {
        withAnimation(.easeInOut(duration: 2).repeatForever(autoreverses: true)) {
            glowAnimation = true
        }
        withAnimation(.linear(duration: 10).repeatForever(autoreverses: false)) {
            rotationAngle = 360
        }
    }
    private func startPlayingAnimations() {
        withAnimation(.easeInOut(duration: 1.5).repeatForever(autoreverses: true)) {
            pulseAnimation = true
        }
        // Animate waveform
        for i in 0..<40 {
            DispatchQueue.main.asyncAfter(deadline: .now() + Double(i) * 0.02) {
                waveformAnimation[i] = CGFloat.random(in: 0.3...1.0)
            }
        }
        // Start sat streaming if enabled
        if showSatStreaming {
            startSatStreaming()
        }
    }
    private func stopPlayingAnimations() {
        pulseAnimation = false
        // Reset waveform
        for i in 0..<40 {
            waveformAnimation[i] = 0.5
        }
        // Stop sat streaming
        stopSatStreaming()
    }
    private func generateParticles() {
        for _ in 0..<12 {
            let particle = AudioParticle(
                x: CGFloat.random(in: -100...100),
                y: CGFloat.random(in: -100...100),
                size: CGFloat.random(in: 4...12),
                color: [Color.orange, Color.purple].randomElement()!,
                speed: CGFloat.random(in: 20...60)
            )
            particleSystem.append(particle)
        }
    }
    private func startSatStreaming() {
        guard showSatStreaming else { return }
        // Create a timer to send sats periodically
        satStreamTimer = Timer.scheduledTimer(withTimeInterval: 60.0, repeats: true) { _ in
            Task {
                // Send value-for-value payment
                if let articleAuthorPubkey = article?.author,
                   let lnurl = await resolveLightningAddress(for: articleAuthorPubkey) {
                    // Send payment via Lightning
                    await sendSatsViaLightning(amount: satStreamAmount, to: lnurl)
                }
            }
        }
    }
    private func stopSatStreaming() {
        satStreamTimer?.invalidate()
        satStreamTimer = nil
    }
    private func resolveLightningAddress(for pubkey: String) async -> String? {
        // Try to get Lightning address from user's profile
        if let profile = appState.profileManager.getCachedProfile(for: pubkey) {
            return profile.lud16 ?? profile.lud06
        }
        return nil
    }
    private func sendSatsViaLightning(amount: Int, to address: String) async {
        // This would integrate with Lightning Service
        // For now, we'll use the zap functionality
        do {
            if article?.author != nil {
                // Use Lightning service to send payment
                try await appState.lightningService.sendSimpleZap(
                    amount: amount,
                    to: article?.author ?? "",
                    comment: "Streaming sats for audio content"
                )
            }
        } catch {
            // Handle error silently
        }
    }
}
// Profile metadata for Lightning address
private struct ProfileMetadata: Codable {
    let lud06: String?
    let lud16: String?
}
// Audio particle for visual effects
struct AudioParticle: Identifiable {
    let id = UUID()
    var x: CGFloat
    var y: CGFloat
    let size: CGFloat
    let color: Color
    let speed: CGFloat
}
struct AudioParticleView: View {
    let particle: AudioParticle
    let isPlaying: Bool
    @State private var offset: CGSize = .zero
    @State private var opacity: Double = 0.8
    var body: some View {
        Circle()
            .fill(
                RadialGradient(
                    colors: [
                        particle.color.opacity(opacity),
                        particle.color.opacity(0)
                    ],
                    center: .center,
                    startRadius: 0,
                    endRadius: particle.size
                )
            )
            .frame(width: particle.size * 2, height: particle.size * 2)
            .offset(x: particle.x + offset.width, y: particle.y + offset.height)
            .blur(radius: isPlaying ? 2 : 4)
            .onAppear {
                if isPlaying {
                    animateParticle()
                }
            }
            .onChange(of: isPlaying) { _, playing in
                if playing {
                    animateParticle()
                } else {
                    withAnimation(.easeOut(duration: 0.5)) {
                        offset = .zero
                        opacity = 0.8
                    }
                }
            }
    }
    private func animateParticle() {
        withAnimation(
            .easeInOut(duration: Double.random(in: 3...6))
            .repeatForever(autoreverses: true)
        ) {
            offset = CGSize(
                width: CGFloat.random(in: -particle.speed...particle.speed),
                height: CGFloat.random(in: -particle.speed...particle.speed)
            )
            opacity = Double.random(in: 0.3...0.8)
        }
    }
}
// Audio player manager
@MainActor
class AudioPlayerManager: ObservableObject {
    @Published var isPlaying = false
    @Published var currentTime: TimeInterval = 0
    @Published var duration: TimeInterval = 100
    @Published var progress: CGFloat = 0
    @Published var speechRate: Float = 1.0
    private let synthesizer = AVSpeechSynthesizer()
    private var utterance: AVSpeechUtterance?
    private var timer: Timer?
    func setupSpeech(for highlight: HighlightEvent) {
        utterance = AVSpeechUtterance(string: highlight.content)
        utterance?.rate = speechRate
        utterance?.pitchMultiplier = 1.0
        utterance?.volume = 0.9
        // Estimate duration (rough approximation)
        let wordsPerMinute: Float = 150
        let wordCount = Float(highlight.content.split(separator: " ").count)
        duration = TimeInterval((wordCount / wordsPerMinute) * 60 / speechRate)
    }
    func togglePlayPause() {
        if isPlaying {
            pause()
        } else {
            play()
        }
    }
    func play() {
        guard let utterance = utterance else { return }
        if synthesizer.isPaused {
            synthesizer.continueSpeaking()
        } else {
            synthesizer.speak(utterance)
            startTimer()
        }
        isPlaying = true
    }
    func pause() {
        synthesizer.pauseSpeaking(at: .immediate)
        stopTimer()
        isPlaying = false
    }
    func stop() {
        synthesizer.stopSpeaking(at: .immediate)
        stopTimer()
        isPlaying = false
        currentTime = 0
        progress = 0
    }
    func seek(to progress: CGFloat) {
        self.progress = progress
        currentTime = duration * TimeInterval(progress)
        // Note: AVSpeechSynthesizer doesn't support seeking, this is for UI only
    }
    func setSpeechRate(_ rate: Float) {
        speechRate = rate
        utterance?.rate = rate
        // Update duration estimate
        if let text = utterance?.speechString {
            let wordsPerMinute: Float = 150
            let wordCount = Float(text.split(separator: " ").count)
            duration = TimeInterval((wordCount / wordsPerMinute) * 60 / rate)
        }
    }
    func setVoice(_ voice: AVSpeechSynthesisVoice) {
        utterance?.voice = voice
    }
    private func startTimer() {
        timer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { _ in
            Task { @MainActor in
                self.updateProgress()
            }
        }
    }
    private func stopTimer() {
        timer?.invalidate()
        timer = nil
    }
    @MainActor
    private func updateProgress() {
        currentTime += 0.1
        progress = CGFloat(currentTime / duration)
        if progress >= 1.0 {
            stop()
        }
    }
}
</file>

<file path="Sources/Highlighter/Views/Auth/ModernAuthenticationView.swift">
import SwiftUI
import NDKSwift
struct ModernAuthenticationView: View {
    @EnvironmentObject var appState: AppState
    @State private var showImportSheet = false
    @State private var privateKey = ""
    @State private var viewAppeared = false
    var body: some View {
        NavigationStack {
            ZStack {
                // Clean background
                DesignSystem.Colors.background
                    .ignoresSafeArea()
                VStack(spacing: .ds.xxl) {
                    Spacer()
                    // Logo and branding
                    VStack(spacing: .ds.large) {
                        Image(systemName: "highlighter")
                            .font(.system(size: 64, weight: .light))
                            .foregroundColor(.ds.primary)
                            .scaleEffect(viewAppeared ? 1 : 0.5)
                            .opacity(viewAppeared ? 1 : 0)
                            .animation(DesignSystem.Animation.springSmooth.delay(0.1), value: viewAppeared)
                        VStack(spacing: .ds.small) {
                            Text("Highlighter")
                                .font(.ds.largeTitle)
                                .foregroundColor(.ds.text)
                            Text("Save and share the best ideas")
                                .font(.ds.body)
                                .foregroundColor(.ds.textSecondary)
                        }
                        .opacity(viewAppeared ? 1 : 0)
                        .offset(y: viewAppeared ? 0 : 20)
                        .animation(DesignSystem.Animation.smooth.delay(0.2), value: viewAppeared)
                    }
                    Spacer()
                    // Action buttons
                    VStack(spacing: .ds.base) {
                        Button(action: createAccount) {
                            HStack {
                                Image(systemName: "sparkles")
                                Text("Create Account")
                            }
                            .frame(maxWidth: .infinity)
                        }
                        .unifiedPrimaryButton()
                        Button(action: { showImportSheet = true }) {
                            Text("I have an account")
                                .frame(maxWidth: .infinity)
                        }
                        .unifiedSecondaryButton()
                    }
                    .padding(.horizontal, .ds.xxl)
                    .opacity(viewAppeared ? 1 : 0)
                    .offset(y: viewAppeared ? 0 : 20)
                    .animation(DesignSystem.Animation.smooth.delay(0.3), value: viewAppeared)
                    Spacer()
                        .frame(height: .ds.huge)
                }
            }
            .sheet(isPresented: $showImportSheet) {
                ModernImportSheet(privateKey: $privateKey, onImport: importAccount)
            }
            .onAppear {
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                    viewAppeared = true
                }
            }
        }
    }
    private func createAccount() {
        HapticManager.shared.impact(HapticManager.ImpactStyle.medium)
        Task {
            do {
                try await appState.createAccount()
                HapticManager.shared.notification(.success)
            } catch {
                HapticManager.shared.notification(.error)
            }
        }
    }
    private func importAccount() {
        guard !privateKey.isEmpty else { return }
        HapticManager.shared.impact(HapticManager.ImpactStyle.medium)
        Task {
            do {
                try await appState.importAccount(nsec: privateKey)
                await MainActor.run {
                    showImportSheet = false
                    privateKey = ""
                    HapticManager.shared.notification(.success)
                }
            } catch {
                await MainActor.run {
                    HapticManager.shared.notification(.error)
                }
            }
        }
    }
}
struct ModernImportSheet: View {
    @Binding var privateKey: String
    let onImport: () -> Void
    @Environment(\.dismiss) var dismiss
    @FocusState private var isTextFieldFocused: Bool
    var body: some View {
        NavigationStack {
            VStack(spacing: .ds.large) {
                VStack(alignment: .leading, spacing: .ds.small) {
                    Text("Your private key")
                        .font(.ds.footnoteMedium)
                        .foregroundColor(.ds.textSecondary)
                    SecureField("nsec1...", text: $privateKey)
                        .font(.ds.body)
                        .modernTextField()
                        .focused($isTextFieldFocused)
                        .textContentType(.password)
                        .autocapitalization(.none)
                        .disableAutocorrection(true)
                }
                VStack(spacing: .ds.small) {
                    Text("Your private key is stored locally and never leaves your device")
                        .font(.ds.caption)
                        .foregroundColor(.ds.textSecondary)
                        .multilineTextAlignment(.center)
                    Label("Keep this secret", systemImage: "lock.fill")
                        .font(.ds.captionMedium)
                        .foregroundColor(.ds.warning)
                }
                .padding(.top, .ds.small)
                Spacer()
                VStack(spacing: .ds.base) {
                    Button(action: onImport) {
                        Text("Import Account")
                            .frame(maxWidth: .infinity)
                    }
                    .unifiedPrimaryButton()
                    .disabled(privateKey.isEmpty)
                    Button("Cancel") {
                        dismiss()
                    }
                    .unifiedSecondaryButton()
                }
            }
            .padding(.ds.large)
            .navigationTitle("Import Account")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                    .font(.ds.body)
                }
            }
        }
        .onAppear {
            isTextFieldFocused = true
        }
    }
}
</file>

<file path="Sources/Highlighter/Views/Components/EnhancedAsyncProfileImage.swift">
import SwiftUI
import NDKSwift
// MARK: - Enhanced Async Profile Image with Blur Hash Support
struct EnhancedAsyncProfileImage: View {
    let pubkey: String
    let size: CGFloat
    @EnvironmentObject var appState: AppState
    @State private var profile: NDKUserProfile?
    @State private var imageState: ImageLoadState = .loading
    @State private var blurHashImage: Image?
    @State private var profileImage: Image?
    @State private var shimmerOffset: CGFloat = -200
    @State private var pulseAnimation = false
    enum ImageLoadState: Equatable {
        case loading
        case loaded(Image)
        case failed
        case placeholder
        static func == (lhs: ImageLoadState, rhs: ImageLoadState) -> Bool {
            switch (lhs, rhs) {
            case (.loading, .loading), (.failed, .failed), (.placeholder, .placeholder):
                return true
            case (.loaded(_), .loaded(_)):
                return true
            default:
                return false
            }
        }
    }
    var body: some View {
        ZStack {
            // Background gradient placeholder
            Circle()
                .fill(gradientForPubkey())
                .overlay(
                    // Shimmer effect while loading
                    Circle()
                        .fill(
                            LinearGradient(
                                colors: [
                                    Color.clear,
                                    Color.white.opacity(0.3),
                                    Color.clear
                                ],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .offset(x: shimmerOffset)
                        .opacity(imageState == .loading ? 1 : 0)
                )
                .mask(Circle())
            // Content based on state
            switch imageState {
            case .loading:
                // Show blurhash or initials while loading
                if let blurHashImage = blurHashImage {
                    blurHashImage
                        .resizable()
                        .scaledToFill()
                        .frame(width: size, height: size)
                        .clipShape(Circle())
                        .blur(radius: 10)
                        .transition(.opacity)
                } else {
                    initialsView
                        .scaleEffect(pulseAnimation ? 1.05 : 0.95)
                        .opacity(pulseAnimation ? 0.8 : 1)
                }
            case .loaded(let image):
                image
                    .resizable()
                    .scaledToFill()
                    .frame(width: size, height: size)
                    .clipShape(Circle())
                    .transition(.asymmetric(
                        insertion: .scale(scale: 1.1).combined(with: .opacity),
                        removal: .scale(scale: 0.9).combined(with: .opacity)
                    ))
            case .failed, .placeholder:
                initialsView
            }
            // Premium glass overlay for depth
            Circle()
                .fill(
                    LinearGradient(
                        colors: [
                            Color.white.opacity(0.2),
                            Color.clear,
                            Color.black.opacity(0.1)
                        ],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .blendMode(.overlay)
            // Border with gradient
            Circle()
                .strokeBorder(
                    LinearGradient(
                        colors: borderColors(),
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    ),
                    lineWidth: borderWidth()
                )
        }
        .frame(width: size, height: size)
        .shadow(color: shadowColor(), radius: shadowRadius(), y: 2)
        .task {
            await loadProfile()
        }
        .onAppear {
            startAnimations()
        }
    }
    // MARK: - Subviews
    private var initialsView: some View {
        Text(PubkeyFormatter.formatForAvatar(pubkey))
            .font(.system(size: size * 0.4, weight: .bold, design: .rounded))
            .foregroundColor(.white)
            .shadow(color: .black.opacity(0.2), radius: 2, x: 0, y: 1)
    }
    // MARK: - Helper Methods
    private func gradientForPubkey() -> LinearGradient {
        // Generate consistent gradient based on pubkey
        let hash = pubkey.hashValue
        let hue1 = Double(abs(hash % 360)) / 360.0
        let hue2 = (hue1 + 0.1).truncatingRemainder(dividingBy: 1.0)
        return LinearGradient(
            colors: [
                Color(hue: hue1, saturation: 0.7, brightness: 0.8),
                Color(hue: hue2, saturation: 0.6, brightness: 0.9)
            ],
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
    }
    private func borderColors() -> [Color] {
        switch imageState {
        case .loaded:
            return [
                Color.white.opacity(0.5),
                Color.white.opacity(0.2)
            ]
        case .loading:
            return [
                DesignSystem.Colors.primary.opacity(0.6),
                DesignSystem.Colors.secondary.opacity(0.4)
            ]
        default:
            return [
                Color.white.opacity(0.3),
                Color.white.opacity(0.1)
            ]
        }
    }
    private func borderWidth() -> CGFloat {
        size >= 60 ? 2 : 1
    }
    private func shadowColor() -> Color {
        switch imageState {
        case .loaded:
            return Color.black.opacity(0.2)
        case .loading:
            return DesignSystem.Colors.primary.opacity(0.3)
        default:
            return Color.black.opacity(0.1)
        }
    }
    private func shadowRadius() -> CGFloat {
        size >= 60 ? 6 : 3
    }
    // MARK: - Data Loading
    private func loadProfile() async {
        guard let ndk = appState.ndk else {
            imageState = .placeholder
            return
        }
        // Subscribe to profile updates
        for await profile in await ndk.profileManager.observe(for: pubkey, maxAge: TimeConstants.hour) {
            await MainActor.run {
                self.profile = profile
            }
            // Load actual image
            if let picture = profile?.picture, let url = URL(string: picture) {
                await loadImage(from: url)
            } else {
                await MainActor.run {
                    imageState = .placeholder
                }
            }
            break // Only need current value
        }
    }
    // BlurHash support can be added later when NDKUserProfile includes it
    private func loadImage(from url: URL) async {
        do {
            let (data, _) = try await URLSession.shared.data(from: url)
            if let uiImage = UIImage(data: data) {
                await MainActor.run {
                    withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                        profileImage = Image(uiImage: uiImage)
                        imageState = .loaded(Image(uiImage: uiImage))
                    }
                }
            } else {
                await MainActor.run {
                    imageState = .failed
                }
            }
        } catch {
            await MainActor.run {
                imageState = .failed
            }
        }
    }
    // MARK: - Animations
    private func startAnimations() {
        // Shimmer animation
        withAnimation(
            .linear(duration: 1.5)
            .repeatForever(autoreverses: false)
        ) {
            shimmerOffset = 200
        }
        // Pulse animation for placeholder
        withAnimation(
            .easeInOut(duration: 1.2)
            .repeatForever(autoreverses: true)
        ) {
            pulseAnimation = true
        }
    }
}
// MARK: - Convenience Modifiers
extension View {
    func profileImageStyle(size: CGFloat) -> some View {
        self
            .frame(width: size, height: size)
            .clipShape(Circle())
            .overlay(
                Circle()
                    .stroke(Color.white.opacity(0.2), lineWidth: 1)
            )
            .shadow(color: Color.black.opacity(0.1), radius: 3, y: 2)
    }
}
// MARK: - Static Profile Image Grid (for discovery)
struct ProfileImageGrid: View {
    let pubkeys: [String]
    let size: CGFloat
    let maxCount: Int
    init(pubkeys: [String], size: CGFloat = 32, maxCount: Int = 4) {
        self.pubkeys = pubkeys
        self.size = size
        self.maxCount = maxCount
    }
    var body: some View {
        HStack(spacing: -size * 0.3) {
            ForEach(Array(pubkeys.prefix(maxCount).enumerated()), id: \.element) { index, pubkey in
                EnhancedAsyncProfileImage(pubkey: pubkey, size: size)
                    .zIndex(Double(maxCount - index))
                    .transition(.asymmetric(
                        insertion: .scale(scale: 0.8).combined(with: .opacity),
                        removal: .scale(scale: 1.2).combined(with: .opacity)
                    ))
                    .animation(
                        .spring(response: 0.4, dampingFraction: 0.7)
                        .delay(Double(index) * 0.05),
                        value: pubkeys
                    )
            }
            if pubkeys.count > maxCount {
                Circle()
                    .fill(DesignSystem.Colors.surfaceSecondary)
                    .frame(width: size, height: size)
                    .overlay(
                        Text("+\(pubkeys.count - maxCount)")
                            .font(.system(size: size * 0.35, weight: .semibold))
                            .foregroundColor(DesignSystem.Colors.textSecondary)
                    )
                    .overlay(
                        Circle()
                            .stroke(Color.white, lineWidth: 2)
                    )
                    .shadow(color: Color.black.opacity(0.1), radius: 3, y: 2)
                    .zIndex(0)
            }
        }
    }
}
// MARK: - Preview
#Preview {
    VStack(spacing: 40) {
        // Different sizes
        HStack(spacing: 20) {
            EnhancedAsyncProfileImage(pubkey: "test1", size: 80)
            EnhancedAsyncProfileImage(pubkey: "test2", size: 60)
            EnhancedAsyncProfileImage(pubkey: "test3", size: 40)
            EnhancedAsyncProfileImage(pubkey: "test4", size: 32)
        }
        // Profile grid
        ProfileImageGrid(
            pubkeys: ["test1", "test2", "test3", "test4", "test5"],
            size: 40
        )
    }
    .padding()
    .background(DesignSystem.Colors.background)
    .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Views/Components/ImmersiveGradientBackground.swift">
import SwiftUI
struct ImmersiveGradientBackground: View {
    @Binding var animate: Bool
    @State private var gradientOffset: CGFloat = 0
    var body: some View {
        ZStack {
            // Base gradient
            LinearGradient(
                colors: [
                    DesignSystem.Colors.primary.opacity(0.8),
                    DesignSystem.Colors.secondary.opacity(0.6),
                    DesignSystem.Colors.primary.opacity(0.4)
                ],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            // Animated overlay gradient
            LinearGradient(
                colors: [
                    DesignSystem.Colors.secondary.opacity(0.3),
                    DesignSystem.Colors.primary.opacity(0.5),
                    Color.purple.opacity(0.3)
                ],
                startPoint: .top,
                endPoint: .bottom
            )
            .offset(y: animate ? gradientOffset : -gradientOffset)
            .blendMode(.overlay)
            // Mesh gradient effect (simulated with radial gradients)
            ZStack {
                RadialGradient(
                    colors: [
                        DesignSystem.Colors.primary.opacity(0.4),
                        Color.clear
                    ],
                    center: .topLeading,
                    startRadius: 50,
                    endRadius: 400
                )
                .offset(x: animate ? 50 : -50, y: animate ? 50 : -50)
                RadialGradient(
                    colors: [
                        DesignSystem.Colors.secondary.opacity(0.3),
                        Color.clear
                    ],
                    center: .bottomTrailing,
                    startRadius: 50,
                    endRadius: 400
                )
                .offset(x: animate ? -50 : 50, y: animate ? -50 : 50)
                RadialGradient(
                    colors: [
                        Color.purple.opacity(0.2),
                        Color.clear
                    ],
                    center: .center,
                    startRadius: 100,
                    endRadius: 300
                )
                .scaleEffect(animate ? 1.2 : 0.8)
            }
            .blendMode(.screen)
            // Subtle noise texture overlay
            Rectangle()
                .fill(
                    LinearGradient(
                        colors: [
                            Color.white.opacity(0.05),
                            Color.black.opacity(0.05)
                        ],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .blendMode(.overlay)
        }
        .ignoresSafeArea()
        .onAppear {
            withAnimation(.easeInOut(duration: 20).repeatForever(autoreverses: true)) {
                gradientOffset = 200
            }
        }
    }
}
</file>

<file path="Sources/Highlighter/Views/Components/MeshGradientBackground.swift">
import SwiftUI
struct MeshGradientBackground: View {
    @State private var gradientPhase: Double = 0
    @State private var animationTimer: Timer?
    @Environment(\.colorScheme) var colorScheme
    var body: some View {
        TimelineView(.animation) { (timeline: TimelineViewDefaultContext) in
            Canvas { context, size in
                let time = timeline.date.timeIntervalSinceReferenceDate
                // Create mesh points
                let rows = 4
                let cols = 4
                let spacing = size.width / CGFloat(cols - 1)
                for row in 0..<rows-1 {
                    for col in 0..<cols-1 {
                        let topLeft = meshPoint(row: row, col: col, spacing: spacing, time: time)
                        let topRight = meshPoint(row: row, col: col + 1, spacing: spacing, time: time)
                        let bottomLeft = meshPoint(row: row + 1, col: col, spacing: spacing, time: time)
                        let bottomRight = meshPoint(row: row + 1, col: col + 1, spacing: spacing, time: time)
                        let path = Path { path in
                            path.move(to: topLeft)
                            path.addCurve(
                                to: topRight,
                                control1: CGPoint(x: topLeft.x + spacing/3, y: topLeft.y),
                                control2: CGPoint(x: topRight.x - spacing/3, y: topRight.y)
                            )
                            path.addCurve(
                                to: bottomRight,
                                control1: CGPoint(x: topRight.x, y: topRight.y + spacing/3),
                                control2: CGPoint(x: bottomRight.x, y: bottomRight.y - spacing/3)
                            )
                            path.addCurve(
                                to: bottomLeft,
                                control1: CGPoint(x: bottomRight.x - spacing/3, y: bottomRight.y),
                                control2: CGPoint(x: bottomLeft.x + spacing/3, y: bottomLeft.y)
                            )
                            path.addCurve(
                                to: topLeft,
                                control1: CGPoint(x: bottomLeft.x, y: bottomLeft.y - spacing/3),
                                control2: CGPoint(x: topLeft.x, y: topLeft.y + spacing/3)
                            )
                        }
                        let colors = gradientColors(for: row, col: col, time: time)
                        let gradient = Gradient(colors: colors)
                        context.fill(path, with: .linearGradient(
                            gradient,
                            startPoint: CGPoint(x: 0, y: 0),
                            endPoint: CGPoint(x: 1, y: 1)
                        ))
                    }
                }
            }
        }
        .blur(radius: 60)
        .opacity(colorScheme == .dark ? 0.5 : 0.3)
    }
    private func meshPoint(row: Int, col: Int, spacing: CGFloat, time: TimeInterval) -> CGPoint {
        let baseX = CGFloat(col) * spacing
        let baseY = CGFloat(row) * spacing
        // Add wave motion
        let waveX = sin(time * 0.5 + Double(row) * 0.3) * 20
        let waveY = cos(time * 0.4 + Double(col) * 0.2) * 20
        return CGPoint(x: baseX + waveX, y: baseY + waveY)
    }
    private func gradientColors(for row: Int, col: Int, time: TimeInterval) -> [Color] {
        let phase = time * 0.2 + Double(row + col) * 0.5
        let colors: [[Color]] = [
            [.purple, .blue],
            [.orange, .pink],
            [.green, .blue],
            [.purple, .orange]
        ]
        let colorIndex = (row + col) % colors.count
        let baseColors = colors[colorIndex]
        return baseColors.map { color in
            color.opacity(0.3 + sin(phase) * 0.2)
        }
    }
}
#Preview {
    ZStack {
        Color.black
        MeshGradientBackground()
    }
}
</file>

<file path="Sources/Highlighter/Views/Components/ModernFormComponents.swift">
import SwiftUI
// MARK: - Modern Form Components
/// Modern text field style with consistent design
struct ModernTextFieldStyle: ViewModifier {
    var isValid: Bool = true
    var isSecure: Bool = false
    @FocusState private var isFocused: Bool
    func body(content: Content) -> some View {
        content
            .padding(.vertical, DesignSystem.Spacing.base)
            .padding(.horizontal, DesignSystem.Spacing.medium)
            .background(
                RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.medium, style: .continuous)
                    .fill(DesignSystem.Colors.surface)
                    .overlay(
                        RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.medium, style: .continuous)
                            .stroke(borderColor, lineWidth: borderWidth)
                    )
            )
            .shadow(
                color: shadowColor,
                radius: 2,
                x: 0,
                y: 1
            )
            .animation(DesignSystem.Animation.quick, value: isFocused)
            .animation(DesignSystem.Animation.quick, value: isValid)
    }
    private var borderColor: Color {
        if !isValid {
            return DesignSystem.Colors.error
        } else if isFocused {
            return DesignSystem.Colors.primary
        } else {
            return DesignSystem.Colors.border
        }
    }
    private var borderWidth: CGFloat {
        if !isValid || isFocused {
            return 2.0
        } else {
            return 1.0
        }
    }
    private var shadowColor: Color {
        if !isValid {
            return DesignSystem.Colors.error.opacity(0.2)
        } else if isFocused {
            return DesignSystem.Colors.primary.opacity(0.1)
        } else {
            return DesignSystem.Shadow.subtle.color
        }
    }
}
/// Modern form section with consistent styling
struct ModernFormSection<Content: View>: View {
    let title: String?
    let subtitle: String?
    let content: Content
    init(
        title: String? = nil,
        subtitle: String? = nil,
        @ViewBuilder content: () -> Content
    ) {
        self.title = title
        self.subtitle = subtitle
        self.content = content()
    }
    var body: some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.small) {
            if let title = title {
                VStack(alignment: .leading, spacing: DesignSystem.Spacing.micro) {
                    Text(title)
                        .font(DesignSystem.Typography.footnoteMedium)
                        .foregroundColor(DesignSystem.Colors.text)
                    if let subtitle = subtitle {
                        Text(subtitle)
                            .font(DesignSystem.Typography.caption)
                            .foregroundColor(DesignSystem.Colors.textSecondary)
                    }
                }
            }
            content
        }
    }
}
/// Modern checkbox with custom styling
struct ModernCheckbox: View {
    @Binding var isChecked: Bool
    let title: String
    let subtitle: String?
    init(_ title: String, isChecked: Binding<Bool>, subtitle: String? = nil) {
        self.title = title
        self._isChecked = isChecked
        self.subtitle = subtitle
    }
    var body: some View {
        Button {
            withAnimation(DesignSystem.Animation.quick) {
                isChecked.toggle()
            }
            HapticManager.shared.triggerSelection()
        } label: {
            HStack(alignment: .top, spacing: DesignSystem.Spacing.base) {
                // Checkbox
                ZStack {
                    RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.micro, style: .continuous)
                        .stroke(
                            isChecked ? DesignSystem.Colors.primary : DesignSystem.Colors.border,
                            lineWidth: isChecked ? 2 : 1
                        )
                        .frame(width: 20, height: 20)
                    if isChecked {
                        RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.micro, style: .continuous)
                            .fill(DesignSystem.Colors.primary)
                            .frame(width: 20, height: 20)
                            .overlay(
                                Image(systemName: "checkmark")
                                    .font(.system(size: 12, weight: .bold))
                                    .foregroundColor(.white)
                            )
                            .transition(.scale.combined(with: .opacity))
                    }
                }
                // Content
                VStack(alignment: .leading, spacing: DesignSystem.Spacing.micro) {
                    Text(title)
                        .font(DesignSystem.Typography.body)
                        .foregroundColor(DesignSystem.Colors.text)
                        .multilineTextAlignment(.leading)
                    if let subtitle = subtitle {
                        Text(subtitle)
                            .font(DesignSystem.Typography.caption)
                            .foregroundColor(DesignSystem.Colors.textSecondary)
                            .multilineTextAlignment(.leading)
                    }
                }
                Spacer()
            }
        }
        .buttonStyle(PlainButtonStyle())
    }
}
/// Modern toggle switch with custom styling
struct ModernToggle: View {
    @Binding var isOn: Bool
    let title: String
    let subtitle: String?
    init(_ title: String, isOn: Binding<Bool>, subtitle: String? = nil) {
        self.title = title
        self._isOn = isOn
        self.subtitle = subtitle
    }
    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: DesignSystem.Spacing.micro) {
                Text(title)
                    .font(DesignSystem.Typography.body)
                    .foregroundColor(DesignSystem.Colors.text)
                if let subtitle = subtitle {
                    Text(subtitle)
                        .font(DesignSystem.Typography.caption)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                }
            }
            Spacer()
            Toggle("", isOn: $isOn)
                .labelsHidden()
                .toggleStyle(ModernToggleStyle())
        }
    }
}
/// Custom toggle style matching the design system
struct ModernToggleStyle: ToggleStyle {
    func makeBody(configuration: Configuration) -> some View {
        Button {
            withAnimation(DesignSystem.Animation.springSnappy) {
                configuration.isOn.toggle()
            }
            HapticManager.shared.triggerSelection()
        } label: {
            RoundedRectangle(cornerRadius: 16, style: .continuous)
                .fill(
                    configuration.isOn
                    ? DesignSystem.Colors.primary
                    : DesignSystem.Colors.surfaceSecondary
                )
                .frame(width: 50, height: 30)
                .overlay(
                    Circle()
                        .fill(Color.white)
                        .frame(width: 26, height: 26)
                        .shadow(color: .black.opacity(0.1), radius: 2, x: 0, y: 1)
                        .offset(x: configuration.isOn ? 10 : -10)
                        .animation(DesignSystem.Animation.springSnappy, value: configuration.isOn)
                )
        }
        .buttonStyle(PlainButtonStyle())
    }
}
/// Modern picker with custom styling
struct ModernPicker<SelectionValue: Hashable, Content: View>: View {
    let title: String
    @Binding var selection: SelectionValue
    let content: Content
    init(
        _ title: String,
        selection: Binding<SelectionValue>,
        @ViewBuilder content: () -> Content
    ) {
        self.title = title
        self._selection = selection
        self.content = content()
    }
    var body: some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.small) {
            Text(title)
                .font(DesignSystem.Typography.footnoteMedium)
                .foregroundColor(DesignSystem.Colors.text)
            Picker(title, selection: $selection) {
                content
            }
            .pickerStyle(SegmentedPickerStyle())
        }
    }
}
/// Modern stepper with custom styling
struct ModernStepper: View {
    @Binding var value: Int
    let range: ClosedRange<Int>
    let title: String
    let subtitle: String?
    init(
        _ title: String,
        value: Binding<Int>,
        in range: ClosedRange<Int>,
        subtitle: String? = nil
    ) {
        self.title = title
        self._value = value
        self.range = range
        self.subtitle = subtitle
    }
    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: DesignSystem.Spacing.micro) {
                Text(title)
                    .font(DesignSystem.Typography.body)
                    .foregroundColor(DesignSystem.Colors.text)
                if let subtitle = subtitle {
                    Text(subtitle)
                        .font(DesignSystem.Typography.caption)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                }
            }
            Spacer()
            HStack(spacing: DesignSystem.Spacing.small) {
                Button {
                    if value > range.lowerBound {
                        withAnimation(DesignSystem.Animation.quick) {
                            value -= 1
                        }
                        HapticManager.shared.impact(HapticManager.ImpactStyle.light)
                    }
                } label: {
                    Image(systemName: "minus")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(
                            value > range.lowerBound
                            ? DesignSystem.Colors.primary
                            : DesignSystem.Colors.textTertiary
                        )
                        .frame(width: 32, height: 32)
                        .background(
                            Circle()
                                .fill(DesignSystem.Colors.surfaceSecondary)
                                .opacity(value > range.lowerBound ? 1 : 0.5)
                        )
                }
                .disabled(value <= range.lowerBound)
                Text("\(value)")
                    .font(DesignSystem.Typography.bodyMedium)
                    .foregroundColor(DesignSystem.Colors.text)
                    .frame(minWidth: 30)
                Button {
                    if value < range.upperBound {
                        withAnimation(DesignSystem.Animation.quick) {
                            value += 1
                        }
                        HapticManager.shared.impact(HapticManager.ImpactStyle.light)
                    }
                } label: {
                    Image(systemName: "plus")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(
                            value < range.upperBound
                            ? DesignSystem.Colors.primary
                            : DesignSystem.Colors.textTertiary
                        )
                        .frame(width: 32, height: 32)
                        .background(
                            Circle()
                                .fill(DesignSystem.Colors.surfaceSecondary)
                                .opacity(value < range.upperBound ? 1 : 0.5)
                        )
                }
                .disabled(value >= range.upperBound)
            }
        }
    }
}
// MARK: - View Extensions
extension View {
    /// Apply modern text field styling
    func modernTextField(isValid: Bool = true, isSecure: Bool = false) -> some View {
        self.modifier(ModernTextFieldStyle(isValid: isValid, isSecure: isSecure))
    }
    /// Wrap in a modern form section
    func modernFormSection(title: String? = nil, subtitle: String? = nil) -> some View {
        ModernFormSection(title: title, subtitle: subtitle) {
            self
        }
    }
}
// MARK: - Preview
#Preview("Form Components") {
    NavigationStack {
        ScrollView {
            VStack(spacing: DesignSystem.Spacing.large) {
                ModernFormSection(title: "Text Fields", subtitle: "Various text input styles") {
                    VStack(spacing: DesignSystem.Spacing.medium) {
                        TextField("Standard text field", text: .constant(""))
                            .modernTextField()
                        TextField("Invalid text field", text: .constant(""))
                            .modernTextField(isValid: false)
                        SecureField("Secure field", text: .constant(""))
                            .modernTextField(isSecure: true)
                    }
                }
                ModernFormSection(title: "Checkboxes") {
                    VStack(alignment: .leading, spacing: DesignSystem.Spacing.small) {
                        ModernCheckbox(
                            "Enable notifications",
                            isChecked: .constant(true),
                            subtitle: "Get notified about new highlights"
                        )
                        ModernCheckbox(
                            "Auto-save highlights",
                            isChecked: .constant(false)
                        )
                    }
                }
                ModernFormSection(title: "Toggles") {
                    VStack(spacing: DesignSystem.Spacing.medium) {
                        ModernToggle(
                            "Dark mode",
                            isOn: .constant(false),
                            subtitle: "Switch to dark appearance"
                        )
                        ModernToggle(
                            "Haptic feedback",
                            isOn: .constant(true)
                        )
                    }
                }
                ModernFormSection(title: "Stepper") {
                    ModernStepper(
                        "Items per page",
                        value: .constant(10),
                        in: 5...50,
                        subtitle: "Number of items to show"
                    )
                }
            }
            .padding(DesignSystem.Spacing.large)
        }
        .background(DesignSystem.Colors.background)
        .navigationTitle("Form Components")
    }
}
</file>

<file path="Sources/Highlighter/Views/Components/ModernStateViews.swift">
import SwiftUI
// MARK: - Modern State Views
/// Modern loading view with elegant animations
struct ModernLoadingView: View {
    let message: String?
    let style: LoadingStyle
    @State private var animateGradient = false
    @State private var rotationAngle: Double = 0
    enum LoadingStyle {
        case dots
        case spinner
        case skeleton
        case pulse
        var animation: Animation {
            switch self {
            case .dots:
                return .easeInOut(duration: 1.2).repeatForever(autoreverses: true)
            case .spinner:
                return .linear(duration: 1).repeatForever(autoreverses: false)
            case .skeleton:
                return .linear(duration: 1.5).repeatForever(autoreverses: false)
            case .pulse:
                return .easeInOut(duration: 1.5).repeatForever(autoreverses: true)
            }
        }
    }
    init(message: String? = nil, style: LoadingStyle = .dots) {
        self.message = message
        self.style = style
    }
    var body: some View {
        VStack(spacing: DesignSystem.Spacing.medium) {
            loadingIndicator
            if let message = message {
                Text(message)
                    .font(DesignSystem.Typography.body)
                    .foregroundColor(DesignSystem.Colors.textSecondary)
                    .multilineTextAlignment(.center)
            }
        }
        .onAppear {
            startAnimation()
        }
    }
    @ViewBuilder
    private var loadingIndicator: some View {
        switch style {
        case .dots:
            dotsIndicator
        case .spinner:
            spinnerIndicator
        case .skeleton:
            skeletonIndicator
        case .pulse:
            pulseIndicator
        }
    }
    private var dotsIndicator: some View {
        HStack(spacing: DesignSystem.Spacing.small) {
            ForEach(0..<3, id: \.self) { index in
                Circle()
                    .fill(
                        LinearGradient(
                            colors: [
                                DesignSystem.Colors.primary,
                                DesignSystem.Colors.primary.opacity(0.6)
                            ],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: 8, height: 8)
                    .scaleEffect(animateGradient ? 1.3 : 0.7)
                    .opacity(animateGradient ? 1.0 : 0.5)
                    .shadow(
                        color: DesignSystem.Colors.primary.opacity(0.3),
                        radius: animateGradient ? 3 : 1,
                        x: 0,
                        y: 1
                    )
                    .animation(
                        style.animation.delay(Double(index) * 0.15),
                        value: animateGradient
                    )
            }
        }
    }
    private var spinnerIndicator: some View {
        ZStack {
            // Background circle for depth
            Circle()
                .stroke(
                    DesignSystem.Colors.primary.opacity(0.1),
                    style: StrokeStyle(lineWidth: 3, lineCap: .round)
                )
            // Animated spinner
            Circle()
                .trim(from: 0, to: 0.7)
                .stroke(
                    AngularGradient(
                        colors: [
                            DesignSystem.Colors.primary,
                            DesignSystem.Colors.secondary,
                            DesignSystem.Colors.primary.opacity(0.2)
                        ],
                        center: .center
                    ),
                    style: StrokeStyle(lineWidth: 3, lineCap: .round)
                )
                .rotationEffect(.degrees(rotationAngle))
                .animation(style.animation, value: rotationAngle)
        }
        .frame(width: 32, height: 32)
        .shadow(
            color: DesignSystem.Colors.primary.opacity(0.2),
            radius: 4,
            x: 0,
            y: 2
        )
    }
    private var skeletonIndicator: some View {
        VStack(spacing: DesignSystem.Spacing.small) {
            ForEach(0..<3, id: \.self) { _ in
                RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.small)
                    .fill(
                        LinearGradient(
                            colors: [
                                DesignSystem.Colors.surfaceSecondary,
                                DesignSystem.Colors.surfaceSecondary.opacity(0.6),
                                DesignSystem.Colors.surfaceSecondary
                            ],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .frame(height: 12)
                    .overlay(
                        LinearGradient(
                            colors: [
                                Color.clear,
                                Color.white.opacity(0.4),
                                Color.clear
                            ],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                        .offset(x: animateGradient ? 200 : -200)
                        .animation(style.animation, value: animateGradient)
                    )
                    .clipped()
            }
        }
        .frame(width: 150)
    }
    private var pulseIndicator: some View {
        ZStack {
            // Outer pulse ring
            Circle()
                .fill(
                    RadialGradient(
                        colors: [
                            DesignSystem.Colors.primary.opacity(0.1),
                            DesignSystem.Colors.primary.opacity(0.3),
                            Color.clear
                        ],
                        center: .center,
                        startRadius: 5,
                        endRadius: 25
                    )
                )
                .frame(width: 50, height: 50)
                .scaleEffect(animateGradient ? 1.2 : 0.8)
                .opacity(animateGradient ? 0.3 : 0.8)
                .animation(style.animation, value: animateGradient)
            // Inner core
            Circle()
                .fill(
                    LinearGradient(
                        colors: [
                            DesignSystem.Colors.primary,
                            DesignSystem.Colors.secondary
                        ],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: 16, height: 16)
                .shadow(
                    color: DesignSystem.Colors.primary.opacity(0.4),
                    radius: animateGradient ? 6 : 3,
                    x: 0,
                    y: 1
                )
                .scaleEffect(animateGradient ? 1.1 : 1.0)
                .animation(style.animation, value: animateGradient)
        }
    }
    private func startAnimation() {
        switch style {
        case .dots, .skeleton, .pulse:
            animateGradient = true
        case .spinner:
            rotationAngle = 360
        }
    }
}
/// Modern empty state view with illustration and actions
struct ModernEmptyStateView: View {
    let icon: String
    let title: String
    let subtitle: String?
    let actionTitle: String?
    let action: (() -> Void)?
    let style: EmptyStateStyle
    enum EmptyStateStyle {
        case standard
        case minimal
        case illustration
        var iconSize: CGFloat {
            switch self {
            case .standard: return 64
            case .minimal: return 48
            case .illustration: return 80
            }
        }
    }
    init(
        icon: String,
        title: String,
        subtitle: String? = nil,
        actionTitle: String? = nil,
        action: (() -> Void)? = nil,
        style: EmptyStateStyle = .standard
    ) {
        self.icon = icon
        self.title = title
        self.subtitle = subtitle
        self.actionTitle = actionTitle
        self.action = action
        self.style = style
    }
    var body: some View {
        VStack(spacing: DesignSystem.Spacing.large) {
            VStack(spacing: DesignSystem.Spacing.medium) {
                // Icon
                Image(systemName: icon)
                    .font(.system(size: style.iconSize, weight: .light))
                    .foregroundStyle(
                        LinearGradient(
                            colors: [
                                DesignSystem.Colors.textTertiary,
                                DesignSystem.Colors.textTertiary.opacity(0.6)
                            ],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .symbolRenderingMode(.hierarchical)
                // Content
                VStack(spacing: DesignSystem.Spacing.small) {
                    Text(title)
                        .font(DesignSystem.Typography.title3)
                        .foregroundColor(DesignSystem.Colors.text)
                        .multilineTextAlignment(.center)
                    if let subtitle = subtitle {
                        Text(subtitle)
                            .font(DesignSystem.Typography.body)
                            .foregroundColor(DesignSystem.Colors.textSecondary)
                            .multilineTextAlignment(.center)
                            .lineLimit(3)
                    }
                }
            }
            // Action button
            if let actionTitle = actionTitle, let action = action {
                Button(action: action) {
                    Text(actionTitle)
                        .frame(minWidth: 120)
                }
                .unifiedSecondaryButton()
            }
        }
        .padding(DesignSystem.Spacing.xl)
        .frame(maxWidth: 300)
    }
}
/// Modern error state view with retry functionality
struct ModernErrorStateView: View {
    let error: Error
    let title: String?
    let subtitle: String?
    let retryAction: (() -> Void)?
    @State private var showDetails = false
    init(
        error: Error,
        title: String? = nil,
        subtitle: String? = nil,
        retryAction: (() -> Void)? = nil
    ) {
        self.error = error
        self.title = title ?? "Something went wrong"
        self.subtitle = subtitle
        self.retryAction = retryAction
    }
    var body: some View {
        VStack(spacing: DesignSystem.Spacing.large) {
            // Error icon
            Image(systemName: "exclamationmark.triangle")
                .font(.system(size: 64, weight: .light))
                .foregroundColor(DesignSystem.Colors.error.opacity(0.8))
                .symbolRenderingMode(.hierarchical)
            // Content
            VStack(spacing: DesignSystem.Spacing.small) {
                Text(title ?? "Something went wrong")
                    .font(DesignSystem.Typography.title3)
                    .foregroundColor(DesignSystem.Colors.text)
                    .multilineTextAlignment(.center)
                if let subtitle = subtitle {
                    Text(subtitle)
                        .font(DesignSystem.Typography.body)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                        .multilineTextAlignment(.center)
                } else {
                    Text(error.localizedDescription)
                        .font(DesignSystem.Typography.body)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                        .multilineTextAlignment(.center)
                        .lineLimit(3)
                }
            }
            // Actions
            VStack(spacing: DesignSystem.Spacing.base) {
                if let retryAction = retryAction {
                    Button("Try Again", action: retryAction)
                        .unifiedPrimaryButton()
                }
                Button("Show Details") {
                    showDetails.toggle()
                }
                .unifiedSecondaryButton()
            }
        }
        .padding(DesignSystem.Spacing.xl)
        .frame(maxWidth: 300)
        .sheet(isPresented: $showDetails) {
            ErrorDetailsView(error: error)
        }
    }
}
/// Error details view for debugging
struct ErrorDetailsView: View {
    let error: Error
    @Environment(\.dismiss) var dismiss
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: DesignSystem.Spacing.medium) {
                    Text(error.localizedDescription)
                        .font(DesignSystem.Typography.body)
                        .foregroundColor(DesignSystem.Colors.text)
                    if let nsError = error as? NSError {
                        Divider()
                        VStack(alignment: .leading, spacing: DesignSystem.Spacing.small) {
                            Text("Domain: \(nsError.domain)")
                            Text("Code: \(nsError.code)")
                            if !nsError.userInfo.isEmpty {
                                Text("User Info:")
                                    .font(DesignSystem.Typography.footnoteMedium)
                                ForEach(Array(nsError.userInfo.keys), id: \.self) { key in
                                    Text("\(key): \(String(describing: nsError.userInfo[key]))")
                                        .font(DesignSystem.Typography.caption)
                                        .foregroundColor(DesignSystem.Colors.textSecondary)
                                }
                            }
                        }
                        .font(DesignSystem.Typography.footnote)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                    }
                }
                .padding(DesignSystem.Spacing.large)
            }
            .navigationTitle("Error Details")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
    }
}
/// Content state wrapper that handles loading, empty, and error states
struct ContentStateView<Content: View, LoadedContent: View>: View {
    let state: ContentState
    let content: () -> Content
    let loadedContent: () -> LoadedContent
    enum ContentState {
        case loading(message: String? = nil)
        case empty(icon: String, title: String, subtitle: String? = nil, actionTitle: String? = nil, action: (() -> Void)? = nil)
        case error(Error, retryAction: (() -> Void)? = nil)
        case loaded
    }
    init(
        state: ContentState,
        @ViewBuilder content: @escaping () -> Content,
        @ViewBuilder loadedContent: @escaping () -> LoadedContent
    ) {
        self.state = state
        self.content = content
        self.loadedContent = loadedContent
    }
    var body: some View {
        switch state {
        case .loading(let message):
            content()
                .overlay(
                    ModernLoadingView(message: message)
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                        .background(DesignSystem.Colors.background.opacity(0.8))
                )
        case .empty(let icon, let title, let subtitle, let actionTitle, let action):
            ModernEmptyStateView(
                icon: icon,
                title: title,
                subtitle: subtitle,
                actionTitle: actionTitle,
                action: action
            )
            .frame(maxWidth: .infinity, maxHeight: .infinity)
        case .error(let error, let retryAction):
            ModernErrorStateView(
                error: error,
                retryAction: retryAction
            )
            .frame(maxWidth: .infinity, maxHeight: .infinity)
        case .loaded:
            loadedContent()
        }
    }
}
// MARK: - View Extensions
extension View {
    /// Wrap content with state management
    func contentState<LoadedContent: View>(
        _ state: ContentStateView<Self, LoadedContent>.ContentState,
        @ViewBuilder loadedContent: @escaping () -> LoadedContent
    ) -> some View {
        ContentStateView(state: state) {
            self
        } loadedContent: {
            loadedContent()
        }
    }
    /// Show loading overlay
    func loadingOverlay(isLoading: Bool, message: String? = nil) -> some View {
        self.overlay(
            Group {
                if isLoading {
                    ModernLoadingView(message: message)
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                        .background(DesignSystem.Colors.background.opacity(0.8))
                }
            }
        )
    }
}
// MARK: - Preview
#Preview("Loading States") {
    ScrollView {
        VStack(spacing: DesignSystem.Spacing.xl) {
            ModernLoadingView(message: "Loading your highlights...", style: .dots)
            ModernLoadingView(style: .spinner)
            ModernLoadingView(style: .skeleton)
            ModernLoadingView(style: .pulse)
        }
        .padding(DesignSystem.Spacing.large)
    }
    .background(DesignSystem.Colors.background)
}
#Preview("Empty States") {
    ScrollView {
        VStack(spacing: DesignSystem.Spacing.xl) {
            ModernEmptyStateView(
                icon: "highlighter",
                title: "No Highlights Yet",
                subtitle: "Start highlighting interesting content to see it here",
                actionTitle: "Create Highlight",
                action: {}
            )
            ModernEmptyStateView(
                icon: "books.vertical",
                title: "No Books Found",
                subtitle: "Try adjusting your search criteria",
                style: .minimal
            )
        }
        .padding(DesignSystem.Spacing.large)
    }
    .background(DesignSystem.Colors.background)
}
struct SampleError: LocalizedError {
    var errorDescription: String? {
        "Failed to load content from the server"
    }
}
#Preview("Error State") {
    ModernErrorStateView(
        error: SampleError(),
        retryAction: {}
    )
    .padding(DesignSystem.Spacing.large)
    .background(DesignSystem.Colors.background)
}
</file>

<file path="Sources/Highlighter/Views/Components/SelectableMarkdownRenderer.swift">
import SwiftUI
import NDKSwift
import NDKSwiftUI
/// A wrapper around NDKMarkdownRenderer that adds text selection capabilities
struct SelectableMarkdownRenderer: View {
    let content: String
    let ndk: NDK
    let onTextSelected: (String, NSRange) -> Void
    @State private var selectedRange: NSRange?
    @State private var textGeometry: [TextGeometry] = []
    @State private var showSelectionHandles = false
    @State private var selectionStart: CGPoint = .zero
    @State private var selectionEnd: CGPoint = .zero
    // Pass through configuration and handlers
    var configuration = MarkdownConfiguration()
    var onMentionTap: ((String) -> Void)?
    var onHashtagTap: ((String) -> Void)?
    var onLinkTap: ((URL) -> Void)?
    var onNostrEntityTap: ((ContentEntity) -> Void)?
    var body: some View {
        // Base markdown renderer without overlay for now
        NDKMarkdownRenderer(content, ndk: ndk)
            .markdownStyle(configuration)
            .onMentionTap { mention in
                onMentionTap?(mention)
            }
            .onHashtagTap { tag in
                onHashtagTap?(tag)
            }
            .onLinkTap { url in
                onLinkTap?(url)
            }
            .onNostrEntityTap { entity in
                onNostrEntityTap?(entity)
            }
            .fixedSize(horizontal: false, vertical: true)
    }
}
/// UIViewRepresentable that provides text selection
private struct SelectableTextOverlay: UIViewRepresentable {
    let content: String
    let onTextSelected: (String, NSRange) -> Void
    func makeUIView(context: Context) -> UITextView {
        let textView = UITextView()
        textView.isEditable = false
        textView.isSelectable = true
        textView.backgroundColor = .clear
        textView.delegate = context.coordinator
        textView.isScrollEnabled = false
        textView.textContainerInset = .zero
        textView.textContainer.lineFragmentPadding = 0
        // Set the text with transparent color
        let attributes: [NSAttributedString.Key: Any] = [
            .font: UIFont.systemFont(ofSize: 17),
            .foregroundColor: UIColor.clear
        ]
        textView.attributedText = NSAttributedString(string: content, attributes: attributes)
        return textView
    }
    func updateUIView(_ uiView: UITextView, context: Context) {
        // Update if content changes
        if uiView.text != content {
            let attributes: [NSAttributedString.Key: Any] = [
                .font: UIFont.systemFont(ofSize: 17),
                .foregroundColor: UIColor.clear
            ]
            uiView.attributedText = NSAttributedString(string: content, attributes: attributes)
        }
    }
    func makeCoordinator() -> Coordinator {
        Coordinator(onTextSelected: onTextSelected)
    }
    class Coordinator: NSObject, UITextViewDelegate {
        let onTextSelected: (String, NSRange) -> Void
        init(onTextSelected: @escaping (String, NSRange) -> Void) {
            self.onTextSelected = onTextSelected
        }
        func textViewDidChangeSelection(_ textView: UITextView) {
            guard let selectedRange = textView.selectedTextRange,
                  !selectedRange.isEmpty,
                  let selectedText = textView.text(in: selectedRange),
                  !selectedText.isEmpty else { return }
            let location = textView.offset(from: textView.beginningOfDocument, to: selectedRange.start)
            let length = textView.offset(from: selectedRange.start, to: selectedRange.end)
            let range = NSRange(location: location, length: length)
            // Clear selection after capturing it
            DispatchQueue.main.async {
                textView.selectedTextRange = nil
            }
            onTextSelected(selectedText, range)
        }
    }
}
// MARK: - View Extensions
extension SelectableMarkdownRenderer {
    func markdownStyle(_ style: MarkdownConfiguration) -> Self {
        var view = self
        view.configuration = style
        return view
    }
    func onMentionTap(_ action: @escaping (String) -> Void) -> Self {
        var view = self
        view.onMentionTap = action
        return view
    }
    func onHashtagTap(_ action: @escaping (String) -> Void) -> Self {
        var view = self
        view.onHashtagTap = action
        return view
    }
    func onLinkTap(_ action: @escaping (URL) -> Void) -> Self {
        var view = self
        view.onLinkTap = action
        return view
    }
    func onNostrEntityTap(_ action: @escaping (ContentEntity) -> Void) -> Self {
        var view = self
        view.onNostrEntityTap = action
        return view
    }
}
// MARK: - Helper Types
private struct TextGeometry {
    let text: String
    let frame: CGRect
    let range: NSRange
}
</file>

<file path="Sources/Highlighter/Views/Components/SharedStyles.swift">
import SwiftUI
// MARK: - Highlighter-Specific Extensions
// This file contains Highlighter-specific utilities that extend the base DesignSystem
// Following DRY principle: All general design system elements are in DesignSystem.swift
// MARK: - Content Rendering Extensions
extension View {
    /// Performance optimization for scroll views with many items
    func optimizeForScrolling(isVisible: Bool) -> some View {
        self.modifier(ContentOptimizationModifier(isVisible: isVisible))
    }
    /// Specialized animation for highlight text selection
    func highlightSelection(_ isSelected: Bool) -> some View {
        self.modifier(HighlightSelectionModifier(isSelected: isSelected))
    }
    /// Smart text truncation with context awareness
    func smartTruncation(maxLines: Int, expandable: Bool = false) -> some View {
        self.modifier(SmartTruncationModifier(maxLines: maxLines, expandable: expandable))
    }
}
// MARK: - Specialized Modifiers for Highlighter Content
/// Performance optimization for scroll views with many items
struct ContentOptimizationModifier: ViewModifier {
    let isVisible: Bool
    func body(content: Content) -> some View {
        content
            .opacity(isVisible ? 1 : 0.3)
            .scaleEffect(isVisible ? 1 : 0.98)
            .animation(.easeInOut(duration: 0.2), value: isVisible)
    }
}
/// Highlight selection with subtle visual feedback
struct HighlightSelectionModifier: ViewModifier {
    let isSelected: Bool
    @State private var selectionScale: CGFloat = 1.0
    func body(content: Content) -> some View {
        content
            .background(
                RoundedRectangle(cornerRadius: 6, style: .continuous)
                    .fill(isSelected ? DesignSystem.Colors.secondary.opacity(0.1) : Color.clear)
                    .animation(.easeInOut(duration: 0.2), value: isSelected)
            )
            .scaleEffect(selectionScale)
            .onChange(of: isSelected) { _, newValue in
                if newValue {
                    withAnimation(.spring(response: 0.15, dampingFraction: 0.8)) {
                        selectionScale = 1.02
                    }
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                        withAnimation(.spring(response: 0.2, dampingFraction: 0.7)) {
                            selectionScale = 1.0
                        }
                    }
                }
            }
    }
}
/// Smart text truncation that can expand when needed
struct SmartTruncationModifier: ViewModifier {
    let maxLines: Int
    let expandable: Bool
    @State private var isExpanded = false
    func body(content: Content) -> some View {
        content
            .lineLimit(isExpanded ? nil : maxLines)
            .animation(.easeInOut(duration: 0.2), value: isExpanded)
            .overlay(alignment: .bottomTrailing) {
                if expandable && !isExpanded {
                    Button("more") {
                        withAnimation(.easeInOut(duration: 0.2)) {
                            isExpanded = true
                        }
                    }
                    .font(.caption)
                    .foregroundColor(DesignSystem.Colors.primary)
                    .padding(.leading, 20)
                    .background(
                        LinearGradient(
                            colors: [Color.clear, DesignSystem.Colors.surface],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                }
            }
    }
}
</file>

<file path="Sources/Highlighter/Views/Components/SwipeableHighlightCard.swift">
import SwiftUI
import NDKSwift
struct SwipeableHighlightCard: View {
    let highlight: HighlightEvent
    let onSwipeRight: () -> Void
    let onSwipeLeft: () -> Void
    let onTap: () -> Void
    @EnvironmentObject var appState: AppState
    @State private var offset: CGSize = .zero
    @State private var rotation: Double = 0
    @State private var scale: CGFloat = 1.0
    @State private var isDragging = false
    @State private var showLeftIcon = false
    @State private var showRightIcon = false
    @State private var hapticTriggered = false
    @State private var glowAnimation = false
    @State private var particleAnimation = false
    @State private var engagement: EngagementService.EngagementMetrics?
    // Gesture thresholds
    private let swipeThreshold: CGFloat = 120
    private let rotationFactor: Double = 0.001
    private let scaleFactor: CGFloat = 0.95
    var body: some View {
        ZStack {
            // Card content
            cardContent
                .offset(offset)
                .rotationEffect(.degrees(rotation))
                .scaleEffect(scale)
                .gesture(dragGesture)
                .onTapGesture(perform: onTap)
            // Swipe indicators
            if isDragging {
                swipeIndicators
            }
            // Particle effects
            if particleAnimation {
                ParticleEffectView()
                    .allowsHitTesting(false)
            }
        }
        .animation(.spring(response: 0.5, dampingFraction: 0.8), value: offset)
        .animation(.spring(response: 0.5, dampingFraction: 0.8), value: rotation)
        .animation(.spring(response: 0.3, dampingFraction: 0.8), value: scale)
        .onAppear {
            startGlowAnimation()
        }
        .task {
            await loadEngagement()
        }
    }
    // MARK: - Card Content
    private var cardContent: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Header with author info
            HStack(spacing: 12) {
                EnhancedAsyncProfileImage(pubkey: highlight.author, size: 44)
                    .overlay(
                        Circle()
                            .stroke(
                                LinearGradient(
                                    colors: [DesignSystem.Colors.primary, DesignSystem.Colors.secondary],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                ),
                                lineWidth: 2
                            )
                    )
                VStack(alignment: .leading, spacing: 2) {
                    Text(PubkeyFormatter.formatCompact(highlight.author))
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundColor(DesignSystem.Colors.text)
                    HStack(spacing: 4) {
                        Image(systemName: "clock")
                            .font(.system(size: 11))
                        Text(RelativeTimeFormatter.shortRelativeTime(from: highlight.createdAt))
                            .font(.system(size: 12))
                    }
                    .foregroundColor(DesignSystem.Colors.textSecondary)
                }
                Spacer()
                // Menu button
                Menu {
                    Button(action: {
                        Task {
                            try? await appState.bookmarkService.toggleHighlightBookmark(highlight)
                            HapticManager.shared.impact(.light)
                        }
                    }) {
                        Label(appState.bookmarkService.isHighlightBookmarked(highlight.id) ? "Unsave" : "Save", 
                              systemImage: appState.bookmarkService.isHighlightBookmarked(highlight.id) ? "bookmark.fill" : "bookmark")
                    }
                    Button(action: {
                        shareHighlight()
                    }) {
                        Label("Share", systemImage: "square.and.arrow.up")
                    }
                    Button(action: {
                        UIPasteboard.general.string = highlight.content
                        HapticManager.shared.impact(.light)
                    }) {
                        Label("Copy", systemImage: "doc.on.doc")
                    }
                } label: {
                    Image(systemName: "ellipsis")
                        .font(.system(size: 16))
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                        .padding(8)
                        .background(Circle().fill(DesignSystem.Colors.surfaceSecondary))
                }
            }
            // Highlight content with quote styling
            ZStack(alignment: .topLeading) {
                Text("\u{201C}")
                    .font(.system(size: 48, weight: .black, design: .serif))
                    .foregroundColor(DesignSystem.Colors.primary.opacity(0.15))
                    .offset(x: -8, y: -20)
                Text(highlight.content)
                    .font(.system(size: 18, weight: .medium, design: .rounded))
                    .foregroundColor(DesignSystem.Colors.text)
                    .lineSpacing(6)
                    .padding(.top, 8)
                    .background(
                        GeometryReader { geometry in
                            // Animated highlight effect
                            RoundedRectangle(cornerRadius: 4)
                                .fill(DesignSystem.Colors.highlightSubtle.opacity(0.3))
                                .frame(width: glowAnimation ? geometry.size.width : 0)
                                .animation(
                                    .easeInOut(duration: 2)
                                    .delay(0.5),
                                    value: glowAnimation
                                )
                        }
                        .padding(.horizontal, -4)
                    )
            }
            // Context or source
            if let url = highlight.url {
                HStack(spacing: 6) {
                    Image(systemName: "link.circle.fill")
                        .font(.system(size: 14))
                        .foregroundColor(DesignSystem.Colors.primary)
                    Text(ContentFormatter.extractDomain(from: url))
                        .font(.system(size: 13))
                        .foregroundColor(DesignSystem.Colors.primary)
                        .lineLimit(1)
                }
                .padding(.horizontal, 12)
                .padding(.vertical, 6)
                .background(
                    Capsule()
                        .fill(DesignSystem.Colors.primary.opacity(0.1))
                        .overlay(
                            Capsule()
                                .stroke(DesignSystem.Colors.primary.opacity(0.2), lineWidth: 1)
                        )
                )
            }
            // Engagement metrics
            HStack(spacing: 24) {
                if let metrics = engagement {
                    EngagementMetric(icon: "heart", value: metrics.likes, color: .red)
                    EngagementMetric(icon: "bubble.right", value: metrics.comments, color: .blue)
                    EngagementMetric(icon: "arrow.2.squarepath", value: metrics.reposts, color: .green)
                    EngagementMetric(icon: "bolt.fill", value: metrics.zaps, color: .orange)
                } else {
                    // Loading state
                    ForEach(0..<4) { _ in
                        RoundedRectangle(cornerRadius: 8)
                            .fill(DesignSystem.Colors.surfaceSecondary)
                            .frame(width: 50, height: 20)
                            .shimmer()
                    }
                }
            }
        }
        .padding(20)
        .background(
            ZStack {
                // Base background
                RoundedRectangle(cornerRadius: 24, style: .continuous)
                    .fill(DesignSystem.Colors.surface)
                // Gradient overlay
                LinearGradient(
                    colors: [
                        DesignSystem.Colors.primary.opacity(0.05),
                        DesignSystem.Colors.secondary.opacity(0.03),
                        Color.clear
                    ],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .clipShape(RoundedRectangle(cornerRadius: 24, style: .continuous))
                // Border gradient
                RoundedRectangle(cornerRadius: 24, style: .continuous)
                    .stroke(
                        LinearGradient(
                            colors: [
                                Color.white.opacity(0.5),
                                Color.white.opacity(0.1)
                            ],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ),
                        lineWidth: 1
                    )
            }
        )
        .shadow(
            color: isDragging ? DesignSystem.Colors.primary.opacity(0.3) : DesignSystem.Shadow.large.color,
            radius: isDragging ? 30 : DesignSystem.Shadow.large.radius,
            y: isDragging ? 15 : DesignSystem.Shadow.large.y
        )
    }
    // MARK: - Swipe Indicators
    private var swipeIndicators: some View {
        ZStack {
            // Left swipe indicator (Archive/Hide)
            HStack {
                ZStack {
                    Circle()
                        .fill(Color.red.opacity(showLeftIcon ? 0.2 : 0))
                        .frame(width: 80, height: 80)
                        .blur(radius: 10)
                    Image(systemName: "archivebox.fill")
                        .font(.system(size: 32))
                        .foregroundColor(Color.red)
                        .opacity(showLeftIcon ? 1 : 0)
                        .scaleEffect(showLeftIcon ? 1.2 : 0.8)
                }
                .offset(x: -40)
                Spacer()
            }
            // Right swipe indicator (Save/Bookmark)
            HStack {
                Spacer()
                ZStack {
                    Circle()
                        .fill(Color.green.opacity(showRightIcon ? 0.2 : 0))
                        .frame(width: 80, height: 80)
                        .blur(radius: 10)
                    Image(systemName: "bookmark.fill")
                        .font(.system(size: 32))
                        .foregroundColor(Color.green)
                        .opacity(showRightIcon ? 1 : 0)
                        .scaleEffect(showRightIcon ? 1.2 : 0.8)
                }
                .offset(x: 40)
            }
        }
        .animation(.spring(response: 0.3, dampingFraction: 0.8), value: showLeftIcon)
        .animation(.spring(response: 0.3, dampingFraction: 0.8), value: showRightIcon)
    }
    // MARK: - Drag Gesture
    private var dragGesture: some Gesture {
        DragGesture()
            .onChanged { value in
                // Update position
                offset = value.translation
                rotation = Double(value.translation.width) * rotationFactor * 20
                // Scale effect
                if !isDragging {
                    withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                        isDragging = true
                        scale = scaleFactor
                    }
                }
                // Show swipe indicators
                withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                    showLeftIcon = value.translation.width < -50
                    showRightIcon = value.translation.width > 50
                }
                // Haptic feedback at threshold
                if abs(value.translation.width) > swipeThreshold && !hapticTriggered {
                    HapticManager.shared.impact(.medium)
                    hapticTriggered = true
                }
            }
            .onEnded { value in
                withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
                    if value.translation.width < -swipeThreshold {
                        // Swipe left - Archive
                        offset = CGSize(width: -UIScreen.main.bounds.width * 1.5, height: 0)
                        rotation = -30
                        HapticManager.shared.notification(.success)
                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                            onSwipeLeft()
                        }
                    } else if value.translation.width > swipeThreshold {
                        // Swipe right - Save
                        offset = CGSize(width: UIScreen.main.bounds.width * 1.5, height: 0)
                        rotation = 30
                        HapticManager.shared.notification(.success)
                        triggerParticleEffect()
                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                            onSwipeRight()
                        }
                    } else {
                        // Return to center
                        offset = .zero
                        rotation = 0
                    }
                    // Reset states
                    isDragging = false
                    scale = 1.0
                    showLeftIcon = false
                    showRightIcon = false
                    hapticTriggered = false
                }
            }
    }
    // MARK: - Helper Methods
    private func startGlowAnimation() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            glowAnimation = true
        }
    }
    private func triggerParticleEffect() {
        particleAnimation = true
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
            particleAnimation = false
        }
    }
    private func loadEngagement() async {
        let metrics = await appState.engagementService.fetchEngagement(for: highlight.id)
        await MainActor.run {
            self.engagement = metrics
        }
    }
    private func shareHighlight() {
        let activityVC = UIActivityViewController(
            activityItems: [highlight.content],
            applicationActivities: nil
        )
        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let window = windowScene.windows.first,
           let rootVC = window.rootViewController {
            rootVC.present(activityVC, animated: true)
        }
        HapticManager.shared.impact(.light)
    }
}
// MARK: - Supporting Views
struct EngagementMetric: View {
    let icon: String
    let value: Int
    let color: Color
    var body: some View {
        HStack(spacing: 4) {
            Image(systemName: icon)
                .font(.system(size: 16))
                .foregroundColor(color)
            Text("\(value)")
                .font(.system(size: 14, weight: .medium))
                .foregroundColor(DesignSystem.Colors.textSecondary)
        }
    }
}
struct ParticleEffectView: View {
    @State private var particles: [Particle] = []
    struct Particle: Identifiable {
        let id = UUID()
        var x: CGFloat
        var y: CGFloat
        let size: CGFloat
        let color: Color
        var opacity: Double = 1.0
    }
    var body: some View {
        ZStack {
            ForEach(particles) { particle in
                Circle()
                    .fill(particle.color)
                    .frame(width: particle.size, height: particle.size)
                    .position(x: particle.x, y: particle.y)
                    .opacity(particle.opacity)
            }
        }
        .onAppear {
            createParticles()
            animateParticles()
        }
    }
    private func createParticles() {
        particles = (0..<20).map { _ in
            Particle(
                x: UIScreen.main.bounds.width / 2,
                y: UIScreen.main.bounds.height / 2,
                size: CGFloat.random(in: 4...12),
                color: [Color.green, Color.blue, Color.purple, Color.orange].randomElement()!
            )
        }
    }
    private func animateParticles() {
        for index in particles.indices {
            withAnimation(.easeOut(duration: 1.5)) {
                particles[index].x += CGFloat.random(in: -150...150)
                particles[index].y += CGFloat.random(in: -150...150)
                particles[index].opacity = 0
            }
        }
    }
}
// MARK: - Card Stack View
struct SwipeableCardStack: View {
    @EnvironmentObject var appState: AppState
    @State private var currentIndex = 0
    @State private var showDetail = false
    @State private var selectedHighlight: HighlightEvent?
    var body: some View {
        ZStack {
            ForEach(Array(appState.highlights.enumerated()), id: \.offset) { index, highlight in
                if index >= currentIndex && index < currentIndex + 3 {
                    SwipeableHighlightCard(
                        highlight: highlight,
                        onSwipeRight: {
                            saveHighlight(highlight)
                            nextCard()
                        },
                        onSwipeLeft: {
                            archiveHighlight(highlight)
                            nextCard()
                        },
                        onTap: {
                            selectedHighlight = highlight
                            showDetail = true
                        }
                    )
                    .offset(y: CGFloat(index - currentIndex) * 10)
                    .scaleEffect(1 - CGFloat(index - currentIndex) * 0.05)
                    .opacity(index == currentIndex ? 1 : 0.8)
                    .zIndex(Double(appState.highlights.count - index))
                }
            }
            if appState.highlights.isEmpty {
                VStack(spacing: 16) {
                    Image(systemName: "rectangle.stack.fill")
                        .font(.system(size: 48))
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                    Text("No highlights to swipe")
                        .font(DesignSystem.Typography.body)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                }
            }
        }
        .sheet(isPresented: $showDetail) {
            if let highlight = selectedHighlight {
                NavigationView {
                    HighlightDetailView(highlight: highlight)
                }
            }
        }
    }
    private func nextCard() {
        withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
            currentIndex += 1
        }
    }
    private func saveHighlight(_ highlight: HighlightEvent) {
        Task {
            do {
                // Toggle bookmark
                try await appState.bookmarkService.toggleHighlightBookmark(highlight)
                // Show success feedback
                HapticManager.shared.notification(.success)
            } catch {
                HapticManager.shared.notification(.error)
            }
        }
    }
    private func archiveHighlight(_ highlight: HighlightEvent) {
        Task {
            // Remove from feed (archive doesn't exist in the service yet, so we'll just remove from view)
            // In a real implementation, this would mark as archived
            HapticManager.shared.notification(.success)
        }
    }
}
#Preview {
    ZStack {
        Color(UIColor.systemBackground)
            .ignoresSafeArea()
        SwipeableCardStack()
            .padding()
    }
    .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Views/Components/TappableAvatar.swift">
import SwiftUI
import NDKSwift
struct TappableAvatar: View {
    let pubkey: String
    let size: CGFloat
    let profile: NDKUserProfile?
    let showOnlineIndicator: Bool
    let enableHoverEffect: Bool
    @State private var showingProfile = false
    @State private var isPressed = false
    @State private var isHovering = false
    @State private var loadingProgress: CGFloat = 0
    @Namespace private var animationNamespace
    init(
        pubkey: String,
        size: CGFloat = 40,
        profile: NDKUserProfile? = nil,
        showOnlineIndicator: Bool = false,
        enableHoverEffect: Bool = true
    ) {
        self.pubkey = pubkey
        self.size = size
        self.profile = profile
        self.showOnlineIndicator = showOnlineIndicator
        self.enableHoverEffect = enableHoverEffect
    }
    var body: some View {
        Button(action: {
            showingProfile = true
            HapticManager.shared.impact(.light)
        }) {
            ZStack {
                // Main avatar
                avatarView
                    .scaleEffect(isPressed ? 0.92 : (isHovering && enableHoverEffect ? 1.05 : 1.0))
                    .animation(AnimationSystem.Curves.springBouncy, value: isPressed)
                    .animation(AnimationSystem.Curves.springSmooth, value: isHovering)
                    .shadow(
                        color: Color.black.opacity(isHovering ? 0.15 : 0.1),
                        radius: isHovering ? 12 : 6,
                        x: 0,
                        y: isHovering ? 4 : 2
                    )
                // Online indicator
                if showOnlineIndicator {
                    Circle()
                        .fill(Color.green)
                        .frame(width: size * 0.25, height: size * 0.25)
                        .overlay(
                            Circle()
                                .stroke(Color.ds.background, lineWidth: 2)
                        )
                        .offset(x: size * 0.35, y: size * 0.35)
                        .scaleEffect(isHovering ? 1.2 : 1.0)
                        .animation(AnimationSystem.Curves.springBouncy, value: isHovering)
                }
            }
        }
        .buttonStyle(PlainButtonStyle())
        .onHover { hovering in
            withAnimation(AnimationSystem.Curves.springSmooth) {
                isHovering = hovering
            }
        }
        .pressEvents(
            onPress: {
                withAnimation(AnimationSystem.Curves.springBouncy) {
                    isPressed = true
                }
            },
            onRelease: {
                withAnimation(AnimationSystem.Curves.springBouncy) {
                    isPressed = false
                }
            }
        )
        .sheet(isPresented: $showingProfile) {
            UserProfileView(pubkey: pubkey)
                .presentationDragIndicator(.visible)
                .presentationDetents([.large])
                .presentationCornerRadius(24)
        }
    }
    @ViewBuilder
    private var avatarView: some View {
        if let picture = profile?.picture, let url = URL(string: picture) {
            AsyncImage(url: url) { phase in
                switch phase {
                case .success(let image):
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .frame(width: size, height: size)
                        .clipShape(Circle())
                        .overlay(
                            Circle()
                                .strokeBorder(
                                    LinearGradient(
                                        colors: [
                                            Color.white.opacity(0.4),
                                            Color.white.opacity(0.1)
                                        ],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    ),
                                    lineWidth: 1
                                )
                        )
                        .transition(.opacity.combined(with: .scale))
                case .failure(_):
                    placeholderAvatar
                        .overlay(
                            Image(systemName: "exclamationmark.triangle.fill")
                                .font(.system(size: size * 0.3))
                                .foregroundColor(.white.opacity(0.8))
                        )
                case .empty:
                    ZStack {
                        placeholderAvatar
                        // Loading animation
                        Circle()
                            .trim(from: 0, to: loadingProgress)
                            .stroke(
                                Color.white.opacity(0.3),
                                style: StrokeStyle(lineWidth: 2, lineCap: .round)
                            )
                            .frame(width: size - 4, height: size - 4)
                            .rotationEffect(.degrees(-90))
                            .onAppear {
                                withAnimation(.easeInOut(duration: 1.5).repeatForever(autoreverses: false)) {
                                    loadingProgress = 1
                                }
                            }
                    }
                @unknown default:
                    placeholderAvatar
                }
            }
        } else {
            placeholderAvatar
        }
    }
    @ViewBuilder
    private var placeholderAvatar: some View {
        ZStack {
            // Gradient background with animation
            Circle()
                .fill(
                    LinearGradient(
                        colors: gradientColors(for: pubkey),
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: size, height: size)
                .overlay(
                    Circle()
                        .fill(
                            RadialGradient(
                                colors: [
                                    Color.white.opacity(0.2),
                                    Color.clear
                                ],
                                center: .topLeading,
                                startRadius: 0,
                                endRadius: size * 0.7
                            )
                        )
                )
            // Initial text
            Text(PubkeyFormatter.formatForAvatar(pubkey))
                .font(.system(size: size * 0.4, weight: .semibold, design: .rounded))
                .foregroundColor(.white)
                .shadow(color: .black.opacity(0.2), radius: 2, x: 0, y: 1)
        }
    }
    private func gradientColors(for pubkey: String) -> [Color] {
        // Generate consistent colors based on pubkey
        let hash = pubkey.hashValue
        let hue1 = Double(abs(hash % 360)) / 360.0
        let hue2 = (hue1 + 0.15).truncatingRemainder(dividingBy: 1.0)
        return [
            Color(hue: hue1, saturation: 0.7, brightness: 0.8),
            Color(hue: hue2, saturation: 0.8, brightness: 0.6)
        ]
    }
}
// MARK: - Convenience Modifier
extension View {
    func tappableAvatar(
        pubkey: String,
        size: CGFloat = 40,
        profile: NDKUserProfile? = nil,
        showOnlineIndicator: Bool = false,
        enableHoverEffect: Bool = true
    ) -> some View {
        self.overlay(
            TappableAvatar(
                pubkey: pubkey,
                size: size,
                profile: profile,
                showOnlineIndicator: showOnlineIndicator,
                enableHoverEffect: enableHoverEffect
            )
        )
    }
}
// MARK: - Press Events Modifier
private struct PressEventsModifier: ViewModifier {
    var onPress: () -> Void
    var onRelease: () -> Void
    @GestureState private var isPressed = false
    func body(content: Content) -> some View {
        content
            .simultaneousGesture(
                DragGesture(minimumDistance: 0)
                    .updating($isPressed) { _, state, _ in
                        if !state {
                            state = true
                            onPress()
                        }
                    }
                    .onEnded { _ in
                        onRelease()
                    }
            )
    }
}
extension View {
    func pressEvents(onPress: @escaping () -> Void, onRelease: @escaping () -> Void) -> some View {
        self.modifier(PressEventsModifier(onPress: onPress, onRelease: onRelease))
    }
}
</file>

<file path="Sources/Highlighter/Views/Curations/CreateCurationView.swift">
import SwiftUI
import NDKSwift
import PhotosUI
struct CreateCurationView: View {
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) var dismiss
    // Form state
    @State private var curationName = ""
    @State private var curationTitle = ""
    @State private var description = ""
    @State private var imageUrl = ""
    @State private var showError = false
    @State private var errorMessage = ""
    // UI state
    @State private var currentStep = 0
    @State private var showImagePicker = false
    @State private var selectedImage: PhotosPickerItem?
    @State private var selectedImageData: Data?
    @State private var keyboardHeight: CGFloat = 0
    @State private var animateHeader = false
    @State private var animateForm = false
    @State private var pulseAnimation = false
    @State private var particleAnimation = false
    @State private var selectedColor = DesignSystem.Colors.primary
    @State private var showColorPicker = false
    @State private var nameFieldFocused = false
    @State private var titleFieldFocused = false
    @State private var descriptionFieldFocused = false
    @Namespace private var animation
    let gradientColors: [[Color]] = [
        [DesignSystem.Colors.primary, DesignSystem.Colors.secondary],
        [Color.blue, Color.purple],
        [Color.pink, Color.orange],
        [Color.green, Color.blue],
        [Color.indigo, Color.pink]
    ]
    var isFormValid: Bool {
        !curationName.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty &&
        !curationTitle.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
    }
    @ViewBuilder
    private var headerImageSection: some View {
        ZStack {
            // Dynamic gradient background
            RoundedRectangle(cornerRadius: 20)
                .fill(
                    LinearGradient(
                        colors: gradientColors[Int(selectedColor.description.hashValue) % gradientColors.count],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(height: 220)
            // Image preview or placeholder
            if let imageData = selectedImageData,
               let uiImage = UIImage(data: imageData) {
                Image(uiImage: uiImage)
                    .resizable()
                    .aspectRatio(contentMode: .fill)
                    .frame(height: 220)
                    .clipped()
                    .cornerRadius(DesignSystem.CornerRadius.xl)
                    .transition(.asymmetric(
                        insertion: .scale.combined(with: .opacity),
                        removal: .opacity
                    ))
            }
            // Interactive overlay
            VStack {
                HStack {
                    Spacer()
                    // Color picker button
                    Button(action: {
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                            showColorPicker.toggle()
                        }
                        HapticManager.shared.impact(.light)
                    }) {
                        ZStack {
                            Circle()
                                .fill(.ultraThinMaterial)
                                .frame(width: 36, height: 36)
                            Image(systemName: "paintpalette.fill")
                                .foregroundColor(.white)
                                .font(.system(size: 16))
                        }
                    }
                    .scaleEffect(pulseAnimation ? 1.1 : 1.0)
                    .padding(DesignSystem.Spacing.base)
                }
                Spacer()
                // Upload button
                Button(action: { showImagePicker = true }) {
                    HStack(spacing: 8) {
                        Image(systemName: selectedImageData == nil ? "photo.badge.plus" : "photo.badge.checkmark")
                            .font(.system(size: 20))
                            .symbolEffect(.bounce, value: selectedImageData != nil)
                        Text(selectedImageData == nil ? "Add Cover Image" : "Change Image")
                            .font(DesignSystem.Typography.body.weight(.medium))
                    }
                    .foregroundColor(.white)
                    .padding(.horizontal, DesignSystem.Spacing.large)
                    .padding(.vertical, DesignSystem.Spacing.small + DesignSystem.Spacing.nano)
                    .background(.ultraThinMaterial)
                    .cornerRadius(DesignSystem.CornerRadius.xl)
                }
                .scaleEffect(animateForm ? 1 : 0.8)
                .opacity(animateForm ? 1 : 0)
            }
            .padding()
        }
        .frame(height: 220)
        .shadow(color: selectedColor.opacity(0.3), radius: DesignSystem.Shadow.elevated.radius, x: DesignSystem.Shadow.elevated.x, y: DesignSystem.Shadow.elevated.y)
        .scaleEffect(animateHeader ? 1 : 0.95)
        .opacity(animateHeader ? 1 : 0)
        .padding(.horizontal)
        .padding(.top, DesignSystem.Spacing.medium)
    }
    @ViewBuilder
    private var colorPickerSection: some View {
        if showColorPicker {
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 12) {
                    ForEach(0..<gradientColors.count, id: \.self) { index in
                        Button(action: {
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                selectedColor = gradientColors[index].first ?? DesignSystem.Colors.primary
                            }
                            HapticManager.shared.impact(.light)
                        }) {
                            Circle()
                                .fill(
                                    LinearGradient(
                                        colors: gradientColors[index],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                                .frame(width: 44, height: 44)
                                .overlay(
                                    Circle()
                                        .stroke(Color.white, lineWidth: 3)
                                        .opacity(selectedColor == gradientColors[index].first ? 1 : 0)
                                )
                        }
                    }
                }
                .padding(.horizontal)
            }
            .transition(.asymmetric(
                insertion: .move(edge: .top).combined(with: .opacity),
                removal: .move(edge: .top).combined(with: .opacity)
            ))
        }
    }
    @ViewBuilder
    private var formFieldsSection: some View {
        VStack(spacing: 24) {
            // Name field
            nameField
            // Title field
            titleField
            // Description field
            descriptionField
            // Image URL field
            if selectedImageData == nil {
                imageUrlField
            }
        }
        .padding(.horizontal)
    }
    @ViewBuilder
    private var nameField: some View {
        VStack(alignment: .leading, spacing: 10) {
            HStack {
                Label("Curation ID", systemImage: "number.square.fill")
                    .font(DesignSystem.Typography.caption.weight(.medium))
                    .foregroundColor(nameFieldFocused ? DesignSystem.Colors.primary : DesignSystem.Colors.textSecondary)
                Spacer()
                if !curationName.isEmpty {
                    Text("\(curationName.count)/50")
                        .font(.ds.footnote)
                        .foregroundColor(curationName.count > 50 ? .red : DesignSystem.Colors.textSecondary)
                }
            }
            .animation(.easeInOut(duration: 0.2), value: nameFieldFocused)
            HStack {
                TextField("my-reading-list", text: $curationName)
                    .textFieldStyle(.plain)
                    .textInputAutocapitalization(.never)
                    .autocorrectionDisabled()
                    .onTapGesture { nameFieldFocused = true }
                    .onChange(of: curationName) { _, newValue in
                        if newValue.count > 50 {
                            curationName = String(newValue.prefix(50))
                        }
                    }
                if !curationName.isEmpty {
                    Button(action: { curationName = "" }) {
                        Image(systemName: "xmark.circle.fill")
                            .foregroundColor(DesignSystem.Colors.textSecondary)
                            .transition(.scale.combined(with: .opacity))
                    }
                }
            }
            .padding(DesignSystem.Spacing.base + DesignSystem.Spacing.nano)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(DesignSystem.Colors.surface)
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(
                                nameFieldFocused ? DesignSystem.Colors.primary : Color.gray.opacity(0.2),
                                lineWidth: nameFieldFocused ? 2 : 1
                            )
                    )
            )
        }
        .scaleEffect(animateForm && currentStep >= 0 ? 1 : 0.95)
        .opacity(animateForm && currentStep >= 0 ? 1 : 0)
        .animation(.spring(response: 0.4, dampingFraction: 0.7).delay(0.1), value: animateForm)
    }
    @ViewBuilder
    private var titleField: some View {
        VStack(alignment: .leading, spacing: 10) {
            HStack {
                Label("Title", systemImage: "textformat.alt")
                    .font(DesignSystem.Typography.caption.weight(.medium))
                    .foregroundColor(titleFieldFocused ? DesignSystem.Colors.primary : DesignSystem.Colors.textSecondary)
                Spacer()
                if !curationTitle.isEmpty {
                    Text("\(curationTitle.count)/100")
                        .font(.ds.footnote)
                        .foregroundColor(curationTitle.count > 100 ? .red : DesignSystem.Colors.textSecondary)
                }
            }
            .animation(.easeInOut(duration: 0.2), value: titleFieldFocused)
            HStack {
                TextField("My Reading List", text: $curationTitle)
                    .textFieldStyle(.plain)
                    .onTapGesture { titleFieldFocused = true }
                    .onChange(of: curationTitle) { _, newValue in
                        if newValue.count > 100 {
                            curationTitle = String(newValue.prefix(100))
                        }
                    }
                if !curationTitle.isEmpty {
                    Button(action: { curationTitle = "" }) {
                        Image(systemName: "xmark.circle.fill")
                            .foregroundColor(DesignSystem.Colors.textSecondary)
                            .transition(.scale.combined(with: .opacity))
                    }
                }
            }
            .padding(DesignSystem.Spacing.base + DesignSystem.Spacing.nano)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(DesignSystem.Colors.surface)
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(
                                titleFieldFocused ? DesignSystem.Colors.primary : Color.gray.opacity(0.2),
                                lineWidth: titleFieldFocused ? 2 : 1
                            )
                    )
            )
        }
        .scaleEffect(animateForm && currentStep >= 0 ? 1 : 0.95)
        .opacity(animateForm && currentStep >= 0 ? 1 : 0)
        .animation(.spring(response: 0.4, dampingFraction: 0.7).delay(0.2), value: animateForm)
    }
    @ViewBuilder
    private var descriptionField: some View {
        VStack(alignment: .leading, spacing: 10) {
            HStack {
                Label("Description", systemImage: "text.quote")
                    .font(DesignSystem.Typography.caption.weight(.medium))
                    .foregroundColor(descriptionFieldFocused ? DesignSystem.Colors.primary : DesignSystem.Colors.textSecondary)
                Spacer()
                Text("Optional")
                    .font(.ds.footnote)
                    .foregroundColor(DesignSystem.Colors.textSecondary)
            }
            .animation(.easeInOut(duration: 0.2), value: descriptionFieldFocused)
            ZStack(alignment: .topLeading) {
                if description.isEmpty {
                    Text("Describe your curation...")
                        .foregroundColor(.gray.opacity(0.5))
                        .padding(.horizontal, DesignSystem.Spacing.micro)
                        .padding(.vertical, DesignSystem.Spacing.small)
                }
                TextEditor(text: $description)
                    .font(DesignSystem.Typography.body)
                    .scrollContentBackground(.hidden)
                    .background(Color.clear)
                    .onTapGesture { descriptionFieldFocused = true }
            }
            .padding(DesignSystem.Spacing.base)
            .frame(minHeight: 120)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(DesignSystem.Colors.surface)
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .stroke(
                                descriptionFieldFocused ? DesignSystem.Colors.primary : Color.gray.opacity(0.2),
                                lineWidth: descriptionFieldFocused ? 2 : 1
                            )
                    )
            )
        }
        .scaleEffect(animateForm && currentStep >= 0 ? 1 : 0.95)
        .opacity(animateForm && currentStep >= 0 ? 1 : 0)
        .animation(.spring(response: 0.4, dampingFraction: 0.7).delay(0.3), value: animateForm)
    }
    @ViewBuilder
    private var imageUrlField: some View {
        VStack(alignment: .leading, spacing: 10) {
            Label("Or use image URL", systemImage: "link.circle.fill")
                .font(DesignSystem.Typography.caption.weight(.medium))
                .foregroundColor(DesignSystem.Colors.textSecondary)
            TextField("https://...", text: $imageUrl)
                .textFieldStyle(.plain)
                .textInputAutocapitalization(.never)
                .autocorrectionDisabled()
                .padding(DesignSystem.Spacing.base + DesignSystem.Spacing.nano)
                .background(
                    RoundedRectangle(cornerRadius: 12)
                        .fill(DesignSystem.Colors.surface)
                        .overlay(
                            RoundedRectangle(cornerRadius: 12)
                                .stroke(Color.gray.opacity(0.2), lineWidth: 1)
                        )
                )
        }
        .scaleEffect(animateForm && currentStep >= 0 ? 1 : 0.95)
        .opacity(animateForm && currentStep >= 0 ? 1 : 0)
        .animation(.spring(response: 0.4, dampingFraction: 0.7).delay(0.4), value: animateForm)
    }
    @ViewBuilder
    private var infoBoxSection: some View {
        VStack(spacing: 16) {
            HStack(alignment: .top, spacing: 12) {
                ZStack {
                    Circle()
                        .fill(
                            LinearGradient(
                                colors: [DesignSystem.Colors.primary, DesignSystem.Colors.primary.opacity(0.7)],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 32, height: 32)
                    Image(systemName: "lightbulb.fill")
                        .foregroundColor(.white)
                        .font(.system(size: 16))
                }
                .scaleEffect(pulseAnimation ? 1.1 : 1.0)
                VStack(alignment: .leading, spacing: 6) {
                    Text("What are Article Curations?")
                        .font(DesignSystem.Typography.body.weight(.semibold))
                        .foregroundColor(DesignSystem.Colors.text)
                    Text("Create themed collections of articles, highlights, and content. Perfect for organizing your reading lists, research topics, or sharing knowledge with others.")
                        .font(DesignSystem.Typography.caption)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                        .fixedSize(horizontal: false, vertical: true)
                }
                Spacer()
            }
            // Feature highlights
            HStack(spacing: 16) {
                FeatureBadge(icon: "folder.fill", text: "Organize", color: DesignSystem.Colors.primary)
                FeatureBadge(icon: "square.and.arrow.up", text: "Share", color: DesignSystem.Colors.secondary)
                FeatureBadge(icon: "sparkles", text: "Discover", color: .blue)
            }
        }
        .padding(DesignSystem.Spacing.large)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(.ultraThinMaterial)
                .overlay(
                    RoundedRectangle(cornerRadius: 16)
                        .stroke(
                            LinearGradient(
                                colors: [DesignSystem.Colors.primary.opacity(0.3), DesignSystem.Colors.secondary.opacity(0.3)],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ),
                            lineWidth: 1
                        )
                )
        )
        .padding(.horizontal)
        .scaleEffect(animateForm ? 1 : 0.95)
        .opacity(animateForm ? 1 : 0)
        .animation(.spring(response: 0.4, dampingFraction: 0.7).delay(0.5), value: animateForm)
    }
    @ViewBuilder
    private var createButtonSection: some View {
        VStack(spacing: 12) {
            Button(action: createCuration) {
                ZStack {
                    // Background gradient
                    RoundedRectangle(cornerRadius: 16)
                        .fill(
                            LinearGradient(
                                colors: isFormValid ? 
                                    [DesignSystem.Colors.primary, DesignSystem.Colors.primary.opacity(0.8)] :
                                    [.gray.opacity(0.3), .gray.opacity(0.2)],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                    // Shimmer effect when valid
                    if isFormValid {
                        RoundedRectangle(cornerRadius: 16)
                            .fill(
                                LinearGradient(
                                    colors: [
                                        Color.white.opacity(0),
                                        Color.white.opacity(0.3),
                                        Color.white.opacity(0)
                                    ],
                                    startPoint: .leading,
                                    endPoint: .trailing
                                )
                            )
                            .mask(
                                RoundedRectangle(cornerRadius: 16)
                                    .fill(
                                        LinearGradient(
                                            colors: [.clear, .white, .clear],
                                            startPoint: .leading,
                                            endPoint: .trailing
                                        )
                                    )
                                    .offset(x: isFormValid ? 200 : -200)
                                    .animation(
                                        .linear(duration: 1.5)
                                        .repeatForever(autoreverses: false),
                                        value: isFormValid
                                    )
                            )
                    }
                    HStack(spacing: 8) {
                        Image(systemName: "folder.badge.plus")
                            .font(.system(size: 18, weight: .semibold))
                            .symbolEffect(.bounce, value: isFormValid)
                        Text("Create Curation")
                            .font(DesignSystem.Typography.body.weight(.semibold))
                    }
                    .foregroundColor(.white)
                }
                .frame(height: 56)
                .disabled(!isFormValid)
                .scaleEffect(isFormValid ? 1 : 0.98)
                .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isFormValid)
            }
            Text("You can add articles and highlights after creating")
                .font(DesignSystem.Typography.caption)
                .foregroundColor(DesignSystem.Colors.textSecondary)
        }
        .padding(.horizontal)
        .padding(.bottom, 32)
        .scaleEffect(animateForm ? 1 : 0.95)
        .opacity(animateForm ? 1 : 0)
        .animation(.spring(response: 0.4, dampingFraction: 0.7).delay(0.6), value: animateForm)
    }
    var body: some View {
        NavigationStack {
            ZStack {
                // Animated background
                AnimatedBackgroundView(particleAnimation: $particleAnimation)
                ScrollViewReader { proxy in
                    ScrollView {
                        VStack(spacing: 0) {
                            // Progress indicator
                            ProgressIndicatorView(currentStep: currentStep, totalSteps: 3)
                                .padding(.horizontal)
                                .padding(.top, 8)
                                .opacity(animateHeader ? 1 : 0)
                                .offset(y: animateHeader ? 0 : -20)
                            VStack(spacing: 24) {
                                // Header image section
                                headerImageSection
                                // Color picker
                                colorPickerSection
                                // Form fields
                                formFieldsSection
                                // Info box
                                infoBoxSection
                                // Create button
                                createButtonSection
                            }
                        }
                        .padding(.bottom, keyboardHeight)
                        .animation(.easeOut(duration: 0.25), value: keyboardHeight)
                        .id("scrollView")
                    }
                    .onTapGesture {
                        nameFieldFocused = false
                        titleFieldFocused = false
                        descriptionFieldFocused = false
                        UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
                    }
                }
            }
            .background(DesignSystem.Colors.background.ignoresSafeArea())
            .navigationTitle("New Curation")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        HapticManager.shared.impact(.light)
                        dismiss()
                    }
                    .foregroundColor(DesignSystem.Colors.primary)
                }
            }
            .photosPicker(
                isPresented: $showImagePicker,
                selection: $selectedImage,
                matching: .images
            )
            .onChange(of: selectedImage) { _, newValue in
                Task {
                    if let data = try? await newValue?.loadTransferable(type: Data.self) {
                        await MainActor.run {
                            selectedImageData = data
                            HapticManager.shared.impact(.medium)
                        }
                    }
                }
            }
            .onAppear {
                startAnimations()
            }
            .onReceive(NotificationCenter.default.publisher(for: UIResponder.keyboardWillShowNotification)) { notification in
                if let keyboardFrame = notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? CGRect {
                    keyboardHeight = keyboardFrame.height
                }
            }
            .onReceive(NotificationCenter.default.publisher(for: UIResponder.keyboardWillHideNotification)) { _ in
                keyboardHeight = 0
            }
        }
        .alert("Error", isPresented: $showError) {
            Button("OK") { }
        } message: {
            Text(errorMessage)
        }
    }
    private func startAnimations() {
        withAnimation(.easeOut(duration: 0.6)) {
            animateHeader = true
        }
        withAnimation(.easeOut(duration: 0.8).delay(0.2)) {
            animateForm = true
        }
        withAnimation(.easeInOut(duration: 2).repeatForever(autoreverses: true)) {
            pulseAnimation = true
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            particleAnimation = true
        }
    }
    private func createCuration() {
        guard isFormValid else { return }
        HapticManager.shared.impact(.medium)
        Task {
            do {
                try await appState.createCuration(
                    name: curationName,
                    title: curationTitle,
                    description: description.isEmpty ? nil : description,
                    image: imageUrl.isEmpty ? nil : imageUrl
                )
                await MainActor.run {
                    HapticManager.shared.notification(.success)
                    dismiss()
                }
            } catch {
                await MainActor.run {
                    errorMessage = error.localizedDescription
                    showError = true
                    HapticManager.shared.notification(.error)
                }
            }
        }
    }
}
// MARK: - Supporting Views
struct ProgressIndicatorView: View {
    let currentStep: Int
    let totalSteps: Int
    var body: some View {
        HStack(spacing: 8) {
            ForEach(0..<totalSteps, id: \.self) { step in
                Capsule()
                    .fill(step <= currentStep ? DesignSystem.Colors.primary : Color.gray.opacity(0.3))
                    .frame(height: 4)
                    .animation(.spring(response: 0.4, dampingFraction: 0.8), value: currentStep)
            }
        }
        .frame(height: 4)
    }
}
struct FeatureBadge: View {
    let icon: String
    let text: String
    let color: Color
    @State private var isAnimating = false
    var body: some View {
        VStack(spacing: 6) {
            ZStack {
                Circle()
                    .fill(color.opacity(0.15))
                    .frame(width: 40, height: 40)
                Image(systemName: icon)
                    .font(.system(size: 18))
                    .foregroundColor(color)
                    .scaleEffect(isAnimating ? 1.1 : 1.0)
            }
            Text(text)
                .font(.ds.footnote)
                .foregroundColor(DesignSystem.Colors.textSecondary)
        }
        .onAppear {
            withAnimation(.easeInOut(duration: 2).repeatForever(autoreverses: true)) {
                isAnimating = true
            }
        }
    }
}
struct AnimatedBackgroundView: View {
    @Binding var particleAnimation: Bool
    @State private var gradientRotation = 0.0
    var body: some View {
        ZStack {
            // Base gradient
            LinearGradient(
                colors: [
                    DesignSystem.Colors.background,
                    DesignSystem.Colors.primary.opacity(0.05),
                    DesignSystem.Colors.secondary.opacity(0.03)
                ],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            // Animated gradient overlay
            LinearGradient(
                colors: [
                    DesignSystem.Colors.primary.opacity(0.03),
                    Color.clear,
                    DesignSystem.Colors.secondary.opacity(0.03)
                ],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            .rotationEffect(.degrees(gradientRotation))
            .onAppear {
                withAnimation(.linear(duration: 20).repeatForever(autoreverses: false)) {
                    gradientRotation = 360
                }
            }
        }
        .ignoresSafeArea()
    }
}
#Preview {
    CreateCurationView()
        .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Views/Curations/CurationDetailView.swift">
import SwiftUI
import NDKSwift
struct CurationDetailView: View {
    let curation: ArticleCuration
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) var dismiss
    @State private var isFollowing = false
    @State private var showAddArticle = false
    @State private var curator: NDKUserProfile?
    @State private var currentUserPubkey: String?
    @State private var loadedArticles: [Article] = []
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: 24) {
                    // Header
                    ZStack(alignment: .bottomLeading) {
                        // Cover image
                        if let imageUrl = curation.image, let url = URL(string: imageUrl) {
                            AsyncImage(url: url) { image in
                                image
                                    .resizable()
                                    .aspectRatio(contentMode: .fill)
                            } placeholder: {
                                Rectangle()
                                    .fill(
                                        LinearGradient(
                                            colors: [
                                                DesignSystem.Colors.primary.opacity(0.3),
                                                DesignSystem.Colors.secondary.opacity(0.3)
                                            ],
                                            startPoint: .topLeading,
                                            endPoint: .bottomTrailing
                                        )
                                    )
                            }
                            .frame(height: 250)
                            .clipped()
                        } else {
                            Rectangle()
                                .fill(
                                    LinearGradient(
                                        colors: [
                                            DesignSystem.Colors.primary.opacity(0.5),
                                            DesignSystem.Colors.secondary.opacity(0.5)
                                        ],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                                .frame(height: 250)
                        }
                        // Gradient overlay
                        LinearGradient(
                            colors: [Color.clear, Color.black.opacity(0.7)],
                            startPoint: .center,
                            endPoint: .bottom
                        )
                        // Title overlay
                        VStack(alignment: .leading, spacing: 8) {
                            Text(curation.title)
                                .font(DesignSystem.Typography.title)
                                .foregroundColor(.white)
                            if let description = curation.description {
                                Text(description)
                                    .font(DesignSystem.Typography.body)
                                    .foregroundColor(.white.opacity(0.9))
                                    .lineLimit(2)
                            }
                        }
                        .padding()
                    }
                    // Curator info
                    HStack {
                        Image(systemName: "person.circle.fill")
                            .font(.system(size: 44))
                            .foregroundColor(DesignSystem.Colors.primary)
                        VStack(alignment: .leading, spacing: 4) {
                            Text(curator?.name ?? curator?.displayName ?? "Curator")
                                .font(DesignSystem.Typography.body)
                                .fontWeight(.medium)
                            Text("\(curation.articles.count) articles • Updated \(relativeTime(from: curation.updatedAt))")
                                .font(DesignSystem.Typography.caption)
                                .foregroundColor(DesignSystem.Colors.textSecondary)
                        }
                        Spacer()
                        Button(action: toggleFollow) {
                            Text(isFollowing ? "Following" : "Follow")
                                .font(DesignSystem.Typography.caption)
                                .fontWeight(.medium)
                                .padding(.horizontal, 20)
                                .padding(.vertical, 10)
                                .background(isFollowing ? DesignSystem.Colors.textTertiary : DesignSystem.Colors.primary)
                                .foregroundColor(.white)
                                .cornerRadius(DesignSystem.CornerRadius.xl)
                        }
                    }
                    .padding(.horizontal)
                    // Action buttons
                    HStack(spacing: 12) {
                        Button(action: shareCuration) {
                            Label("Share", systemImage: "square.and.arrow.up")
                                .font(DesignSystem.Typography.caption)
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, DesignSystem.Spacing.base)
                                .background(DesignSystem.Colors.surface)
                                .cornerRadius(DesignSystem.CornerRadius.medium)
                        }
                        if let userPubkey = currentUserPubkey, curation.author == userPubkey {
                            Button(action: { showAddArticle = true }) {
                                Label("Add Article", systemImage: "plus.circle")
                                    .font(DesignSystem.Typography.caption)
                                    .frame(maxWidth: .infinity)
                                    .padding(.vertical, 12)
                                    .background(DesignSystem.Colors.primary)
                                    .foregroundColor(.white)
                                    .cornerRadius(DesignSystem.CornerRadius.medium)
                            }
                        }
                    }
                    .padding(.horizontal)
                    // Articles
                    VStack(alignment: .leading, spacing: 16) {
                        Text("Articles")
                            .font(DesignSystem.Typography.headline)
                            .padding(.horizontal)
                        if loadedArticles.isEmpty && curation.articles.isEmpty {
                            EmptyArticlesView()
                                .padding(.horizontal)
                        } else {
                            // Show loaded articles
                            ForEach(loadedArticles) { article in
                                LoadedArticleCard(article: article)
                                    .padding(.horizontal)
                            }
                            // Show unresolved references (URLs only)
                            ForEach(curation.articles.filter { ref in 
                                ref.url != nil && !loadedArticles.contains { $0.event.id == ref.eventId }
                            }, id: \.url) { reference in
                                ArticleCard(article: reference)
                                    .padding(.horizontal)
                            }
                        }
                    }
                }
                .padding(.bottom)
            }
            .background(DesignSystem.Colors.background)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(DesignSystem.Colors.primary)
                }
            }
        }
        .task {
            await loadCurator()
            await loadArticles()
            // Load current user pubkey
            if let signer = appState.activeSigner {
                currentUserPubkey = try? await signer.pubkey
            }
        }
        .sheet(isPresented: $showAddArticle) {
            AddArticleSheet(curation: curation)
                .environmentObject(appState)
        }
    }
    private func loadCurator() async {
        guard let ndk = appState.ndk else { return }
        for await profile in await ndk.profileManager.observe(for: curation.author, maxAge: TimeConstants.hour) {
            await MainActor.run {
                self.curator = profile
            }
            break
        }
    }
    private func loadArticles() async {
        guard let ndk = appState.ndk else { return }
        // Collect event IDs and addresses to fetch
        var eventIds: [String] = []
        var eventAddresses: [(kind: Int, pubkey: String, identifier: String)] = []
        for reference in curation.articles {
            if let eventId = reference.eventId {
                eventIds.append(eventId)
            } else if let address = reference.eventAddress {
                // Parse NIP-33 address format: <kind>:<pubkey>:<d-tag>
                let parts = address.split(separator: ":")
                if parts.count == 3,
                   let kind = Int(parts[0]) {
                    eventAddresses.append((
                        kind: kind,
                        pubkey: String(parts[1]),
                        identifier: String(parts[2])
                    ))
                }
            }
        }
        // Stream articles by event ID
        if !eventIds.isEmpty {
            Task {
                let filter = NDKFilter(ids: eventIds)
                let articleSource = await ndk.outbox.observe(
                    filter: filter,
                    maxAge: 300,
                    cachePolicy: .cacheWithNetwork
                )
                for await event in articleSource.events {
                    if event.kind == 30023,
                       let article = try? Article(from: event) {
                        await MainActor.run {
                            if !loadedArticles.contains(where: { $0.id == article.id }) {
                                loadedArticles.append(article)
                                loadedArticles.sort { $0.createdAt > $1.createdAt }
                            }
                        }
                    }
                }
            }
        }
        // Stream articles by address (NIP-33 parameterized replaceable events)
        for address in eventAddresses {
            Task {
                let filter = NDKFilter(
                    authors: [address.pubkey],
                    kinds: [address.kind]
                )
                let articleSource = await ndk.outbox.observe(
                    filter: filter,
                    maxAge: 300,
                    cachePolicy: .cacheWithNetwork
                )
                for await event in articleSource.events {
                    // Check if this event has the matching d-tag
                    if let dTag = event.tags.first(where: { $0.first == "d" })?[safe: 1],
                       dTag == address.identifier,
                       event.kind == 30023,
                       let article = try? Article(from: event) {
                        await MainActor.run {
                            if !loadedArticles.contains(where: { $0.id == article.id }) {
                                loadedArticles.append(article)
                                loadedArticles.sort { $0.createdAt > $1.createdAt }
                            }
                        }
                    }
                }
            }
        }
    }
    private func toggleFollow() {
        isFollowing.toggle()
        HapticManager.shared.impact(.light)
        // Note: Follow functionality requires contact list management (NIP-02)
        // This demo focuses on curation display features
    }
    private func shareCuration() {
        HapticManager.shared.impact(.light)
        // Note: Share functionality would generate a shareable link or QR code
        // This demo focuses on core curation features
    }
    private func relativeTime(from date: Date) -> String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: date, relativeTo: Date())
    }
}
struct ArticleCard: View {
    let article: ArticleCuration.ArticleReference
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            if let url = article.url {
                HStack {
                    VStack(alignment: .leading, spacing: 8) {
                        Text(URL(string: url)?.host ?? "Article")
                            .font(DesignSystem.Typography.caption)
                            .foregroundColor(DesignSystem.Colors.primary)
                        Text(url)
                            .font(DesignSystem.Typography.body)
                            .lineLimit(2)
                            .foregroundColor(DesignSystem.Colors.text)
                        Text("Added \(relativeTime(from: article.addedAt))")
                            .font(DesignSystem.Typography.caption)
                            .foregroundColor(DesignSystem.Colors.textSecondary)
                    }
                    Spacer()
                    Image(systemName: "arrow.up.right")
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                }
                .modernCard()
                .onTapGesture {
                    if let url = URL(string: url) {
                        UIApplication.shared.open(url)
                    }
                }
            }
        }
    }
    private func relativeTime(from date: Date) -> String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: date, relativeTo: Date())
    }
}
struct EmptyArticlesView: View {
    var body: some View {
        VStack(spacing: 16) {
            Image(systemName: "doc.text.magnifyingglass")
                .font(.system(size: 48))
                .foregroundColor(DesignSystem.Colors.primary.opacity(0.5))
            Text("No articles yet")
                .font(DesignSystem.Typography.body)
                .foregroundColor(DesignSystem.Colors.textSecondary)
            Text("Articles added to this curation will appear here")
                .font(DesignSystem.Typography.caption)
                .foregroundColor(DesignSystem.Colors.textSecondary)
                .multilineTextAlignment(.center)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 40)
        .background(DesignSystem.Colors.surface.opacity(0.5))
        .cornerRadius(DesignSystem.CornerRadius.medium)
    }
}
struct LoadedArticleCard: View {
    let article: Article
    @State private var showArticleView = false
    @State private var author: NDKUserProfile?
    @EnvironmentObject var appState: AppState
    var body: some View {
        Button(action: { showArticleView = true }) {
            VStack(alignment: .leading, spacing: 12) {
                HStack(alignment: .top, spacing: 12) {
                    // Article image thumbnail
                    if let imageUrl = article.image, let url = URL(string: imageUrl) {
                        AsyncImage(url: url) { image in
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                        } placeholder: {
                            Rectangle()
                                .fill(DesignSystem.Colors.surface)
                        }
                        .frame(width: 80, height: 80)
                        .cornerRadius(DesignSystem.CornerRadius.small)
                        .clipped()
                    }
                    VStack(alignment: .leading, spacing: 8) {
                        Text(article.title)
                            .font(DesignSystem.Typography.body)
                            .fontWeight(.medium)
                            .foregroundColor(DesignSystem.Colors.text)
                            .lineLimit(2)
                            .multilineTextAlignment(.leading)
                        if let summary = article.summary {
                            Text(summary)
                                .font(DesignSystem.Typography.caption)
                                .foregroundColor(DesignSystem.Colors.textSecondary)
                                .lineLimit(2)
                        }
                        HStack(spacing: 8) {
                            if let author = author {
                                Text(author.name ?? author.displayName ?? "Anonymous")
                                    .font(DesignSystem.Typography.caption)
                                    .foregroundColor(DesignSystem.Colors.primary)
                            }
                            Text("•")
                                .foregroundColor(DesignSystem.Colors.textSecondary)
                            Text(relativeTime(from: article.createdAt))
                                .font(DesignSystem.Typography.caption)
                                .foregroundColor(DesignSystem.Colors.textSecondary)
                            Text("•")
                                .foregroundColor(DesignSystem.Colors.textSecondary)
                            Text("\(article.estimatedReadingTime) min read")
                                .font(DesignSystem.Typography.caption)
                                .foregroundColor(DesignSystem.Colors.textSecondary)
                        }
                    }
                    Spacer()
                }
                .modernCard()
            }
        }
        .buttonStyle(PlainButtonStyle())
        .sheet(isPresented: $showArticleView) {
            ArticleView(article: article)
                .environmentObject(appState)
        }
        .task {
            await loadAuthor()
        }
    }
    private func loadAuthor() async {
        guard let ndk = appState.ndk else { return }
        for await profile in await ndk.profileManager.observe(for: article.author, maxAge: TimeConstants.hour) {
            await MainActor.run {
                self.author = profile
            }
            break
        }
    }
    private func relativeTime(from date: Date) -> String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: date, relativeTo: Date())
    }
}
struct AddArticleSheet: View {
    let curation: ArticleCuration
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) var dismiss
    @State private var articleUrl = ""
    @State private var showError = false
    @State private var errorMessage = ""
    var body: some View {
        NavigationStack {
            VStack(alignment: .leading, spacing: 24) {
                Text("Add Article")
                    .font(DesignSystem.Typography.headline)
                Text("Add an article URL to your curation")
                    .font(DesignSystem.Typography.body)
                    .foregroundColor(DesignSystem.Colors.textSecondary)
                TextField("https://...", text: $articleUrl)
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .textInputAutocapitalization(.never)
                    .autocorrectionDisabled()
                Button(action: addArticle) {
                    HStack {
                        Image(systemName: "plus.circle")
                        Text("Add Article")
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(DesignSystem.Colors.primary)
                    .foregroundColor(.white)
                    .cornerRadius(DesignSystem.CornerRadius.medium)
                }
                .disabled(articleUrl.isEmpty)
                Spacer()
            }
            .padding()
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
        }
        .alert("Error", isPresented: $showError) {
            Button("OK") { }
        } message: {
            Text(errorMessage)
        }
    }
    private func addArticle() {
        guard !articleUrl.isEmpty else { return }
        HapticManager.shared.impact(.light)
        Task {
            // Note: Adding articles requires updating the curation event
            // This demo focuses on curation viewing
            await MainActor.run {
                dismiss()
            }
        }
    }
}
#Preview {
    CurationDetailView(
        curation: ArticleCuration(
            id: "1",
            event: NDKEvent(id: "", pubkey: "", createdAt: 0, kind: 30004, tags: [], content: "", sig: ""),
            name: "best-reads-2024",
            title: "Best Reads of 2024",
            description: "A collection of the most insightful articles I've read this year",
            image: nil,
            author: "test",
            createdAt: Date(),
            updatedAt: Date(),
            articles: []
        )
    )
    .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Views/Curations/CurationManagementView.swift">
import SwiftUI
import NDKSwift
import UniformTypeIdentifiers
// Move DraggedArticle outside to make it accessible to nested types
struct DraggedArticle: Codable, Transferable {
    let url: String?
    let eventId: String?
    let title: String
    var identifier: String {
        eventId ?? url ?? title
    }
    static var typeIdentifier: String {
        UTType.draggedArticle.identifier
    }
    static var transferRepresentation: some TransferRepresentation {
        CodableRepresentation(contentType: .draggedArticle)
    }
}
extension UTType {
    static let draggedArticle = UTType(exportedAs: "com.highlighter.draggedArticle")
}
struct CurationManagementView: View {
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) var dismiss
    // View state
    @State private var viewMode: ViewMode = .grid
    @State private var searchText = ""
    @State private var sortOption: SortOption = .recent
    @State private var selectedCurations: Set<ArticleCuration> = []
    @State private var isEditMode = false
    @State private var showCreateCuration = false
    @State private var curationToEdit: ArticleCuration?
    @State private var showDeleteConfirmation = false
    // Drag and drop state
    @State private var draggedArticle: DraggedArticle?
    @State private var hoveredCuration: ArticleCuration?
    @State private var dropAnimation = false
    // Animation state
    @State private var appearAnimation = false
    @State private var headerAnimation = false
    @Namespace private var animation
    enum ViewMode: String, CaseIterable {
        case grid = "square.grid.2x2"
        case list = "list.bullet"
        case carousel = "rectangle.stack"
        var title: String {
            switch self {
            case .grid: return "Grid"
            case .list: return "List"
            case .carousel: return "Carousel"
            }
        }
    }
    enum SortOption: String, CaseIterable {
        case recent = "Recent"
        case alphabetical = "A-Z"
        case articleCount = "Most Articles"
        var icon: String {
            switch self {
            case .recent: return "clock"
            case .alphabetical: return "textformat"
            case .articleCount: return "number"
            }
        }
    }
    var filteredCurations: [ArticleCuration] {
        let curations = appState.userCurations.filter { curation in
            searchText.isEmpty ||
            curation.title.localizedCaseInsensitiveContains(searchText) ||
            (curation.description ?? "").localizedCaseInsensitiveContains(searchText)
        }
        switch sortOption {
        case .recent:
            return curations.sorted { $0.updatedAt > $1.updatedAt }
        case .alphabetical:
            return curations.sorted { $0.title.localizedCompare($1.title) == .orderedAscending }
        case .articleCount:
            return curations.sorted { $0.articles.count > $1.articles.count }
        }
    }
    var body: some View {
        NavigationStack {
            ZStack {
                // Background gradient
                LinearGradient(
                    colors: [
                        DesignSystem.Colors.background,
                        DesignSystem.Colors.primary.opacity(0.03),
                        DesignSystem.Colors.secondary.opacity(0.02)
                    ],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .ignoresSafeArea()
                VStack(spacing: 0) {
                    // Enhanced header
                    VStack(spacing: 16) {
                        // Search bar with animations
                        HStack(spacing: 12) {
                            HStack {
                                Image(systemName: "magnifyingglass")
                                    .foregroundColor(DesignSystem.Colors.textSecondary)
                                    .font(.system(size: 16))
                                TextField("Search curations...", text: $searchText)
                                    .textFieldStyle(.plain)
                                if !searchText.isEmpty {
                                    Button(action: { searchText = "" }) {
                                        Image(systemName: "xmark.circle.fill")
                                            .foregroundColor(DesignSystem.Colors.textSecondary)
                                            .transition(.scale.combined(with: .opacity))
                                    }
                                }
                            }
                            .padding(.horizontal, 12)
                            .padding(.vertical, 10)
                            .background(DesignSystem.Colors.surface)
                            .cornerRadius(DesignSystem.CornerRadius.medium)
                            .overlay(
                                RoundedRectangle(cornerRadius: 12)
                                    .stroke(Color.gray.opacity(0.2), lineWidth: 1)
                            )
                            // Sort button
                            Menu {
                                ForEach(SortOption.allCases, id: \.self) { option in
                                    Button(action: { 
                                        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                            sortOption = option
                                        }
                                        HapticManager.shared.impact(.light)
                                    }) {
                                        Label(option.rawValue, systemImage: option.icon)
                                    }
                                }
                            } label: {
                                Image(systemName: "arrow.up.arrow.down.circle.fill")
                                    .font(.title2)
                                    .foregroundColor(DesignSystem.Colors.primary)
                                    .symbolEffect(.bounce, value: sortOption)
                            }
                        }
                        .padding(.horizontal)
                        .opacity(headerAnimation ? 1 : 0)
                        .offset(y: headerAnimation ? 0 : -20)
                        // View mode selector with smooth transitions
                        HStack(spacing: 0) {
                            ForEach(ViewMode.allCases, id: \.self) { mode in
                                Button(action: {
                                    withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                        viewMode = mode
                                    }
                                    HapticManager.shared.impact(.light)
                                }) {
                                    VStack(spacing: 4) {
                                        Image(systemName: mode.rawValue)
                                            .font(.system(size: 20))
                                            .foregroundColor(viewMode == mode ? .white : DesignSystem.Colors.textSecondary)
                                        Text(mode.title)
                                            .font(.caption2)
                                            .foregroundColor(viewMode == mode ? .white : DesignSystem.Colors.textSecondary)
                                    }
                                    .frame(maxWidth: .infinity)
                                    .padding(.vertical, 8)
                                    .background(
                                        ZStack {
                                            if viewMode == mode {
                                                RoundedRectangle(cornerRadius: 10)
                                                    .fill(DesignSystem.Colors.primary)
                                                    .matchedGeometryEffect(id: "viewMode", in: animation)
                                            }
                                        }
                                    )
                                }
                                .buttonStyle(PlainButtonStyle())
                            }
                        }
                        .padding(4)
                        .background(DesignSystem.Colors.surface)
                        .cornerRadius(14)
                        .padding(.horizontal)
                        .opacity(headerAnimation ? 1 : 0)
                        .offset(y: headerAnimation ? 0 : -20)
                    }
                    .padding(.top, 16)
                    .padding(.bottom, 20)
                    // Content area with transitions
                    ZStack {
                        switch viewMode {
                        case .grid:
                            GridView(
                                curations: filteredCurations,
                                selectedCurations: $selectedCurations,
                                isEditMode: isEditMode,
                                hoveredCuration: $hoveredCuration,
                                draggedArticle: draggedArticle,
                                curationToEdit: $curationToEdit,
                                shareCuration: shareCuration,
                                deleteCuration: deleteCuration,
                                addArticleToCuration: addArticleToCuration
                            )
                            .transition(.asymmetric(
                                insertion: .move(edge: .leading).combined(with: .opacity),
                                removal: .move(edge: .trailing).combined(with: .opacity)
                            ))
                        case .list:
                            ListView(
                                curations: filteredCurations,
                                selectedCurations: $selectedCurations,
                                isEditMode: isEditMode,
                                hoveredCuration: $hoveredCuration,
                                draggedArticle: draggedArticle,
                                curationToEdit: $curationToEdit,
                                shareCuration: shareCuration,
                                deleteCuration: deleteCuration,
                                addArticleToCuration: addArticleToCuration
                            )
                            .transition(.asymmetric(
                                insertion: .scale(scale: 0.9).combined(with: .opacity),
                                removal: .scale(scale: 1.1).combined(with: .opacity)
                            ))
                        case .carousel:
                            CarouselView(
                                curations: filteredCurations,
                                curationToEdit: $curationToEdit
                            )
                            .transition(.asymmetric(
                                insertion: .move(edge: .trailing).combined(with: .opacity),
                                removal: .move(edge: .leading).combined(with: .opacity)
                            ))
                        }
                    }
                    .opacity(appearAnimation ? 1 : 0)
                    .scaleEffect(appearAnimation ? 1 : 0.95)
                    // Empty state
                    if filteredCurations.isEmpty {
                        EmptyStateView(searchText: searchText)
                            .transition(.scale.combined(with: .opacity))
                    }
                }
            }
            .navigationTitle("Manage Curations")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Done") {
                        HapticManager.shared.impact(.light)
                        dismiss()
                    }
                    .foregroundColor(DesignSystem.Colors.primary)
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    HStack(spacing: 16) {
                        if !filteredCurations.isEmpty {
                            Button(action: {
                                withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                    isEditMode.toggle()
                                    if !isEditMode {
                                        selectedCurations.removeAll()
                                    }
                                }
                                HapticManager.shared.impact(.light)
                            }) {
                                Text(isEditMode ? "Done" : "Edit")
                                    .foregroundColor(DesignSystem.Colors.primary)
                            }
                        }
                        Button(action: { showCreateCuration = true }) {
                            Image(systemName: "plus.circle.fill")
                                .font(.title2)
                                .foregroundColor(DesignSystem.Colors.primary)
                                .symbolEffect(.bounce, value: showCreateCuration)
                        }
                    }
                }
            }
            .sheet(isPresented: $showCreateCuration) {
                CreateCurationView()
                    .environmentObject(appState)
            }
            .sheet(item: $curationToEdit) { curation in
                CurationDetailView(curation: curation)
                    .environmentObject(appState)
            }
            .confirmationDialog(
                "Delete \(selectedCurations.count) Curation\(selectedCurations.count == 1 ? "" : "s")?",
                isPresented: $showDeleteConfirmation,
                titleVisibility: .visible
            ) {
                Button("Delete", role: .destructive) {
                    deleteCurations()
                }
            } message: {
                Text("This action cannot be undone.")
            }
            .onAppear {
                startAnimations()
            }
            .onDrop(of: [.draggedArticle], isTargeted: nil) { providers in
                handleDrop(providers: providers)
            }
        }
    }
    private func startAnimations() {
        withAnimation(.easeOut(duration: 0.4)) {
            appearAnimation = true
        }
        withAnimation(.easeOut(duration: 0.5).delay(0.1)) {
            headerAnimation = true
        }
    }
    private func deleteCurations() {
        Task {
            do {
                // Convert Set to Array for the deletion
                let curationsToDelete = Array(selectedCurations)
                // Publish deletion events
                try await appState.publishingService.deleteCurations(curationsToDelete)
                // Note: Local state removal would be handled by DataStreamManager
                // when it receives the deletion events from the relays
                HapticManager.shared.notification(.success)
                selectedCurations.removeAll()
                isEditMode = false
            } catch {
                HapticManager.shared.notification(.error)
                // Could show an error alert here
            }
        }
    }
    private func handleDrop(providers: [NSItemProvider]) -> Bool {
        for provider in providers {
            if provider.hasItemConformingToTypeIdentifier(UTType.draggedArticle.identifier) {
                _ = provider.loadTransferable(type: DraggedArticle.self) { result in
                    switch result {
                    case .success(_):
                        DispatchQueue.main.async {
                            // Handle adding article to curation
                            HapticManager.shared.impact(.medium)
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                dropAnimation = true
                            }
                            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                                dropAnimation = false
                            }
                        }
                    case .failure(_):
                        // Failed to load dragged article
                        break
                    }
                }
                return true
            }
        }
        return false
    }
    private func shareCuration(_ curation: ArticleCuration) {
        let shareText = """
        Check out my curation: \(curation.title)
        \(curation.description ?? "A collection of articles on Nostr")
        nostr:\(curation.id)
        """
        let activityController = UIActivityViewController(
            activityItems: [shareText],
            applicationActivities: nil
        )
        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let window = windowScene.windows.first,
           let rootViewController = window.rootViewController {
            rootViewController.present(activityController, animated: true)
        }
    }
    private func deleteCuration(_ curation: ArticleCuration) {
        Task {
            do {
                // Delete the curation event
                try await appState.publishingService.deleteCuration(curation)
                await MainActor.run {
                    // Remove from selected curations if present
                    selectedCurations.remove(curation)
                    HapticManager.shared.notification(.success)
                }
            } catch {
                await MainActor.run {
                    HapticManager.shared.notification(.error)
                }
            }
        }
    }
    private func addArticleToCuration(_ article: DraggedArticle, _ curation: ArticleCuration) async {
        // Find the actual article from the data
        guard let actualArticle = appState.articles.first(where: { $0.id == article.identifier }) else {
            HapticManager.shared.notification(.error)
            return
        }
        do {
            try await appState.publishingService.updateCuration(curation, addingArticle: actualArticle)
            HapticManager.shared.notification(.success)
        } catch {
            HapticManager.shared.notification(.error)
        }
    }
}
// MARK: - Grid View
struct GridView: View {
    let curations: [ArticleCuration]
    @Binding var selectedCurations: Set<ArticleCuration>
    let isEditMode: Bool
    @Binding var hoveredCuration: ArticleCuration?
    let draggedArticle: DraggedArticle?
    @Binding var curationToEdit: ArticleCuration?
    let shareCuration: (ArticleCuration) -> Void
    let deleteCuration: (ArticleCuration) -> Void
    let addArticleToCuration: (DraggedArticle, ArticleCuration) async -> Void
    @State private var dropTargets: [String: Bool] = [:]
    let columns = [
        GridItem(.flexible(), spacing: 16),
        GridItem(.flexible(), spacing: 16)
    ]
    var body: some View {
        ScrollView {
            LazyVGrid(columns: columns, spacing: 16) {
                ForEach(curations) { curation in
                    gridItem(for: curation)
                }
            }
            .padding()
        }
    }
    @ViewBuilder
    private func gridItem(for curation: ArticleCuration) -> some View {
        let isSelected = selectedCurations.contains(curation)
        let isHovered = hoveredCuration?.id == curation.id && draggedArticle != nil
        CurationGridItem(
            curation: curation,
            isSelected: isSelected,
            isEditMode: isEditMode,
            isHovered: isHovered
        )
        .onTapGesture {
            handleTap(curation: curation)
        }
        .onDrop(of: [.draggedArticle], isTargeted: Binding(
            get: { dropTargets[curation.id] ?? false },
            set: { isTargeted in
                dropTargets[curation.id] = isTargeted
                hoveredCuration = isTargeted ? curation : nil
            }
        )) { providers in
            handleDropOnCuration(providers: providers, curation: curation)
        }
        .contextMenu {
            CurationContextMenu(curation: curation, curationToEdit: $curationToEdit, shareCuration: shareCuration, deleteCuration: deleteCuration)
        }
    }
    private func handleTap(curation: ArticleCuration) {
        if isEditMode {
            toggleSelection(curation)
        } else {
            curationToEdit = curation
        }
    }
    private func toggleSelection(_ curation: ArticleCuration) {
        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
            if selectedCurations.contains(curation) {
                selectedCurations.remove(curation)
            } else {
                selectedCurations.insert(curation)
            }
        }
        HapticManager.shared.impact(.light)
    }
    private func handleDropOnCuration(providers: [NSItemProvider], curation: ArticleCuration) -> Bool {
        guard let provider = providers.first,
              provider.hasItemConformingToTypeIdentifier(DraggedArticle.typeIdentifier) else {
            return false
        }
        provider.loadDataRepresentation(forTypeIdentifier: DraggedArticle.typeIdentifier) { data, error in
            guard let data = data,
                  let draggedArticle = try? JSONDecoder().decode(DraggedArticle.self, from: data) else {
                return
            }
            Task {
                await addArticleToCuration(draggedArticle, curation)
            }
        }
        HapticManager.shared.impact(.medium)
        return true
    }
}
// MARK: - List View
struct ListView: View {
    let curations: [ArticleCuration]
    @Binding var selectedCurations: Set<ArticleCuration>
    let isEditMode: Bool
    @Binding var hoveredCuration: ArticleCuration?
    let draggedArticle: DraggedArticle?
    @Binding var curationToEdit: ArticleCuration?
    let shareCuration: (ArticleCuration) -> Void
    let deleteCuration: (ArticleCuration) -> Void
    let addArticleToCuration: (DraggedArticle, ArticleCuration) async -> Void
    @State private var dropTargets: [String: Bool] = [:]
    var body: some View {
        List {
            ForEach(curations) { curation in
                listRow(for: curation)
            }
        }
        .listStyle(.plain)
    }
    @ViewBuilder
    private func listRow(for curation: ArticleCuration) -> some View {
        let isSelected = selectedCurations.contains(curation)
        let isHovered = hoveredCuration?.id == curation.id && draggedArticle != nil
        CurationListRow(
            curation: curation,
            isSelected: isSelected,
            isEditMode: isEditMode,
            isHovered: isHovered
        )
        .listRowInsets(EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16))
        .listRowBackground(Color.clear)
        .onTapGesture {
            handleTap(curation: curation)
        }
        .onDrop(of: [.draggedArticle], isTargeted: Binding(
            get: { dropTargets[curation.id] ?? false },
            set: { isTargeted in
                dropTargets[curation.id] = isTargeted
                hoveredCuration = isTargeted ? curation : nil
            }
        )) { providers in
            handleDropOnCuration(providers: providers, curation: curation)
        }
        .contextMenu {
            CurationContextMenu(curation: curation, curationToEdit: $curationToEdit, shareCuration: shareCuration, deleteCuration: deleteCuration)
        }
    }
    private func handleTap(curation: ArticleCuration) {
        if isEditMode {
            toggleSelection(curation)
        } else {
            curationToEdit = curation
        }
    }
    private func toggleSelection(_ curation: ArticleCuration) {
        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
            if selectedCurations.contains(curation) {
                selectedCurations.remove(curation)
            } else {
                selectedCurations.insert(curation)
            }
        }
        HapticManager.shared.impact(.light)
    }
    private func handleDropOnCuration(providers: [NSItemProvider], curation: ArticleCuration) -> Bool {
        guard let provider = providers.first,
              provider.hasItemConformingToTypeIdentifier(DraggedArticle.typeIdentifier) else {
            return false
        }
        provider.loadDataRepresentation(forTypeIdentifier: DraggedArticle.typeIdentifier) { data, error in
            guard let data = data,
                  let draggedArticle = try? JSONDecoder().decode(DraggedArticle.self, from: data) else {
                return
            }
            Task {
                await addArticleToCuration(draggedArticle, curation)
            }
        }
        HapticManager.shared.impact(.medium)
        return true
    }
}
// MARK: - Carousel View
struct CarouselView: View {
    let curations: [ArticleCuration]
    @Binding var curationToEdit: ArticleCuration?
    @State private var currentIndex = 0
    @State private var dragOffset: CGSize = .zero
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                ForEach(Array(curations.enumerated()), id: \.element.id) { index, curation in
                    CurationManagementCarouselCard(
                        curation: curation,
                        geometry: geometry,
                        index: index,
                        currentIndex: currentIndex,
                        totalCount: curations.count
                    )
                    .offset(x: cardOffset(index: index, geometry: geometry))
                    .offset(x: dragOffset.width)
                    .scaleEffect(cardScale(index: index))
                    .opacity(cardOpacity(index: index))
                    .zIndex(Double(curations.count - abs(index - currentIndex)))
                    .onTapGesture {
                        if index == currentIndex {
                            curationToEdit = curation
                        } else {
                            withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                                currentIndex = index
                            }
                            HapticManager.shared.impact(.light)
                        }
                    }
                }
                // Navigation dots
                VStack {
                    Spacer()
                    HStack(spacing: 8) {
                        ForEach(0..<curations.count, id: \.self) { index in
                            Circle()
                                .fill(index == currentIndex ? DesignSystem.Colors.primary : Color.gray.opacity(0.3))
                                .frame(width: 8, height: 8)
                                .scaleEffect(index == currentIndex ? 1.2 : 1)
                                .animation(DesignSystem.Animation.springSnappy, value: currentIndex)
                        }
                    }
                    .padding(.bottom, 20)
                }
            }
            .gesture(
                DragGesture()
                    .onChanged { value in
                        dragOffset = value.translation
                    }
                    .onEnded { value in
                        let threshold = geometry.size.width * 0.2
                        withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                            if value.translation.width < -threshold && currentIndex < curations.count - 1 {
                                currentIndex += 1
                            } else if value.translation.width > threshold && currentIndex > 0 {
                                currentIndex -= 1
                            }
                            dragOffset = .zero
                        }
                        HapticManager.shared.impact(.light)
                    }
            )
        }
        .padding(.vertical, 40)
    }
    private func cardOffset(index: Int, geometry: GeometryProxy) -> CGFloat {
        let difference = CGFloat(index - currentIndex)
        let cardWidth = geometry.size.width * 0.8
        let spacing: CGFloat = 20
        return difference * (cardWidth + spacing)
    }
    private func cardScale(index: Int) -> CGFloat {
        let difference = abs(index - currentIndex)
        return 1 - (CGFloat(difference) * 0.1)
    }
    private func cardOpacity(index: Int) -> Double {
        let difference = abs(index - currentIndex)
        return difference == 0 ? 1 : (difference == 1 ? 0.7 : 0.3)
    }
}
// MARK: - Supporting Views
struct CurationGridItem: View {
    let curation: ArticleCuration
    let isSelected: Bool
    let isEditMode: Bool
    let isHovered: Bool
    @State private var animateHover = false
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Image section
            ZStack {
                if let imageUrl = curation.image, let url = URL(string: imageUrl) {
                    AsyncImage(url: url) { image in
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                    } placeholder: {
                        ShimmerView()
                    }
                    .frame(height: 120)
                    .clipped()
                } else {
                    RoundedRectangle(cornerRadius: 0)
                        .fill(
                            LinearGradient(
                                colors: [DesignSystem.Colors.primary, DesignSystem.Colors.primary.opacity(0.7)],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(height: 120)
                        .overlay(
                            Image(systemName: "folder.fill")
                                .font(.system(size: 40))
                                .foregroundColor(.white.opacity(0.8))
                        )
                }
                // Selection overlay
                if isEditMode {
                    Color.black.opacity(isSelected ? 0.3 : 0)
                        .overlay(
                            Image(systemName: isSelected ? "checkmark.circle.fill" : "circle")
                                .font(.title2)
                                .foregroundColor(.white)
                                .padding(8),
                            alignment: .topTrailing
                        )
                }
                // Drop indicator
                if isHovered {
                    RoundedRectangle(cornerRadius: 0)
                        .stroke(DesignSystem.Colors.primary, lineWidth: 3)
                        .background(DesignSystem.Colors.primary.opacity(0.1))
                        .scaleEffect(animateHover ? 1.05 : 1)
                }
            }
            .cornerRadius(12, corners: [.topLeft, .topRight])
            // Content section
            VStack(alignment: .leading, spacing: 6) {
                Text(curation.title)
                    .font(DesignSystem.Typography.body.weight(.medium))
                    .lineLimit(1)
                HStack {
                    Label("\(curation.articles.count)", systemImage: "doc.text")
                        .font(DesignSystem.Typography.caption)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                    Spacer()
                    Text(RelativeTimeFormatter.relativeTime(from: curation.updatedAt))
                        .font(.ds.caption)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                }
            }
            .padding(.horizontal, 12)
            .padding(.bottom, 12)
        }
        .modernCard()
        .scaleEffect(isSelected || isHovered ? 0.95 : 1)
        .animation(DesignSystem.Animation.springSnappy, value: isSelected)
        .animation(DesignSystem.Animation.springSnappy, value: isHovered)
        .onAppear {
            if isHovered {
                withAnimation(.easeInOut(duration: 0.8).repeatForever(autoreverses: true)) {
                    animateHover = true
                }
            }
        }
    }
}
struct CurationListRow: View {
    let curation: ArticleCuration
    let isSelected: Bool
    let isEditMode: Bool
    let isHovered: Bool
    var body: some View {
        HStack(spacing: 16) {
            // Selection indicator
            if isEditMode {
                Image(systemName: isSelected ? "checkmark.circle.fill" : "circle")
                    .font(.title3)
                    .foregroundColor(isSelected ? DesignSystem.Colors.primary : .gray)
                    .animation(DesignSystem.Animation.springSnappy, value: isSelected)
            }
            // Thumbnail
            if let imageUrl = curation.image, let url = URL(string: imageUrl) {
                AsyncImage(url: url) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                } placeholder: {
                    ShimmerView()
                }
                .frame(width: 60, height: 60)
                .cornerRadius(10)
            } else {
                RoundedRectangle(cornerRadius: 10)
                    .fill(
                        LinearGradient(
                            colors: [DesignSystem.Colors.primary, DesignSystem.Colors.primary.opacity(0.7)],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: 60, height: 60)
                    .overlay(
                        Image(systemName: "folder.fill")
                            .foregroundColor(.white.opacity(0.8))
                    )
            }
            // Content
            VStack(alignment: .leading, spacing: 4) {
                Text(curation.title)
                    .font(DesignSystem.Typography.body.weight(.medium))
                    .lineLimit(1)
                if let description = curation.description {
                    Text(description)
                        .font(DesignSystem.Typography.caption)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                        .lineLimit(2)
                }
                HStack(spacing: 12) {
                    Label("\(curation.articles.count) articles", systemImage: "doc.text")
                        .font(.ds.caption)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                    Text(RelativeTimeFormatter.relativeTime(from: curation.updatedAt))
                        .font(.ds.caption)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                }
            }
            Spacer()
            if !isEditMode {
                Image(systemName: "chevron.right")
                    .font(.caption)
                    .foregroundColor(DesignSystem.Colors.textSecondary)
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(DesignSystem.Colors.surface)
                .overlay(
                    RoundedRectangle(cornerRadius: 12)
                        .stroke(isHovered ? DesignSystem.Colors.primary : Color.clear, lineWidth: 2)
                )
        )
        .scaleEffect(isHovered ? 1.02 : 1)
        .animation(DesignSystem.Animation.springSnappy, value: isHovered)
    }
}
struct CurationManagementCarouselCard: View {
    let curation: ArticleCuration
    let geometry: GeometryProxy
    let index: Int
    let currentIndex: Int
    let totalCount: Int
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Image section
            if let imageUrl = curation.image, let url = URL(string: imageUrl) {
                AsyncImage(url: url) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                } placeholder: {
                    ShimmerView()
                }
                .frame(height: geometry.size.height * 0.5)
                .clipped()
            } else {
                ZStack {
                    LinearGradient(
                        colors: [DesignSystem.Colors.primary, DesignSystem.Colors.secondary],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                    Image(systemName: "folder.fill")
                        .font(.system(size: 80))
                        .foregroundColor(.white.opacity(0.8))
                }
                .frame(height: geometry.size.height * 0.5)
            }
            // Content section
            VStack(alignment: .leading, spacing: 12) {
                Text(curation.title)
                    .font(.ds.title3)
                    .fontWeight(.bold)
                    .lineLimit(2)
                if let description = curation.description {
                    Text(description)
                        .font(DesignSystem.Typography.body)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                        .lineLimit(3)
                }
                Spacer()
                HStack {
                    Label("\(curation.articles.count) articles", systemImage: "doc.text")
                        .font(DesignSystem.Typography.caption)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                    Spacer()
                    Text(RelativeTimeFormatter.relativeTime(from: curation.updatedAt))
                        .font(DesignSystem.Typography.caption)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                }
            }
            .padding(20)
            .frame(maxHeight: .infinity)
        }
        .frame(width: geometry.size.width * 0.8)
        .background(DesignSystem.Colors.surface)
        .cornerRadius(20)
        .shadow(
            color: .black.opacity(index == currentIndex ? 0.2 : 0.1),
            radius: index == currentIndex ? 20 : 10,
            y: 10
        )
    }
}
struct CurationContextMenu: View {
    let curation: ArticleCuration
    @Binding var curationToEdit: ArticleCuration?
    let shareCuration: (ArticleCuration) -> Void
    let deleteCuration: (ArticleCuration) -> Void
    var body: some View {
        Button(action: { curationToEdit = curation }) {
            Label("View Details", systemImage: "eye")
        }
        Button(action: { 
            shareCuration(curation)
            HapticManager.shared.impact(.light)
        }) {
            Label("Share", systemImage: "square.and.arrow.up")
        }
        Divider()
        Button(role: .destructive, action: {
            deleteCuration(curation)
            HapticManager.shared.notification(.warning)
        }) {
            Label("Delete", systemImage: "trash")
        }
    }
}
struct EmptyStateView: View {
    let searchText: String
    @State private var animateIcon = false
    var body: some View {
        VStack(spacing: 20) {
            Image(systemName: searchText.isEmpty ? "folder.badge.plus" : "magnifyingglass")
                .font(.system(size: 60))
                .foregroundColor(DesignSystem.Colors.primary.opacity(0.5))
                .scaleEffect(animateIcon ? 1.1 : 1)
                .onAppear {
                    withAnimation(.easeInOut(duration: 2).repeatForever(autoreverses: true)) {
                        animateIcon = true
                    }
                }
            Text(searchText.isEmpty ? "No curations yet" : "No results found")
                .font(.ds.title3)
                .fontWeight(.medium)
                .foregroundColor(DesignSystem.Colors.text)
            Text(searchText.isEmpty ? 
                 "Create your first curation to organize articles" : 
                 "Try adjusting your search terms")
                .font(DesignSystem.Typography.body)
                .foregroundColor(DesignSystem.Colors.textSecondary)
                .multilineTextAlignment(.center)
        }
        .padding(40)
    }
}
struct ShimmerView: View {
    @State private var shimmerOffset: CGFloat = -1
    var body: some View {
        GeometryReader { geometry in
            Rectangle()
                .fill(Color.gray.opacity(0.3))
                .overlay(
                    Rectangle()
                        .fill(
                            LinearGradient(
                                colors: [
                                    Color.clear,
                                    Color.white.opacity(0.3),
                                    Color.clear
                                ],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .offset(x: shimmerOffset * geometry.size.width)
                )
                .onAppear {
                    withAnimation(.linear(duration: 1.5).repeatForever(autoreverses: false)) {
                        shimmerOffset = 2
                    }
                }
        }
    }
}
// MARK: - Corner Radius Extension
extension View {
    func cornerRadius(_ radius: CGFloat, corners: UIRectCorner) -> some View {
        clipShape(RoundedCorner(radius: radius, corners: corners))
    }
}
struct RoundedCorner: Shape {
    var radius: CGFloat = .infinity
    var corners: UIRectCorner = .allCorners
    func path(in rect: CGRect) -> Path {
        let path = UIBezierPath(
            roundedRect: rect,
            byRoundingCorners: corners,
            cornerRadii: CGSize(width: radius, height: radius)
        )
        return Path(path.cgPath)
    }
}
#Preview {
    CurationManagementView()
        .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Views/Discovery/EnhancedArticleDiscoveryView.swift">
import SwiftUI
import NDKSwift
struct EnhancedArticleDiscoveryView: View {
    @EnvironmentObject var appState: AppState
    @StateObject private var viewModel = ArticleDiscoveryViewModel()
    let searchText: String
    @State private var selectedCategory: ArticleCategory = .all
    @State private var showFilters = false
    @State private var refreshID = UUID()
    enum ArticleCategory: String, CaseIterable {
        case all = "All"
        case technology = "Technology"
        case bitcoin = "Bitcoin"
        case philosophy = "Philosophy"
        case science = "Science"
        case culture = "Culture"
        var icon: String {
            switch self {
            case .all: return "square.grid.3x3"
            case .technology: return "cpu"
            case .bitcoin: return "bitcoinsign.circle"
            case .philosophy: return "brain"
            case .science: return "atom"
            case .culture: return "theatermasks"
            }
        }
        var color: Color {
            switch self {
            case .all: return .ds.primary
            case .technology: return .blue
            case .bitcoin: return .orange
            case .philosophy: return .purple
            case .science: return .green
            case .culture: return .pink
            }
        }
        var hashtags: [String] {
            switch self {
            case .all: return []
            case .technology: return ["tech", "programming", "ai", "software"]
            case .bitcoin: return ["bitcoin", "btc", "lightning", "nostr"]
            case .philosophy: return ["philosophy", "wisdom", "thoughts", "ideas"]
            case .science: return ["science", "research", "physics", "biology"]
            case .culture: return ["culture", "art", "music", "literature"]
            }
        }
    }
    var body: some View {
        ScrollView {
            VStack(spacing: 24) {
                // Category selector with animation
                categorySelectorView
                // Featured article carousel
                if viewModel.featuredArticle != nil {
                    featuredArticleSection
                        .transition(.asymmetric(
                            insertion: .push(from: .bottom).combined(with: .opacity),
                            removal: .push(from: .top).combined(with: .opacity)
                        ))
                }
                // Trending articles
                if !viewModel.trendingArticles.isEmpty {
                    trendingArticlesSection
                }
                // Main article grid
                articleGridSection
            }
            .padding(.bottom, 100)
        }
        .refreshable {
            HapticManager.shared.impact(.medium)
            await viewModel.refreshArticles()
            refreshID = UUID()
            HapticManager.shared.notification(.success)
        }
        .task(id: refreshID) {
            if let ndk = appState.ndk {
                viewModel.configure(with: ndk)
                await viewModel.loadArticles(category: selectedCategory, searchText: searchText)
            }
        }
        .onChange(of: selectedCategory) { _, newCategory in
            Task {
                await viewModel.loadArticles(category: newCategory, searchText: searchText)
            }
        }
        .onChange(of: searchText) { _, newText in
            Task {
                await viewModel.searchArticles(query: newText, category: selectedCategory)
            }
        }
    }
    // MARK: - Components
    private var categorySelectorView: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 12) {
                ForEach(ArticleCategory.allCases, id: \.self) { category in
                    CategoryChip(
                        category: category,
                        isSelected: selectedCategory == category
                    ) {
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                            selectedCategory = category
                            HapticManager.shared.impact(.light)
                        }
                    }
                }
                // Filter button
                Button(action: { showFilters = true }) {
                    HStack(spacing: 6) {
                        Image(systemName: "line.3.horizontal.decrease.circle")
                        Text("Filters")
                    }
                    .font(.system(size: 14, weight: .medium))
                    .foregroundColor(.ds.primary)
                    .padding(.horizontal, 16)
                    .padding(.vertical, 10)
                    .background(
                        Capsule()
                            .fill(Color.ds.primary.opacity(0.1))
                            .overlay(
                                Capsule()
                                    .strokeBorder(Color.ds.primary.opacity(0.2), lineWidth: 1)
                            )
                    )
                }
            }
            .padding(.horizontal)
        }
    }
    private var featuredArticleSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            HStack {
                Label("Featured Article", systemImage: "star.fill")
                    .font(.system(size: 18, weight: .bold))
                    .foregroundColor(.ds.text)
                Spacer()
                Text("AI Recommended")
                    .font(.system(size: 12, weight: .medium))
                    .foregroundColor(.purple)
                    .padding(.horizontal, 12)
                    .padding(.vertical, 4)
                    .background(
                        Capsule()
                            .fill(Color.purple.opacity(0.1))
                    )
            }
            .padding(.horizontal)
            if let featured = viewModel.featuredArticle {
                FeaturedArticleCard(article: featured)
                    .padding(.horizontal)
            }
        }
    }
    private var trendingArticlesSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            HStack {
                Label("Trending Now", systemImage: "flame.fill")
                    .font(.system(size: 18, weight: .bold))
                    .foregroundColor(.ds.text)
                Spacer()
                Text("\(viewModel.trendingArticles.count) articles")
                    .font(.system(size: 14))
                    .foregroundColor(.ds.textSecondary)
            }
            .padding(.horizontal)
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 16) {
                    ForEach(viewModel.trendingArticles) { article in
                        TrendingArticleCard(article: article)
                            .frame(width: 300)
                    }
                }
                .padding(.horizontal)
            }
        }
    }
    private var articleGridSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            HStack {
                Text("Discover Articles")
                    .font(.system(size: 22, weight: .bold))
                    .foregroundColor(.ds.text)
                Spacer()
                if viewModel.isLoading {
                    ProgressView()
                        .scaleEffect(0.8)
                }
            }
            .padding(.horizontal)
            if viewModel.articles.isEmpty && !viewModel.isLoading {
                VStack(spacing: 16) {
                    Image(systemName: "magnifyingglass")
                        .font(.system(size: 60))
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                    Text("No articles found")
                        .font(DesignSystem.Typography.title3)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                    Text("Try adjusting your search terms")
                        .font(DesignSystem.Typography.body)
                        .foregroundColor(DesignSystem.Colors.textSecondary.opacity(0.7))
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .padding()
                    .padding(.horizontal)
                    .padding(.vertical, 60)
            } else {
                LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())], spacing: 16) {
                    ForEach(viewModel.articles) { article in
                        ArticleGridCard(article: article)
                    }
                }
                .padding(.horizontal)
            }
            // Load more button
            if viewModel.hasMoreArticles && !viewModel.isLoading {
                Button(action: {
                    Task {
                        await viewModel.loadMoreArticles()
                    }
                }) {
                    HStack {
                        Text("Load More")
                        Image(systemName: "arrow.down.circle")
                    }
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(.ds.primary)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 16)
                    .background(
                        RoundedRectangle(cornerRadius: 16, style: .continuous)
                            .fill(Color.ds.primary.opacity(0.1))
                    )
                }
                .padding(.horizontal)
                .padding(.top, 16)
            }
        }
    }
}
// MARK: - View Model
@MainActor
class ArticleDiscoveryViewModel: ObservableObject {
    @Published var articles: [Article] = []
    @Published var trendingArticles: [Article] = []
    @Published var featuredArticle: Article?
    @Published var isLoading = false
    @Published var hasMoreArticles = true
    private var ndk: NDK?
    private var loadedEventIds = Set<String>()
    private var lastLoadedTimestamp: Timestamp?
    func configure(with ndk: NDK) {
        self.ndk = ndk
    }
    func loadArticles(category: EnhancedArticleDiscoveryView.ArticleCategory, searchText: String) async {
        guard let ndk = ndk else { return }
        isLoading = true
        defer { isLoading = false }
        // Clear previous results
        articles.removeAll()
        loadedEventIds.removeAll()
        lastLoadedTimestamp = nil
        // Build filter
        var filter = NDKFilter(kinds: [30023]) // Long-form content
        if !category.hashtags.isEmpty {
            // Create a new filter with the category tags
            filter = NDKFilter(
                kinds: [30023],
                limit: 20,
                tags: ["t": Set(category.hashtags)]
            )
        }
        filter.limit = 50
        // Subscribe with closeOnEose to get all matching events then close
        let dataSource = NDKDataSource(
            ndk: ndk,
            filter: filter,
            maxAge: 0,
            cachePolicy: .networkOnly,
            closeOnEose: true
        )
        var collectedEvents: [NDKEvent] = []
        for await event in dataSource.events {
            collectedEvents.append(event)
        }
        processArticleEvents(collectedEvents)
        // Load trending and featured
        await loadTrendingArticles()
        await loadFeaturedArticle(category: category)
    }
    func searchArticles(query: String, category: EnhancedArticleDiscoveryView.ArticleCategory) async {
        guard !query.isEmpty else {
            await loadArticles(category: category, searchText: "")
            return
        }
        // Filter existing articles first
        let filtered = articles.filter { article in
            article.title.localizedCaseInsensitiveContains(query) ||
            article.summary?.localizedCaseInsensitiveContains(query) == true ||
            article.hashtags.contains { $0.localizedCaseInsensitiveContains(query) }
        }
        withAnimation {
            articles = filtered
        }
        // Then search for more
        await loadArticles(category: category, searchText: query)
    }
    func loadMoreArticles() async {
        guard let ndk = ndk, !isLoading, hasMoreArticles else { return }
        isLoading = true
        defer { isLoading = false }
        var filter = NDKFilter(kinds: [30023])
        filter.limit = 30
        if let lastTimestamp = lastLoadedTimestamp {
            filter.until = lastTimestamp
        }
        // Subscribe with closeOnEose to get all matching events then close
        let dataSource = NDKDataSource(
            ndk: ndk,
            filter: filter,
            maxAge: 0,
            cachePolicy: .networkOnly,
            closeOnEose: true
        )
        var collectedEvents: [NDKEvent] = []
        for await event in dataSource.events {
            collectedEvents.append(event)
        }
        if collectedEvents.count < 30 {
            hasMoreArticles = false
        }
        processArticleEvents(collectedEvents)
    }
    func refreshArticles() async {
        articles.removeAll()
        trendingArticles.removeAll()
        featuredArticle = nil
        loadedEventIds.removeAll()
        hasMoreArticles = true
        await loadArticles(category: .all, searchText: "")
    }
    private func processArticleEvents(_ events: [NDKEvent]) {
        let newArticles = events.compactMap { event -> Article? in
            guard !loadedEventIds.contains(event.id) else { return nil }
            loadedEventIds.insert(event.id)
            // Update last timestamp
            if lastLoadedTimestamp == nil || event.createdAt < lastLoadedTimestamp! {
                lastLoadedTimestamp = event.createdAt
            }
            return parseArticleEvent(event)
        }
        withAnimation {
            articles.append(contentsOf: newArticles)
        }
    }
    private func parseArticleEvent(_ event: NDKEvent) -> Article? {
        // Extract article data from tags
        var title = ""
        var summary: String?
        var image: String?
        var publishedAt = Date(timeIntervalSince1970: TimeInterval(event.createdAt))
        var hashtags: [String] = []
        for tag in event.tags {
            guard let tagName = tag.first else { continue }
            switch tagName {
            case "title":
                title = tag[safe: 1] ?? ""
            case "summary":
                summary = tag[safe: 1]
            case "image":
                image = tag[safe: 1]
            case "published_at":
                if let timestamp = tag[safe: 1], let time = TimeInterval(timestamp) {
                    publishedAt = Date(timeIntervalSince1970: time)
                }
            case "t":
                if let hashtag = tag[safe: 1] {
                    hashtags.append(hashtag)
                }
            default:
                break
            }
        }
        guard !title.isEmpty else { return nil }
        return Article(
            id: event.id,
            identifier: event.id,
            title: title,
            summary: summary,
            content: event.content,
            author: event.pubkey,
            publishedAt: publishedAt,
            image: image,
            hashtags: hashtags,
            createdAt: event.createdAt
        )
    }
    private func loadTrendingArticles() async {
        // For now, take top articles
        // In production, this would analyze zaps, comments, and highlights
        trendingArticles = Array(articles.prefix(5))
    }
    private func loadFeaturedArticle(category: EnhancedArticleDiscoveryView.ArticleCategory) async {
        // For now, pick a random article
        // In production, this would use AI to recommend based on user preferences
        featuredArticle = articles.randomElement()
    }
}
// MARK: - Card Components
struct CategoryChip: View {
    let category: EnhancedArticleDiscoveryView.ArticleCategory
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            HStack(spacing: 8) {
                Image(systemName: category.icon)
                    .font(.system(size: 16))
                Text(category.rawValue)
                    .font(.system(size: 15, weight: .medium))
            }
            .foregroundColor(isSelected ? .white : category.color)
            .padding(.horizontal, 16)
            .padding(.vertical, 10)
            .background(
                Capsule()
                    .fill(isSelected ? category.color : category.color.opacity(0.1))
                    .overlay(
                        Capsule()
                            .strokeBorder(category.color.opacity(0.2), lineWidth: isSelected ? 0 : 1)
                    )
            )
            .scaleEffect(isSelected ? 1.05 : 1)
        }
        .buttonStyle(PlainButtonStyle())
    }
}
struct FeaturedArticleCard: View {
    let article: Article
    @EnvironmentObject var appState: AppState
    @State private var isBookmarked = false
    var body: some View {
        NavigationLink(destination: ArticleView(article: article)) {
            VStack(alignment: .leading, spacing: 16) {
                // Image with gradient overlay
                ZStack(alignment: .bottomLeading) {
                    if let imageUrl = article.image {
                        AsyncImage(url: URL(string: imageUrl)) { phase in
                            switch phase {
                            case .success(let image):
                                image
                                    .resizable()
                                    .aspectRatio(contentMode: .fill)
                                    .frame(height: 220)
                                    .clipped()
                            case .empty, .failure:
                                RoundedRectangle(cornerRadius: 0)
                                    .fill(
                                        LinearGradient(
                                            colors: [.purple.opacity(0.3), .blue.opacity(0.3)],
                                            startPoint: .topLeading,
                                            endPoint: .bottomTrailing
                                        )
                                    )
                                    .frame(height: 220)
                            @unknown default:
                                EmptyView()
                            }
                        }
                    } else {
                        RoundedRectangle(cornerRadius: 0)
                            .fill(
                                LinearGradient(
                                    colors: [.purple.opacity(0.3), .blue.opacity(0.3)],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .frame(height: 220)
                    }
                    // Gradient overlay
                    LinearGradient(
                        colors: [.clear, .black.opacity(0.7)],
                        startPoint: .center,
                        endPoint: .bottom
                    )
                    // Title on image
                    Text(article.title)
                        .font(.system(size: 24, weight: .bold))
                        .foregroundColor(.white)
                        .lineLimit(2)
                        .padding()
                }
                // Content section
                VStack(alignment: .leading, spacing: 12) {
                    if let summary = article.summary {
                        Text(summary)
                            .font(.system(size: 16))
                            .foregroundColor(.ds.textSecondary)
                            .lineLimit(3)
                    }
                    HStack {
                        // Author
                        HStack(spacing: 8) {
                            Circle()
                                .fill(Color.ds.surfaceSecondary)
                                .frame(width: 28, height: 28)
                                .overlay(
                                    Text(PubkeyFormatter.formatForAvatar(article.author))
                                        .font(.system(size: 12, weight: .medium))
                                        .foregroundColor(.ds.text)
                                )
                            Text(PubkeyFormatter.formatShort(article.author))
                                .font(.system(size: 14))
                                .foregroundColor(.ds.textSecondary)
                        }
                        Spacer()
                        // Actions
                        HStack(spacing: 16) {
                            Label("\(article.estimatedReadingTime) min", systemImage: "clock")
                                .font(.system(size: 13))
                                .foregroundColor(.ds.textTertiary)
                            Button(action: {
                                Task {
                                    isBookmarked.toggle()
                                    try? await appState.bookmarkService.toggleArticleBookmark(article)
                                    HapticManager.shared.impact(.light)
                                }
                            }) {
                                Image(systemName: isBookmarked ? "bookmark.fill" : "bookmark")
                                    .font(.system(size: 18))
                                    .foregroundColor(isBookmarked ? .ds.primary : .ds.textSecondary)
                            }
                        }
                    }
                    // Tags
                    if !article.hashtags.isEmpty {
                        ScrollView(.horizontal, showsIndicators: false) {
                            HStack(spacing: 8) {
                                ForEach(article.hashtags.prefix(5), id: \.self) { tag in
                                    Text("#\(tag)")
                                        .font(.system(size: 12, weight: .medium))
                                        .foregroundColor(.purple)
                                        .padding(.horizontal, 10)
                                        .padding(.vertical, 4)
                                        .background(
                                            Capsule()
                                                .fill(Color.purple.opacity(0.1))
                                        )
                                }
                            }
                        }
                    }
                }
                .padding()
            }
        }
        .background(
            RoundedRectangle(cornerRadius: 24, style: .continuous)
                .fill(Color.ds.surface)
                .shadow(color: .black.opacity(0.1), radius: 20, y: 10)
        )
        .buttonStyle(PlainButtonStyle())
        .onAppear {
            isBookmarked = appState.bookmarkService.isArticleBookmarked(article.id)
        }
    }
}
struct TrendingArticleCard: View {
    let article: Article
    var body: some View {
        NavigationLink(destination: ArticleView(article: article)) {
            HStack(spacing: 16) {
                // Thumbnail
                if let imageUrl = article.image {
                    AsyncImage(url: URL(string: imageUrl)) { phase in
                        switch phase {
                        case .success(let image):
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                .frame(width: 100, height: 100)
                                .clipShape(RoundedRectangle(cornerRadius: 16, style: .continuous))
                        case .empty, .failure:
                            RoundedRectangle(cornerRadius: 16, style: .continuous)
                                .fill(Color.ds.surfaceSecondary)
                                .frame(width: 100, height: 100)
                                .overlay(
                                    Image(systemName: "photo")
                                        .foregroundColor(.ds.textTertiary)
                                )
                        @unknown default:
                            EmptyView()
                        }
                    }
                } else {
                    RoundedRectangle(cornerRadius: 16, style: .continuous)
                        .fill(
                            LinearGradient(
                                colors: [.orange.opacity(0.3), .red.opacity(0.3)],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 100, height: 100)
                }
                // Content
                VStack(alignment: .leading, spacing: 8) {
                    Text(article.title)
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundColor(.ds.text)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)
                    if let summary = article.summary {
                        Text(summary)
                            .font(.system(size: 14))
                            .foregroundColor(.ds.textSecondary)
                            .lineLimit(2)
                    }
                    Spacer()
                    HStack {
                        Label("\(article.estimatedReadingTime) min", systemImage: "clock")
                            .font(.system(size: 12))
                            .foregroundColor(.ds.textTertiary)
                        Spacer()
                        Image(systemName: "flame.fill")
                            .font(.system(size: 14))
                            .foregroundColor(.orange)
                    }
                }
                Spacer(minLength: 0)
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 20, style: .continuous)
                    .fill(Color.ds.surface)
                    .shadow(color: .black.opacity(0.05), radius: 10, y: 5)
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}
struct ArticleGridCard: View {
    let article: Article
    @EnvironmentObject var appState: AppState
    @State private var isPressed = false
    @State private var isBookmarked = false
    var body: some View {
        NavigationLink(destination: ArticleView(article: article)) {
            VStack(alignment: .leading, spacing: 12) {
                // Thumbnail
                if let imageUrl = article.image {
                    AsyncImage(url: URL(string: imageUrl)) { phase in
                        switch phase {
                        case .success(let image):
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                .frame(height: 120)
                                .clipped()
                                .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
                        case .empty, .failure:
                            RoundedRectangle(cornerRadius: 12, style: .continuous)
                                .fill(Color.ds.surfaceSecondary)
                                .frame(height: 120)
                                .overlay(
                                    Image(systemName: "doc.text")
                                        .font(.system(size: 24))
                                        .foregroundColor(.ds.textTertiary)
                                )
                        @unknown default:
                            EmptyView()
                        }
                    }
                } else {
                    RoundedRectangle(cornerRadius: 12, style: .continuous)
                        .fill(
                            LinearGradient(
                                colors: [
                                    Color.ds.primary.opacity(0.2),
                                    Color.ds.secondary.opacity(0.2)
                                ],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(height: 120)
                }
                // Content
                VStack(alignment: .leading, spacing: 8) {
                    Text(article.title)
                        .font(.system(size: 15, weight: .semibold))
                        .foregroundColor(.ds.text)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)
                    HStack {
                        Label("\(article.estimatedReadingTime) min", systemImage: "clock")
                            .font(.system(size: 11))
                            .foregroundColor(.ds.textTertiary)
                        Spacer()
                        Button(action: {
                            Task {
                                isBookmarked.toggle()
                                try? await appState.bookmarkService.toggleArticleBookmark(article)
                                HapticManager.shared.impact(.light)
                            }
                        }) {
                            Image(systemName: isBookmarked ? "bookmark.fill" : "bookmark")
                                .font(.system(size: 14))
                                .foregroundColor(isBookmarked ? .ds.primary : .ds.textTertiary)
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                }
                .padding(.horizontal, 12)
                .padding(.bottom, 12)
            }
        }
        .background(
            RoundedRectangle(cornerRadius: 16, style: .continuous)
                .fill(Color.ds.surface)
                .shadow(color: .black.opacity(0.08), radius: 8, y: 4)
        )
        .scaleEffect(isPressed ? 0.95 : 1)
        .buttonStyle(PlainButtonStyle())
        .onLongPressGesture(minimumDuration: 0.1, maximumDistance: .infinity, pressing: { pressing in
            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                isPressed = pressing
            }
        }, perform: {})
        .onAppear {
            isBookmarked = appState.bookmarkService.isArticleBookmarked(article.id)
        }
    }
}
</file>

<file path="Sources/Highlighter/Views/Feed/TimelineFeedView.swift">
import SwiftUI
import NDKSwift
struct TimelineFeedView: View {
    @EnvironmentObject var appState: AppState
    @StateObject private var feedDataManager = FeedDataManager()
    @State private var scrollOffset: CGFloat = 0
    @State private var headerScale: CGFloat = 1
    @State private var isRefreshing = false
    @State private var selectedFilter: FeedFilter = .all
    @State private var showFilterSheet = false
    @State private var feedOpacity: Double = 0
    @State private var showFloatingTimeline = true
    @State private var engagements: [String: EngagementService.EngagementMetrics] = [:]
    enum FeedFilter: String, CaseIterable {
        case all = "All"
        case following = "Following"
        case trending = "Trending"
        case recent = "Recent"
        var icon: String {
            switch self {
            case .all: return "square.grid.2x2"
            case .following: return "person.2.fill"
            case .trending: return "flame.fill"
            case .recent: return "clock.fill"
            }
        }
        var color: Color {
            switch self {
            case .all: return .ds.primary
            case .following: return .ds.secondary
            case .trending: return .red
            case .recent: return .blue
            }
        }
    }
    var body: some View {
        NavigationStack {
            ZStack {
                // Dynamic gradient background
                TimelineGradientBackground()
                    .ignoresSafeArea()
                // Floating timeline particles
                if showFloatingTimeline {
                    TimelineParticles()
                        .ignoresSafeArea()
                        .opacity(feedOpacity)
                        .animation(.easeIn(duration: 2), value: feedOpacity)
                }
                ScrollViewReader { scrollProxy in
                    ScrollView(.vertical, showsIndicators: false) {
                        VStack(spacing: 0) {
                            // Sticky header with filters
                            feedHeader
                                .padding(.top, DesignSystem.Spacing.large)
                                .scaleEffect(headerScale)
                                .opacity(headerScale)
                                .id("header")
                            // Timeline content
                            VStack(spacing: DesignSystem.Spacing.large) {
                                ForEach(feedDataManager.timelineEvents, id: \.id) { event in
                                    TimelineEventCard(
                                        event: event,
                                        engagement: engagements[event.id] ?? EngagementService.EngagementMetrics()
                                    )
                                    .transition(.asymmetric(
                                        insertion: .push(from: .bottom).combined(with: .opacity),
                                        removal: .push(from: .top).combined(with: .opacity)
                                    ))
                                    .id(event.id)
                                }
                                // No loading states - events stream in progressively
                            }
                            .padding(.horizontal, DesignSystem.Spacing.large)
                            .padding(.vertical, DesignSystem.Spacing.xl)
                        }
                        .padding(.bottom, DesignSystem.Spacing.huge * 2.5)
                        .background(GeometryReader { geo in
                            Color.clear.preference(
                                key: ScrollOffsetPreferenceKey.self,
                                value: geo.frame(in: .named("scroll")).minY
                            )
                        })
                    }
                    .coordinateSpace(name: "scroll")
                    .onPreferenceChange(ScrollOffsetPreferenceKey.self) { value in
                        scrollOffset = value
                        // Calculate header scale based on scroll
                        let scale = min(1.0, max(0.8, (100 + value) / 100))
                        withAnimation(.easeOut(duration: 0.2)) {
                            headerScale = scale
                        }
                    }
                    .refreshable {
                        HapticManager.shared.impact(.medium)
                        isRefreshing = true
                        await feedDataManager.refresh()
                        isRefreshing = false
                    }
                }
            }
            .navigationBarHidden(true)
        }
        .onAppear {
            feedDataManager.appState = appState
            withAnimation(.easeInOut(duration: 0.8).delay(0.3)) {
                feedOpacity = 1
            }
        }
        .task {
            await feedDataManager.startStreaming(filter: selectedFilter)
        }
        .onChange(of: selectedFilter) { _, newFilter in
            Task {
                await feedDataManager.changeFilter(newFilter)
            }
        }
        .onChange(of: feedDataManager.timelineEvents) {
            Task {
                await fetchEngagements()
            }
        }
        .sheet(isPresented: $showFilterSheet) {
            FilterSelectionSheet(selectedFilter: $selectedFilter)
                .presentationDetents([.height(300)])
                .presentationDragIndicator(.visible)
        }
    }
    private var feedHeader: some View {
        VStack(spacing: DesignSystem.Spacing.medium) {
            HStack {
                VStack(alignment: .leading, spacing: DesignSystem.Spacing.mini) {
                    Text("Timeline")
                        .font(.system(size: 36, weight: .bold, design: .rounded))
                        .foregroundColor(DesignSystem.Colors.text)
                    Text("Latest highlights from your network")
                        .font(.ds.body)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                }
                Spacer()
                // Filter button with badge
                Button(action: { showFilterSheet = true }) {
                    ZStack(alignment: .topTrailing) {
                        Circle()
                            .fill(.ultraThinMaterial)
                            .frame(width: 44, height: 44)
                            .overlay(
                                Image(systemName: "line.3.horizontal.decrease.circle")
                                    .font(.system(size: 20, weight: .medium))
                                    .foregroundColor(selectedFilter.color)
                            )
                        if selectedFilter != .all {
                            Circle()
                                .fill(selectedFilter.color)
                                .frame(width: 12, height: 12)
                                .offset(x: 4, y: -4)
                        }
                    }
                }
                .buttonStyle(ScaleButtonStyle())
            }
            .padding(.horizontal, DesignSystem.Spacing.large)
            // Quick filter pills
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: DesignSystem.Spacing.small) {
                    ForEach(FeedFilter.allCases, id: \.self) { filter in
                        FilterPill(
                            filter: filter,
                            isSelected: selectedFilter == filter,
                            action: { selectedFilter = filter }
                        )
                    }
                }
                .padding(.horizontal, DesignSystem.Spacing.large)
            }
        }
    }
    private func fetchEngagements() async {
        let eventIds = feedDataManager.timelineEvents.prefix(20).map { $0.id }
        guard !eventIds.isEmpty else { return }
        let fetchedEngagements = await appState.engagementService.fetchEngagementBatch(for: eventIds)
        await MainActor.run {
            engagements = fetchedEngagements
        }
    }
}
// MARK: - Timeline Event Card
struct TimelineEventCard: View {
    let event: NDKEvent
    let engagement: EngagementService.EngagementMetrics
    @State private var isExpanded = false
    @State private var showDetail = false
    @State private var cardRotation: Double = 0
    @State private var isPressed = false
    var body: some View {
        Button(action: { showDetail = true }) {
            VStack(alignment: .leading, spacing: 0) {
                // Header with author info
                HStack(spacing: DesignSystem.Spacing.small) {
                    EnhancedAsyncProfileImage(pubkey: event.pubkey, size: 42)
                    VStack(alignment: .leading, spacing: 2) {
                        Text(PubkeyFormatter.formatCompact(event.pubkey))
                            .font(.system(size: 15, weight: .semibold))
                            .foregroundColor(DesignSystem.Colors.text)
                        HStack(spacing: 4) {
                            Image(systemName: "clock")
                                .font(.system(size: 11))
                            Text(RelativeTimeFormatter.shortRelativeTime(from: event.createdAt))
                                .font(.system(size: 12))
                        }
                        .foregroundColor(DesignSystem.Colors.textTertiary)
                    }
                    Spacer()
                    // More menu
                    Menu {
                        Button(action: {}) {
                            Label("Share", systemImage: "square.and.arrow.up")
                        }
                        Button(action: {}) {
                            Label("Copy", systemImage: "doc.on.doc")
                        }
                        Button(action: {}) {
                            Label("Report", systemImage: "flag")
                        }
                    } label: {
                        Circle()
                            .fill(Color.primary.opacity(0.05))
                            .frame(width: 32, height: 32)
                            .overlay(
                                Image(systemName: "ellipsis")
                                    .font(.system(size: 14, weight: .medium))
                                    .foregroundColor(.primary.opacity(0.6))
                            )
                    }
                }
                .padding(DesignSystem.Spacing.medium)
                // Content
                VStack(alignment: .leading, spacing: DesignSystem.Spacing.small) {
                    Text(event.content)
                        .font(.system(size: 16))
                        .foregroundColor(DesignSystem.Colors.text)
                        .lineLimit(isExpanded ? nil : 4)
                        .fixedSize(horizontal: false, vertical: true)
                    if event.content.count > 200 && !isExpanded {
                        Button(action: { withAnimation { isExpanded.toggle() } }) {
                            Text("Show more")
                                .font(.system(size: 14, weight: .medium))
                                .foregroundColor(DesignSystem.Colors.primary)
                        }
                    }
                }
                .padding(.horizontal, DesignSystem.Spacing.medium)
                // Engagement bar
                HStack(spacing: 0) {
                    TimelineEngagementButton(
                        icon: "bubble.right",
                        count: engagement.comments,
                        action: {}
                    )
                    TimelineEngagementButton(
                        icon: "arrow.2.squarepath",
                        count: engagement.reposts,
                        action: {}
                    )
                    TimelineEngagementButton(
                        icon: "heart",
                        count: engagement.likes,
                        action: {}
                    )
                    TimelineEngagementButton(
                        icon: "bolt.fill",
                        count: engagement.zaps,
                        color: .ds.secondary,
                        action: {}
                    )
                    Spacer()
                    // Bookmark button
                    Button(action: {}) {
                        Image(systemName: "bookmark")
                            .font(.system(size: 16))
                            .foregroundColor(.primary.opacity(0.6))
                    }
                    .padding(.trailing, DesignSystem.Spacing.medium)
                }
                .padding(.vertical, DesignSystem.Spacing.small)
            }
        }
        .buttonStyle(PlainButtonStyle())
        .background(
            RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.xl, style: .continuous)
                .fill(.ultraThinMaterial)
                .overlay(
                    RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.xl, style: .continuous)
                        .stroke(
                            LinearGradient(
                                colors: [
                                    Color.white.opacity(0.2),
                                    Color.white.opacity(0.05)
                                ],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ),
                            lineWidth: 1
                        )
                )
        )
        .shadow(
            color: Color.black.opacity(0.08),
            radius: isPressed ? 4 : 12,
            x: 0,
            y: isPressed ? 2 : 6
        )
        .scaleEffect(isPressed ? 0.97 : 1)
        .rotation3DEffect(
            .degrees(cardRotation),
            axis: (x: 0, y: 1, z: 0),
            perspective: 1
        )
        .animation(.spring(response: 0.4, dampingFraction: 0.7), value: isPressed)
        .onLongPressGesture(minimumDuration: 0.1, maximumDistance: .infinity, pressing: { pressing in
            isPressed = pressing
            if pressing {
                HapticManager.shared.impact(.light)
            }
        }, perform: {})
    }
}
// MARK: - Supporting Views
struct FilterPill: View {
    let filter: TimelineFeedView.FeedFilter
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            HStack(spacing: 6) {
                Image(systemName: filter.icon)
                    .font(.system(size: 14, weight: .semibold))
                Text(filter.rawValue)
                    .font(.system(size: 14, weight: .medium))
            }
            .padding(.horizontal, 14)
            .padding(.vertical, 8)
            .background(
                Capsule()
                    .fill(isSelected ? filter.color : Color.primary.opacity(0.08))
            )
            .foregroundColor(isSelected ? .white : .primary)
            .overlay(
                Capsule()
                    .strokeBorder(
                        isSelected ? Color.clear : Color.primary.opacity(0.1),
                        lineWidth: 1
                    )
            )
        }
        .buttonStyle(TimelineScaleButtonStyle())
    }
}
struct TimelineEngagementButton: View {
    let icon: String
    let count: Int
    var color: Color = .primary
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            HStack(spacing: 4) {
                Image(systemName: icon)
                    .font(.system(size: 16))
                if count > 0 {
                    Text("\(count)")
                        .font(.system(size: 13, weight: .medium))
                }
            }
            .foregroundColor(color.opacity(0.8))
            .padding(.horizontal, DesignSystem.Spacing.medium)
            .padding(.vertical, DesignSystem.Spacing.small)
        }
        .buttonStyle(TimelineScaleButtonStyle(scale: 1.1))
    }
}
struct TimelineSkeletonCard: View {
    @State private var shimmerOffset: CGFloat = -200
    var body: some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.medium) {
            // Header skeleton
            HStack(spacing: DesignSystem.Spacing.small) {
                Circle()
                    .fill(Color.primary.opacity(0.1))
                    .frame(width: 42, height: 42)
                VStack(alignment: .leading, spacing: 4) {
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.primary.opacity(0.1))
                        .frame(width: 120, height: 14)
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.primary.opacity(0.08))
                        .frame(width: 80, height: 12)
                }
                Spacer()
            }
            // Content skeleton
            VStack(alignment: .leading, spacing: 8) {
                ForEach(0..<3, id: \.self) { index in
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.primary.opacity(0.08))
                        .frame(height: 16)
                        .frame(maxWidth: index == 2 ? 200 : .infinity)
                }
            }
            // Footer skeleton
            HStack(spacing: DesignSystem.Spacing.large) {
                ForEach(0..<4, id: \.self) { _ in
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.primary.opacity(0.06))
                        .frame(width: 40, height: 20)
                }
            }
        }
        .padding(DesignSystem.Spacing.medium)
        .background(
            RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.xl, style: .continuous)
                .fill(Color.primary.opacity(0.03))
        )
        .overlay(
            LinearGradient(
                colors: [
                    Color.clear,
                    Color.white.opacity(0.3),
                    Color.clear
                ],
                startPoint: .leading,
                endPoint: .trailing
            )
            .frame(width: 100)
            .offset(x: shimmerOffset)
            .mask(
                RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.xl, style: .continuous)
            )
        )
        .onAppear {
            withAnimation(
                .linear(duration: 1.5)
                .repeatForever(autoreverses: false)
            ) {
                shimmerOffset = 300
            }
        }
    }
}
struct TimelineGradientBackground: View {
    @State private var animateGradient = false
    var body: some View {
        Rectangle()
            .fill(
                LinearGradient(
                    colors: [
                        DesignSystem.Colors.background,
                        DesignSystem.Colors.primary.opacity(0.05),
                        DesignSystem.Colors.secondary.opacity(0.03),
                        DesignSystem.Colors.background
                    ],
                    startPoint: animateGradient ? .topLeading : .bottomLeading,
                    endPoint: animateGradient ? .bottomTrailing : .topTrailing
                )
            )
            .animation(
                .easeInOut(duration: 8)
                .repeatForever(autoreverses: true),
                value: animateGradient
            )
            .onAppear {
                animateGradient = true
            }
    }
}
struct TimelineParticles: View {
    @State private var particles: [TimelineParticle] = []
    var body: some View {
        GeometryReader { geometry in
            ForEach(particles) { particle in
                Circle()
                    .fill(particle.color.opacity(particle.opacity))
                    .frame(width: particle.size, height: particle.size)
                    .blur(radius: particle.blur)
                    .position(x: particle.x, y: particle.y)
                    .animation(
                        .linear(duration: particle.lifetime)
                        .repeatForever(autoreverses: false),
                        value: particle.y
                    )
            }
        }
        .onAppear {
            generateParticles()
        }
    }
    private func generateParticles() {
        particles = (0..<15).map { _ in
            TimelineParticle(
                color: [.ds.primary, .ds.secondary, .ds.primary.opacity(0.5)].randomElement()!,
                size: CGFloat.random(in: 20...60),
                opacity: Double.random(in: 0.05...0.15),
                blur: CGFloat.random(in: 8...20),
                lifetime: Double.random(in: 15...30)
            )
        }
    }
}
struct TimelineParticle: Identifiable {
    let id = UUID()
    let color: Color
    let size: CGFloat
    let opacity: Double
    let blur: CGFloat
    let lifetime: Double
    var x: CGFloat = CGFloat.random(in: 0...UIScreen.main.bounds.width)
    var y: CGFloat = CGFloat.random(in: -100...UIScreen.main.bounds.height + 100)
}
struct FilterSelectionSheet: View {
    @Binding var selectedFilter: TimelineFeedView.FeedFilter
    @Environment(\.dismiss) var dismiss
    var body: some View {
        VStack(spacing: DesignSystem.Spacing.large) {
            // Handle
            Capsule()
                .fill(Color.primary.opacity(0.2))
                .frame(width: 40, height: 4)
                .padding(.top, DesignSystem.Spacing.small)
            Text("Filter Timeline")
                .font(.system(size: 20, weight: .bold))
                .padding(.top, DesignSystem.Spacing.small)
            VStack(spacing: DesignSystem.Spacing.small) {
                ForEach(TimelineFeedView.FeedFilter.allCases, id: \.self) { filter in
                    Button(action: {
                        selectedFilter = filter
                        HapticManager.shared.impact(.light)
                        dismiss()
                    }) {
                        HStack(spacing: DesignSystem.Spacing.medium) {
                            Image(systemName: filter.icon)
                                .font(.system(size: 20))
                                .foregroundColor(filter.color)
                                .frame(width: 30)
                            VStack(alignment: .leading, spacing: 2) {
                                Text(filter.rawValue)
                                    .font(.system(size: 16, weight: .semibold))
                                    .foregroundColor(.primary)
                                Text(filterDescription(for: filter))
                                    .font(.system(size: 13))
                                    .foregroundColor(.secondary)
                            }
                            Spacer()
                            if selectedFilter == filter {
                                Image(systemName: "checkmark.circle.fill")
                                    .font(.system(size: 20))
                                    .foregroundColor(filter.color)
                            }
                        }
                        .padding(DesignSystem.Spacing.medium)
                        .background(
                            RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.medium)
                                .fill(selectedFilter == filter ? filter.color.opacity(0.1) : Color.primary.opacity(0.05))
                        )
                    }
                    .buttonStyle(PlainButtonStyle())
                }
            }
            .padding(.horizontal, DesignSystem.Spacing.large)
            Spacer()
        }
        .background(Color(UIColor.systemBackground))
    }
    private func filterDescription(for filter: TimelineFeedView.FeedFilter) -> String {
        switch filter {
        case .all: return "Show all highlights from the network"
        case .following: return "Only from people you follow"
        case .trending: return "Most engaged highlights"
        case .recent: return "Latest highlights first"
        }
    }
}
// MARK: - Button Styles
struct TimelineScaleButtonStyle: ButtonStyle {
    var scale: CGFloat = 0.95
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? scale : 1)
            .animation(.easeInOut(duration: 0.15), value: configuration.isPressed)
    }
}
// MARK: - Feed Data Manager
@MainActor
class FeedDataManager: ObservableObject {
    @Published var timelineEvents: [NDKEvent] = []
    // No loading states - data streams progressively
    weak var appState: AppState?
    private var activeFilter: TimelineFeedView.FeedFilter = .all
    private var dataSource: NDKDataSource<NDKEvent>?
    private var streamTask: Task<Void, Never>?
    func startStreaming(filter: TimelineFeedView.FeedFilter) async {
        guard let appState = appState, let ndk = appState.ndk else { return }
        // Start streaming immediately - no loading states
        activeFilter = filter
        // Cancel existing stream
        streamTask?.cancel()
        streamTask = nil
        // Create filter based on selection
        let filter = createFilter(for: filter)
        // Create data source for observing events
        dataSource = await ndk.outbox.observe(
            filter: filter,
            maxAge: 0,  // Real-time updates
            cachePolicy: .cacheWithNetwork
        )
        // Start streaming events
        streamTask = Task {
            guard let dataSource = dataSource else { return }
            // Stream events (includes cached events first)
            for await event in dataSource.events {
                guard !Task.isCancelled else { break }
                addEvent(event)
            }
        }
        // Events stream continuously
    }
    func changeFilter(_ filter: TimelineFeedView.FeedFilter) async {
        timelineEvents.removeAll()
        await startStreaming(filter: filter)
    }
    func refresh() async {
        await changeFilter(activeFilter)
    }
    private func createFilter(for feedFilter: TimelineFeedView.FeedFilter) -> NDKFilter {
        switch feedFilter {
        case .all:
            return NDKFilter(kinds: [9802]) // All highlights
        case .following:
            // For now, return all highlights
            // Following functionality needs to be implemented properly
            return NDKFilter(kinds: [9802], limit: 100)
        case .trending:
            // Implement trending by getting recent highlights with most engagement
            let since = Date().addingTimeInterval(-TimeConstants.day)
            return NDKFilter(
                kinds: [9802],
                since: Int64(since.timeIntervalSince1970),
                limit: 100
            )
        case .recent:
            let since = Date().addingTimeInterval(-TimeConstants.hour * 2)
            return NDKFilter(kinds: [9802], since: Int64(since.timeIntervalSince1970))
        }
    }
    private func addEvent(_ event: NDKEvent) {
        // Avoid duplicates
        guard !timelineEvents.contains(where: { $0.id == event.id }) else { return }
        withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
            timelineEvents.insert(event, at: 0)
            // Keep max 100 events
            if timelineEvents.count > 100 {
                timelineEvents.removeLast()
            }
        }
    }
}
#Preview {
    TimelineFeedView()
        .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Views/Highlights/CreateHighlightView.swift">
import SwiftUI
import NDKSwift
struct CreateHighlightView: View {
    @State private var selectedMode = HighlightMode.paste
    @State private var pastedText = ""
    @State private var sourceTitle = ""
    @State private var sourceAuthor = ""
    @State private var sourceURL = ""
    @State private var urlInputVisible = false
    @State private var isSaving = false
    @State private var importedContent = ""
    @State private var showImportOptions = false
    @State private var isImporting = false
    @State private var animateBackground = false
    @State private var showSmartImporter = false
    @State private var commentText = ""
    @State private var contextText = ""
    @Environment(\.dismiss) var dismiss
    enum HighlightMode: CaseIterable {
        case paste
        case article
        var title: String {
            switch self {
            case .paste: return "Paste Text"
            case .article: return "Import Article"
            }
        }
        var icon: String {
            switch self {
            case .paste: return "doc.on.clipboard"
            case .article: return "doc.text"
            }
        }
        var description: String {
            switch self {
            case .paste: return "Paste any text to highlight"
            case .article: return "Import from your saved articles"
            }
        }
    }
    @EnvironmentObject var appState: AppState
    var body: some View {
        NavigationStack {
            ZStack {
                CreateHighlightGradientBackground(animating: animateBackground)
                ScrollView {
                    VStack(spacing: 24) {
                        // Mode Selection
                        VStack(spacing: 16) {
                            Text("Create Highlight")
                                .font(.largeTitle.weight(.bold))
                                .foregroundColor(.ds.text)
                            HStack(spacing: 12) {
                                ForEach(HighlightMode.allCases, id: \.self) { mode in
                                    HighlightModeCard(
                                        mode: mode,
                                        isSelected: selectedMode == mode,
                                        action: {
                                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                                selectedMode = mode
                                                HapticManager.shared.impact(.light)
                                            }
                                        }
                                    )
                                }
                            }
                        }
                        .padding(.top, 40)
                        // Content Input
                        Group {
                            switch selectedMode {
                            case .paste:
                                pasteTextView
                            case .article:
                                importArticleView
                            }
                        }
                        .transition(.asymmetric(
                            insertion: .push(from: .trailing).combined(with: .opacity),
                            removal: .push(from: .leading).combined(with: .opacity)
                        ))
                        // Save Button
                        Button(action: saveHighlight) {
                            Label(isSaving ? "Saving..." : "Save Highlight", 
                                  systemImage: isSaving ? "arrow.circlepath" : "checkmark.circle.fill")
                                .font(.headline)
                                .frame(maxWidth: .infinity)
                                .padding(.vertical, 16)
                                .background(
                                    RoundedRectangle(cornerRadius: 16, style: .continuous)
                                        .fill(isReadyToSave ? Color.ds.primary : Color.secondary.opacity(0.3))
                                )
                                .foregroundColor(.white)
                                .scaleEffect(isSaving ? 0.95 : 1.0)
                        }
                        .disabled(!isReadyToSave || isSaving)
                        .buttonStyle(.plain)
                        .padding(.bottom, 40)
                    }
                    .padding(.horizontal)
                }
            }
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                    .foregroundColor(.ds.primary)
                }
            }
            .sheet(isPresented: $showImportOptions) {
                SmartContentImporter()
            }
            .fullScreenCover(isPresented: $showSmartImporter) {
                SmartArticleImportView()
            }
        }
        .onAppear {
            withAnimation(.easeInOut(duration: 3).repeatForever(autoreverses: true)) {
                animateBackground = true
            }
        }
    }
    private var isReadyToSave: Bool {
        switch selectedMode {
        case .paste:
            return !pastedText.isEmpty
        case .article:
            return !importedContent.isEmpty
        }
    }
    // MARK: - Paste Text View
    private var pasteTextView: some View {
        VStack(alignment: .leading, spacing: 20) {
            // Text Input
            VStack(alignment: .leading, spacing: 8) {
                Label("Highlight Text", systemImage: "highlighter")
                    .font(.headline)
                    .foregroundColor(.ds.text)
                TextEditor(text: $pastedText)
                    .frame(minHeight: 150)
                    .padding(12)
                    .background(
                        RoundedRectangle(cornerRadius: 12, style: .continuous)
                            .fill(Color.ds.surfaceSecondary)
                            .overlay(
                                RoundedRectangle(cornerRadius: 12, style: .continuous)
                                    .strokeBorder(Color.ds.border, lineWidth: 1)
                            )
                    )
                    .font(.body)
            }
            // Source Information
            VStack(spacing: 12) {
                ModernTextField(
                    icon: "book",
                    placeholder: "Source Title (optional)",
                    text: $sourceTitle
                )
                ModernTextField(
                    icon: "person",
                    placeholder: "Author (optional)",
                    text: $sourceAuthor
                )
                ModernTextField(
                    icon: "link",
                    placeholder: "Source URL (optional)",
                    text: $sourceURL
                )
            }
            // Additional fields
            VStack(alignment: .leading, spacing: 8) {
                Label("Context (optional)", systemImage: "text.alignleft")
                    .font(.headline)
                    .foregroundColor(.ds.text)
                TextEditor(text: $contextText)
                    .frame(minHeight: 80)
                    .padding(12)
                    .background(
                        RoundedRectangle(cornerRadius: 12, style: .continuous)
                            .fill(Color.ds.surfaceSecondary)
                            .overlay(
                                RoundedRectangle(cornerRadius: 12, style: .continuous)
                                    .strokeBorder(Color.ds.border, lineWidth: 1)
                            )
                    )
                    .font(.body)
            }
            // Comment field
            VStack(alignment: .leading, spacing: 8) {
                Label("Your Comment (optional)", systemImage: "text.bubble")
                    .font(.headline)
                    .foregroundColor(.ds.text)
                TextEditor(text: $commentText)
                    .frame(minHeight: 80)
                    .padding(12)
                    .background(
                        RoundedRectangle(cornerRadius: 12, style: .continuous)
                            .fill(Color.ds.surfaceSecondary)
                            .overlay(
                                RoundedRectangle(cornerRadius: 12, style: .continuous)
                                    .strokeBorder(Color.ds.border, lineWidth: 1)
                            )
                    )
                    .font(.body)
            }
        }
    }
    private var importArticleView: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Recent Articles")
                .font(.headline)
                .foregroundColor(.ds.text)
            if appState.articles.isEmpty {
                ArticlePlaceholderCard()
                    .onTapGesture {
                        showImportOptions = true
                    }
            } else {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: 12) {
                        ForEach(Array(appState.articles.prefix(5)), id: \.id) { article in
                            ArticleSelectionCard(article: article) {
                                selectArticle(article)
                            }
                        }
                    }
                    .padding(.horizontal, 2)
                }
            }
            Button(action: { showImportOptions = true }) {
                Label("Import New Article", systemImage: "plus.circle.fill")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(.ds.primary)
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 12)
                    .background(
                        RoundedRectangle(cornerRadius: 12, style: .continuous)
                            .fill(Color.ds.primary.opacity(0.1))
                            .overlay(
                                RoundedRectangle(cornerRadius: 12, style: .continuous)
                                    .strokeBorder(Color.ds.primary.opacity(0.3), lineWidth: 1)
                            )
                    )
            }
            .buttonStyle(.plain)
        }
    }
    // MARK: - Actions
    private func selectArticle(_ article: Article) {
        importedContent = article.content
        sourceTitle = article.title
        sourceAuthor = "nostr:" + article.author
        sourceURL = article.references.first ?? ""
        selectedMode = .article
        HapticManager.shared.impact(.medium)
    }
    private func saveHighlight() {
        Task {
            await MainActor.run {
                isSaving = true
                HapticManager.shared.impact(.medium)
            }
            let content = selectedMode == .paste ? pastedText : importedContent
            // Create highlight event
            let highlight = HighlightEvent(
                content: content,
                context: contextText.isEmpty ? nil : contextText,
                source: sourceURL.isEmpty ? nil : sourceURL,
                author: sourceAuthor.isEmpty ? nil : sourceAuthor.replacingOccurrences(of: "nostr:", with: ""),
                comment: commentText.isEmpty ? nil : commentText
            )
            // Publish the highlight
            do {
                try await appState.publishingService.publishHighlight(highlight)
                await MainActor.run {
                    HapticManager.shared.notification(.success)
                    dismiss()
                }
            } catch {
                await MainActor.run {
                    HapticManager.shared.notification(.error)
                    // Keep the view open to let user retry
                }
            }
            await MainActor.run {
                isSaving = false
            }
        }
    }
    private func handleURLImport(_ url: String) {
        guard !url.isEmpty else { return }
        Task {
            await MainActor.run {
                isImporting = true
            }
            // Since we don't have actual URL import functionality yet,
            // we'll just save the URL and let the user paste content
            await MainActor.run {
                sourceURL = url
                isImporting = false
                urlInputVisible = false
                HapticManager.shared.notification(.success)
            }
        }
    }
}
// MARK: - Supporting Views
struct HighlightModeCard: View {
    let mode: CreateHighlightView.HighlightMode
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            VStack(spacing: 12) {
                ZStack {
                    Circle()
                        .fill(isSelected ? Color.ds.primary : Color.ds.surfaceSecondary)
                        .frame(width: 60, height: 60)
                        .overlay(
                            Circle()
                                .strokeBorder(isSelected ? Color.clear : Color.ds.border, lineWidth: 1)
                        )
                    Image(systemName: mode.icon)
                        .font(.system(size: 24, weight: .semibold))
                        .foregroundColor(isSelected ? .white : .ds.textSecondary)
                }
                VStack(spacing: 4) {
                    Text(mode.title)
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundColor(isSelected ? .ds.text : .ds.textSecondary)
                    Text(mode.description)
                        .font(.system(size: 12))
                        .foregroundColor(.ds.textTertiary)
                        .multilineTextAlignment(.center)
                        .lineLimit(2)
                }
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 20)
            .padding(.horizontal, 16)
            .background(
                RoundedRectangle(cornerRadius: 20, style: .continuous)
                    .fill(isSelected ? Color.ds.primary.opacity(0.08) : Color.ds.surfaceSecondary)
                    .overlay(
                        RoundedRectangle(cornerRadius: 20, style: .continuous)
                            .strokeBorder(isSelected ? Color.ds.primary.opacity(0.3) : Color.clear, lineWidth: 2)
                    )
            )
            .scaleEffect(isSelected ? 1.02 : 1.0)
        }
        .buttonStyle(.plain)
    }
}
struct ArticleSelectionCard: View {
    let article: Article
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            VStack(alignment: .leading, spacing: 8) {
                Text(article.title)
                    .font(.system(size: 14, weight: .semibold))
                    .foregroundColor(.ds.text)
                    .lineLimit(2)
                    .multilineTextAlignment(.leading)
                if let summary = article.summary {
                    Text(summary)
                        .font(.system(size: 12))
                        .foregroundColor(.ds.textSecondary)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)
                }
                HStack {
                    Label("\(article.estimatedReadingTime) min", systemImage: "clock")
                        .font(.system(size: 11))
                        .foregroundColor(.ds.textTertiary)
                    Spacer()
                    Text(article.createdAt.formatted(.relative(presentation: .named)))
                        .font(.system(size: 11))
                        .foregroundColor(.ds.textTertiary)
                }
            }
            .padding(12)
            .frame(width: 220, alignment: .leading)
            .background(
                RoundedRectangle(cornerRadius: 12, style: .continuous)
                    .fill(Color.ds.surfaceSecondary)
            )
            .overlay(
                RoundedRectangle(cornerRadius: 12, style: .continuous)
                    .strokeBorder(Color.ds.border, lineWidth: 1)
            )
        }
        .buttonStyle(.plain)
    }
}
struct ArticlePlaceholderCard: View {
    var body: some View {
        VStack(spacing: 16) {
            Image(systemName: "doc.text.magnifyingglass")
                .font(.system(size: 48))
                .foregroundColor(.orange.opacity(0.6))
            VStack(spacing: 8) {
                Text("No articles yet")
                    .font(.headline)
                    .foregroundColor(.ds.text)
                Text("Import your first article to start highlighting")
                    .font(.subheadline)
                    .foregroundColor(.ds.textSecondary)
                    .multilineTextAlignment(.center)
            }
            Text("Tap to import")
                .font(.caption)
                .foregroundColor(.orange)
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 40)
        .padding(.horizontal, 24)
        .background(
            RoundedRectangle(cornerRadius: 16, style: .continuous)
                .fill(Color.orange.opacity(0.05))
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .strokeBorder(Color.orange.opacity(0.2), lineWidth: 1)
        )
    }
}
struct CreateHighlightGradientBackground: View {
    let animating: Bool
    var body: some View {
        if #available(iOS 18.0, *) {
            MeshGradient(
                width: 3,
                height: 3,
                points: [
                    [0.0, 0.0], [0.5, 0.0], [1.0, 0.0],
                    [0.0, 0.5], [animating ? 0.6 : 0.4, 0.5], [1.0, 0.5],
                    [0.0, 1.0], [0.5, 1.0], [1.0, 1.0]
                ],
                colors: [
                    .purple.opacity(0.1), .pink.opacity(0.05), .purple.opacity(0.1),
                    .pink.opacity(0.05), .clear, .purple.opacity(0.05),
                    .purple.opacity(0.1), .pink.opacity(0.05), .purple.opacity(0.1)
                ]
            )
            .ignoresSafeArea()
        } else {
            // Fallback for iOS 17
            LinearGradient(
                colors: [.purple.opacity(0.1), .pink.opacity(0.05)],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            .ignoresSafeArea()
        }
    }
}
struct ModernTextField: View {
    let icon: String
    let placeholder: String
    @Binding var text: String
    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: icon)
                .font(.system(size: 16))
                .foregroundColor(.ds.textSecondary)
                .frame(width: 20)
            TextField(placeholder, text: $text)
                .font(.body)
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 14)
        .background(
            RoundedRectangle(cornerRadius: 12, style: .continuous)
                .fill(Color.ds.surfaceSecondary)
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .strokeBorder(Color.ds.border, lineWidth: 1)
        )
    }
}
#Preview {
    CreateHighlightView()
        .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Views/Highlights/SwarmHeatmapView.swift">
import SwiftUI
import NDKSwift
struct SwarmHeatmapView: View {
    let articleId: String
    let content: String
    @StateObject private var heatmapData = SwarmHeatmapData()
    @State private var hoveredRange: NSRange?
    @State private var selectedRange: NSRange?
    @State private var showTooltip = false
    @State private var tooltipPosition: CGPoint = .zero
    @State private var particlePositions: [ParticlePosition] = []
    @State private var isShowingHighlightCreation = false
    @State private var showingZapAllConfirmation = false
    @State private var selectedTextForHighlight = ""
    @EnvironmentObject var appState: AppState
    @Namespace private var animation
    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .topLeading) {
                // Base text with heatmap overlay
                HeatmapTextView(
                    content: content,
                    heatmapData: heatmapData,
                    hoveredRange: $hoveredRange,
                    selectedRange: $selectedRange,
                    geometry: geometry
                )
                // Particle effects layer
                ParticleLayer(particles: $particlePositions)
                    .allowsHitTesting(false)
                // Interactive tooltip
                if showTooltip, let range = selectedRange {
                    SwarmTooltipView(
                        range: range,
                        heatmapData: heatmapData,
                        position: tooltipPosition,
                        onZap: { userId in
                            HapticManager.shared.impact(.light)
                            zapHighlighter(userId: userId)
                        }
                    )
                    .transition(.asymmetric(
                        insertion: .scale(scale: 0.8).combined(with: .opacity),
                        removal: .scale(scale: 0.95).combined(with: .opacity)
                    ))
                    .zIndex(100)
                }
            }
            .onAppear {
                startHeatmapUpdates()
                startParticleAnimation()
            }
        }
        .background(Color.ds.background)
        .sheet(isPresented: $isShowingHighlightCreation) {
            CreateHighlightView()
                .environmentObject(appState)
        }
        .alert("Zap All Highlighters", isPresented: $showingZapAllConfirmation) {
            Button("Cancel", role: .cancel) { }
            Button("Zap All") {
                Task {
                    await zapAllHighlighters()
                }
            }
        } message: {
            Text("Send \(heatmapData.getHighlighters(for: selectedRange ?? NSRange()).count * 21) sats total (21 sats to each highlighter)?")
        }
    }
    private func startHeatmapUpdates() {
        Task {
            await heatmapData.startStreaming(articleId: articleId)
        }
    }
    private func startParticleAnimation() {
        Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { _ in
            updateParticles()
        }
    }
    private func updateParticles() {
        // Add new particles for active highlights
        for highlight in heatmapData.activeHighlights {
            if Double.random(in: 0...1) < 0.3 { // 30% chance
                let position = calculateParticlePosition(for: highlight.range)
                particlePositions.append(ParticlePosition(
                    id: UUID(),
                    start: position,
                    end: position.applying(.init(translationX: .random(in: -50...50), y: -100)),
                    startTime: Date()
                ))
            }
        }
        // Remove old particles
        particlePositions.removeAll { particle in
            Date().timeIntervalSince(particle.startTime) > 2.0
        }
    }
    private func calculateParticlePosition(for range: NSRange) -> CGPoint {
        // Calculate position based on text range
        CGPoint(x: 100, y: 100) // Simplified - would calculate actual text position
    }
    private func zapHighlighter(userId: String) {
        Task {
            // Default small zap amount is 21 sats
            // Would integrate with LightningService to send zap
            HapticManager.shared.notification(.success)
        }
    }
    private func zapAllHighlighters() async {
        let highlighters = heatmapData.getHighlighters(for: selectedRange ?? NSRange())
        for _ in highlighters {
            // Would integrate with LightningService to send zaps
            try? await Task.sleep(nanoseconds: 100_000_000) // 0.1 second delay between zaps
        }
        HapticManager.shared.notification(.success)
    }
}
// MARK: - Heatmap Text View
struct HeatmapTextView: UIViewRepresentable {
    let content: String
    let heatmapData: SwarmHeatmapData
    @Binding var hoveredRange: NSRange?
    @Binding var selectedRange: NSRange?
    let geometry: GeometryProxy
    func makeUIView(context: Context) -> HeatmapTextUIView {
        let view = HeatmapTextUIView()
        view.isEditable = false
        view.isSelectable = false
        view.backgroundColor = .clear
        view.textContainerInset = UIEdgeInsets(top: 16, left: 16, bottom: 16, right: 16)
        return view
    }
    func updateUIView(_ uiView: HeatmapTextUIView, context: Context) {
        let attributedString = createHeatmapAttributedString()
        uiView.attributedText = attributedString
        uiView.heatmapData = heatmapData
        uiView.setNeedsDisplay()
    }
    private func createHeatmapAttributedString() -> NSAttributedString {
        let baseAttributes: [NSAttributedString.Key: Any] = [
            .font: UIFont.systemFont(ofSize: 17, weight: .regular),
            .foregroundColor: UIColor.label
        ]
        let attributedString = NSMutableAttributedString(string: content, attributes: baseAttributes)
        // Apply heatmap styling
        for highlight in heatmapData.highlights {
            let intensity = min(highlight.intensity, 1.0)
            let backgroundColor = UIColor.systemOrange.withAlphaComponent(intensity * 0.3)
            attributedString.addAttributes([
                .backgroundColor: backgroundColor,
                .underlineStyle: NSUnderlineStyle.single.rawValue,
                .underlineColor: UIColor.systemOrange.withAlphaComponent(intensity)
            ], range: highlight.range)
        }
        return attributedString
    }
}
// MARK: - Custom Text View with Heatmap Drawing
class HeatmapTextUIView: UITextView {
    var heatmapData: SwarmHeatmapData?
    private var heatmapLayer: CAGradientLayer?
    override func draw(_ rect: CGRect) {
        super.draw(rect)
        drawHeatmapOverlay()
    }
    private func drawHeatmapOverlay() {
        guard let heatmapData = heatmapData,
              let context = UIGraphicsGetCurrentContext() else { return }
        context.saveGState()
        // Draw heat zones with gradient effects
        for highlight in heatmapData.highlights {
            let rects = getRects(for: highlight.range)
            for rect in rects {
                let expandedRect = rect.insetBy(dx: -4, dy: -2)
                let intensity = min(highlight.intensity, 1.0)
                // Create gradient
                let colors = [
                    UIColor.systemOrange.withAlphaComponent(0).cgColor,
                    UIColor.systemOrange.withAlphaComponent(intensity * 0.4).cgColor,
                    UIColor.systemOrange.withAlphaComponent(0).cgColor
                ]
                let gradient = CGGradient(colorsSpace: CGColorSpaceCreateDeviceRGB(),
                                        colors: colors as CFArray,
                                        locations: [0, 0.5, 1])!
                let path = UIBezierPath(roundedRect: expandedRect, cornerRadius: 4)
                context.addPath(path.cgPath)
                context.clip()
                context.drawLinearGradient(gradient,
                                         start: CGPoint(x: expandedRect.minX, y: expandedRect.midY),
                                         end: CGPoint(x: expandedRect.maxX, y: expandedRect.midY),
                                         options: [])
                context.resetClip()
            }
        }
        context.restoreGState()
    }
    private func getRects(for range: NSRange) -> [CGRect] {
        let layoutManager = layoutManager
        let textContainer = textContainer
        var rects: [CGRect] = []
        let glyphRange = layoutManager.glyphRange(forCharacterRange: range, actualCharacterRange: nil)
        layoutManager.enumerateEnclosingRects(forGlyphRange: glyphRange,
                                            withinSelectedGlyphRange: NSRange(location: NSNotFound, length: 0),
                                            in: textContainer) { rect, _ in
            rects.append(rect.offsetBy(dx: self.textContainerInset.left, dy: self.textContainerInset.top))
        }
        return rects
    }
}
// MARK: - Particle Effects
struct ParticleLayer: View {
    @Binding var particles: [ParticlePosition]
    var body: some View {
        ZStack {
            ForEach(particles) { particle in
                HeatmapParticleView(particle: particle)
            }
        }
    }
}
struct HeatmapParticleView: View {
    let particle: ParticlePosition
    @State private var opacity: Double = 1.0
    @State private var scale: Double = 0.5
    @State private var position: CGPoint
    init(particle: ParticlePosition) {
        self.particle = particle
        self._position = State(initialValue: particle.start)
    }
    var body: some View {
        Circle()
            .fill(LinearGradient(
                colors: [Color.ds.primary, Color.ds.primary.opacity(0.3)],
                startPoint: .top,
                endPoint: .bottom
            ))
            .frame(width: 6, height: 6)
            .scaleEffect(scale)
            .opacity(opacity)
            .position(position)
            .onAppear {
                withAnimation(.easeOut(duration: 2)) {
                    position = particle.end
                    opacity = 0
                    scale = 1.5
                }
            }
    }
}
// MARK: - Tooltip View
struct SwarmTooltipView: View {
    let range: NSRange
    let heatmapData: SwarmHeatmapData
    let position: CGPoint
    let onZap: (String) -> Void
    @State private var isShowingHighlightCreation = false
    @State private var showingZapAllConfirmation = false
    var highlighters: [HighlighterInfo] {
        heatmapData.getHighlighters(for: range)
    }
    var body: some View {
        VStack(spacing: 12) {
            // Header
            HStack {
                Image(systemName: "sparkles")
                    .font(.caption)
                    .foregroundColor(.ds.primary)
                Text("\(highlighters.count) highlights")
                    .font(.ds.caption)
                    .fontWeight(.bold)
                Spacer()
                Text("\(totalZaps) zaps")
                    .font(.ds.caption)
                    .foregroundColor(.ds.textSecondary)
            }
            // User avatars
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: -8) {
                    ForEach(highlighters.prefix(10)) { highlighter in
                        HighlighterAvatarView(
                            highlighter: highlighter,
                            onTap: {
                                onZap(highlighter.id)
                            }
                        )
                    }
                    if highlighters.count > 10 {
                        Text("+\(highlighters.count - 10)")
                            .font(.ds.caption)
                            .foregroundColor(.ds.textSecondary)
                            .padding(.horizontal, 8)
                            .padding(.vertical, 4)
                            .background(Color.ds.surfaceSecondary)
                            .clipShape(Capsule())
                            .padding(.leading, 8)
                    }
                }
            }
            // Quick actions
            HStack(spacing: 12) {
                Button(action: { addHighlight() }) {
                    Label("Add", systemImage: "plus.circle.fill")
                        .font(.ds.caption)
                }
                .buttonStyle(MicroButtonStyle())
                Button(action: { zapAll() }) {
                    Label("Zap All", systemImage: "bolt.fill")
                        .font(.ds.caption)
                }
                .buttonStyle(MicroButtonStyle(isPrimary: true))
            }
        }
        .padding(16)
        .frame(width: 280)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(.regularMaterial)
                .overlay(
                    RoundedRectangle(cornerRadius: 16)
                        .strokeBorder(Color.ds.border, lineWidth: 1)
                )
                .shadow(color: .black.opacity(0.1), radius: 20, x: 0, y: 10)
        )
        .position(position)
    }
    private var totalZaps: Int {
        highlighters.reduce(0) { $0 + $1.zapCount }
    }
    private func addHighlight() {
        HapticManager.shared.impact(.medium)
        isShowingHighlightCreation = true
    }
    private func zapAll() {
        HapticManager.shared.impact(.heavy)
        showingZapAllConfirmation = true
    }
}
// MARK: - Highlighter Avatar
struct HighlighterAvatarView: View {
    let highlighter: HighlighterInfo
    let onTap: () -> Void
    @State private var isPressed = false
    var body: some View {
        Button(action: onTap) {
            ZStack {
                // Avatar
                Circle()
                    .fill(Color.ds.surfaceSecondary)
                    .frame(width: 40, height: 40)
                    .overlay(
                        Text(highlighter.name.prefix(2).uppercased())
                            .font(.ds.caption)
                            .fontWeight(.bold)
                            .foregroundColor(.ds.primary)
                    )
                // Zap indicator
                if highlighter.zapCount > 0 {
                    Text("⚡️")
                        .font(.system(size: 10))
                        .offset(x: 14, y: -14)
                }
            }
            .scaleEffect(isPressed ? 0.9 : 1.0)
        }
        .buttonStyle(PlainButtonStyle())
        .onLongPressGesture(minimumDuration: 0, maximumDistance: .infinity,
                           pressing: { pressing in
            withAnimation(.spring(response: 0.3)) {
                isPressed = pressing
            }
        }, perform: {})
    }
}
// MARK: - Supporting Types
struct ParticlePosition: Identifiable {
    let id: UUID
    let start: CGPoint
    let end: CGPoint
    let startTime: Date
}
struct HighlighterInfo: Identifiable, Equatable {
    let id: String
    let name: String
    let zapCount: Int
    let timestamp: Date
}
// MARK: - Heatmap Data Manager
@MainActor
class SwarmHeatmapData: ObservableObject {
    @Published var highlights: [HeatmapHighlight] = []
    @Published var activeHighlights: [HeatmapHighlight] = []
    private var dataSource: NDKDataSource<NDKEvent>?
    struct HeatmapHighlight {
        let id: String
        let range: NSRange
        let intensity: Double
        let users: [String]
        let timestamp: Date
    }
    func startStreaming(articleId: String) async {
        // Create filter for kind 9802 (highlights) with article reference
        // let filter = NDKFilter(
        //     kinds: [9802],
        //     tags: ["r": [articleId]]
        // )
        // Need to get NDK instance from AppState
        // dataSource = ndk.observe(filter: filter)
        // Stream highlights
        guard let events = dataSource?.events else { return }
        for await event in events {
            processHighlightEvent(event)
        }
    }
    private func processHighlightEvent(_ event: NDKEvent) {
        // Process incoming highlight events and update heatmap
        // let content = event.content
        guard let range = extractRange(from: event) else { return }
        withAnimation(.spring(response: 0.5)) {
            // Update or add highlight
            if let index = highlights.firstIndex(where: { $0.range == range }) {
                let highlight = highlights[index]
                let newUsers = highlight.users + [event.pubkey]
                let newIntensity = min(Double(newUsers.count) / 10.0, 1.0)
                highlights[index] = HeatmapHighlight(
                    id: highlight.id,
                    range: range,
                    intensity: newIntensity,
                    users: Array(Set(newUsers)),
                    timestamp: Date()
                )
            } else {
                let newHighlight = HeatmapHighlight(
                    id: event.id,
                    range: range,
                    intensity: 0.1,
                    users: [event.pubkey],
                    timestamp: Date()
                )
                highlights.append(newHighlight)
                // Mark as active for particle effects
                activeHighlights.append(newHighlight)
                // Remove from active after delay
                DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                    self.activeHighlights.removeAll { $0.id == newHighlight.id }
                }
            }
        }
    }
    private func extractRange(from event: NDKEvent) -> NSRange? {
        // Extract range from event tags
        // Simplified implementation
        return NSRange(location: 100, length: 50)
    }
    func getHighlighters(for range: NSRange) -> [HighlighterInfo] {
        // Get all users who highlighted this range
        highlights
            .filter { $0.range.intersection(range) != nil }
            .flatMap { highlight in
                highlight.users.map { userId in
                    HighlighterInfo(
                        id: userId,
                        name: "User", // Would fetch actual name
                        zapCount: Int.random(in: 0...10),
                        timestamp: highlight.timestamp
                    )
                }
            }
            .removingDuplicates()
    }
}
// MARK: - Micro Button Style
struct MicroButtonStyle: ButtonStyle {
    var isPrimary = false
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .padding(.horizontal, 12)
            .padding(.vertical, 6)
            .background(
                RoundedRectangle(cornerRadius: 8)
                    .fill(isPrimary ? Color.ds.primary : Color.ds.surfaceSecondary)
            )
            .foregroundColor(isPrimary ? .white : .ds.text)
            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)
    }
}
// MARK: - Extensions
extension NSRange {
    func intersection(_ other: NSRange) -> NSRange? {
        let intersection = NSIntersectionRange(self, other)
        return intersection.length > 0 ? intersection : nil
    }
}
extension Array where Element: Equatable {
    func removingDuplicates() -> [Element] {
        var result: [Element] = []
        for element in self {
            if !result.contains(element) {
                result.append(element)
            }
        }
        return result
    }
}
</file>

<file path="Sources/Highlighter/Views/Highlights/SwarmOverlayView.swift">
import SwiftUI
import NDKSwift
extension Bool {
    static func random(probability: Double) -> Bool {
        return Double.random(in: 0...1) < probability
    }
}
struct SwarmOverlayView: View {
    let text: String
    @ObservedObject var swarmManager: SwarmHighlightManager
    @State private var selectedHighlight: SwarmHighlight?
    @State private var popoverPosition: CGPoint = .zero
    @State private var glowAnimation = false
    @State private var particlePositions: [SwarmParticlePosition] = []
    @State private var heatmapOpacity: Double = 0
    @State private var newHighlightAnimation: [String: Bool] = [:]
    @State private var liveActivityPulse = false
    @State private var swarmActivityLevel: Double = 0
    @State private var gestureOffset: CGSize = .zero
    @State private var dragVelocity: CGSize = .zero
    @State private var cardRotation: Double = 0
    @State private var activeHighlightIndex = 0
    @State private var cosmicParticles: [CosmicParticle] = []
    @State private var rippleEffects: [SwarmRippleEffect] = []
    @State private var highlightPath = Path()
    @State private var pathAnimation: CGFloat = 0
    @Namespace private var animation
    @Environment(\.colorScheme) var colorScheme
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // Cosmic background layer
                CosmicBackgroundView(
                    particles: cosmicParticles,
                    activityLevel: swarmActivityLevel
                )
                .allowsHitTesting(false)
                .blur(radius: 3)
                // Live activity indicator
                LiveSwarmActivityIndicator(
                    activityLevel: swarmActivityLevel,
                    isPulsing: liveActivityPulse
                )
                .position(x: geometry.size.width - 40, y: 40)
                .allowsHitTesting(false)
                // Ripple effects layer
                ForEach(rippleEffects) { ripple in
                    SwarmRippleEffectView(ripple: ripple)
                }
                .allowsHitTesting(false)
                // Heatmap overlay layer with enhanced effects
                SwarmHeatmapOverlay(
                    text: text,
                    swarmHighlights: swarmManager.findOverlappingHighlights(in: text),
                    opacity: heatmapOpacity
                )
                .allowsHitTesting(false)
                .blur(radius: 6 + (swarmActivityLevel * 4))
                .scaleEffect(1 + (swarmActivityLevel * 0.05))
                // Connection paths between highlights
                if highlightPath.isEmpty == false {
                    highlightPath
                        .trim(from: 0, to: pathAnimation)
                        .stroke(
                            LinearGradient(
                                colors: [.orange.opacity(0.6), .orange.opacity(0.2)],
                                startPoint: .leading,
                                endPoint: .trailing
                            ),
                            style: StrokeStyle(lineWidth: 2, lineCap: .round, dash: [5, 3])
                        )
                        .blur(radius: 1)
                        .allowsHitTesting(false)
                }
                // Main text view with highlights
                SwarmTextView(
                    text: text,
                    swarmHighlights: swarmManager.findOverlappingHighlights(in: text),
                    selectedHighlight: $selectedHighlight,
                    popoverPosition: $popoverPosition,
                    geometry: geometry,
                    newHighlightAnimation: $newHighlightAnimation
                )
                .offset(gestureOffset)
                .scaleEffect(1 - abs(gestureOffset.width) / 1000)
                .rotation3DEffect(
                    .degrees(Double(gestureOffset.width / 10)),
                    axis: (x: 0, y: 1, z: 0),
                    perspective: 0.5
                )
                // Particle effects layer with physics
                ForEach(particlePositions) { particle in
                    ParticleView(particle: particle)
                        .offset(
                            x: dragVelocity.width * 0.3,
                            y: dragVelocity.height * 0.3
                        )
                }
            }
            .gesture(
                DragGesture()
                    .onChanged { value in
                        gestureOffset = value.translation
                        dragVelocity = CGSize(
                            width: value.velocity.width / 50,
                            height: value.velocity.height / 50
                        )
                    }
                    .onEnded { _ in
                        withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
                            gestureOffset = .zero
                            dragVelocity = .zero
                        }
                    }
            )
        }
        .overlay(alignment: .topLeading) {
            if let highlight = selectedHighlight {
                SwarmPopover(
                    highlight: highlight,
                    position: popoverPosition,
                    onDismiss: { 
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                            selectedHighlight = nil
                        }
                    }
                )
                .transition(.asymmetric(
                    insertion: .scale(scale: 0.8).combined(with: .opacity),
                    removal: .scale(scale: 0.9).combined(with: .opacity)
                ))
                .zIndex(1000)
            }
        }
        .onAppear {
            startAnimations()
            generateParticles()
            generateCosmicParticles()
            calculateHighlightPaths()
        }
        .onChange(of: swarmManager.swarmHighlights) { oldValue, newValue in
            animateNewHighlights(oldValue: oldValue, newValue: newValue)
            updateSwarmActivity(oldCount: oldValue.count, newCount: newValue.count)
            calculateHighlightPaths()
        }
        .onReceive(Timer.publish(every: 10, on: .main, in: .common).autoconnect()) { _ in
            simulateLiveActivity()
        }
    }
    private func startAnimations() {
        withAnimation(.easeInOut(duration: 2).repeatForever(autoreverses: true)) {
            glowAnimation = true
        }
        withAnimation(.easeIn(duration: 1)) {
            heatmapOpacity = 0.6
        }
        withAnimation(.easeInOut(duration: 1.5).repeatForever(autoreverses: true)) {
            liveActivityPulse = true
        }
        withAnimation(.linear(duration: 3).delay(0.5)) {
            pathAnimation = 1.0
        }
    }
    private func generateParticles() {
        let highlights = swarmManager.findOverlappingHighlights(in: text)
        for (_, highlight) in highlights.prefix(5) {
            if highlight.intensity > 0.5 {
                for _ in 0..<Int(highlight.intensity * 5) {
                    let particle = SwarmParticlePosition(
                        x: .random(in: 0...UIScreen.main.bounds.width),
                        y: .random(in: 0...UIScreen.main.bounds.height),
                        scale: .random(in: 0.5...1.5),
                        opacity: .random(in: 0.3...0.8)
                    )
                    particlePositions.append(particle)
                }
            }
        }
    }
    private func generateCosmicParticles() {
        for _ in 0..<20 {
            let particle = CosmicParticle(
                x: .random(in: -50...UIScreen.main.bounds.width + 50),
                y: .random(in: -50...UIScreen.main.bounds.height + 50),
                size: .random(in: 2...6),
                speed: .random(in: 10...30),
                angle: .random(in: 0...360)
            )
            cosmicParticles.append(particle)
        }
    }
    private func calculateHighlightPaths() {
        let highlights = swarmManager.findOverlappingHighlights(in: text)
        guard highlights.count > 1 else { return }
        highlightPath = Path { path in
            for i in 0..<highlights.count - 1 {
                let start = CGPoint(x: CGFloat(highlights[i].range.location) * 10, y: 50)
                let end = CGPoint(x: CGFloat(highlights[i + 1].range.location) * 10, y: 50)
                let control = CGPoint(
                    x: (start.x + end.x) / 2,
                    y: 50 - CGFloat.random(in: 20...50)
                )
                path.move(to: start)
                path.addQuadCurve(to: end, control: control)
            }
        }
    }
    private func animateNewHighlights(oldValue: [SwarmHighlight], newValue: [SwarmHighlight]) {
        let newIds = Set(newValue.map { $0.id })
        let oldIds = Set(oldValue.map { $0.id })
        let addedIds = newIds.subtracting(oldIds)
        for id in addedIds {
            newHighlightAnimation[id.uuidString] = false
            // Create ripple effect at highlight location
            if let highlight = newValue.first(where: { $0.id.uuidString == id.uuidString }) {
                let ripple = SwarmRippleEffect(
                    x: CGFloat(highlight.range.location) * 10,
                    y: 50
                )
                rippleEffects.append(ripple)
                // Remove ripple after animation
                DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                    rippleEffects.removeAll { $0.id == ripple.id }
                }
            }
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                withAnimation(.spring(response: 0.5, dampingFraction: 0.7)) {
                    newHighlightAnimation[id.uuidString] = true
                }
            }
        }
    }
    private func updateSwarmActivity(oldCount: Int, newCount: Int) {
        if newCount > oldCount {
            withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {
                swarmActivityLevel = min(1.0, swarmActivityLevel + 0.2)
            }
            // Decay activity over time
            DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                withAnimation(.easeOut(duration: 1)) {
                    swarmActivityLevel = max(0, swarmActivityLevel - 0.1)
                }
            }
            HapticManager.shared.impact(.light)
        }
    }
    private func simulateLiveActivity() {
        // Only show subtle activity hint when there's no real activity
        // This helps users understand the feature is working even with low activity
        let hasRealActivity = !swarmManager.swarmHighlights.isEmpty
        let shouldSimulate = !hasRealActivity && Bool.random(probability: 0.2) // 20% chance
        if shouldSimulate && swarmActivityLevel == 0 {
            withAnimation(.easeInOut(duration: 1.0)) {
                swarmActivityLevel = .random(in: 0.1...0.2) // Very subtle
            }
            DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
                withAnimation(.easeOut(duration: 1.5)) {
                    swarmActivityLevel = 0
                }
            }
            // Add subtle ripple effect
            let ripple = SwarmRippleEffect(
                x: .random(in: 100...300),
                y: .random(in: 100...400)
            )
            rippleEffects.append(ripple)
            // Remove ripple after animation
            DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {
                rippleEffects.removeAll { $0.id == ripple.id }
            }
        }
    }
}
// New Heatmap Visualization Component
struct SwarmHeatmapOverlay: View {
    let text: String
    let swarmHighlights: [(range: NSRange, highlight: SwarmHighlight)]
    let opacity: Double
    var body: some View {
        Canvas { context, size in
            guard !text.isEmpty else { return }
            for (range, highlight) in swarmHighlights {
                let intensity = highlight.intensity
                // Create gradient colors based on intensity
                let startColor = Color.orange.opacity(0.1 * intensity)
                let midColor = Color.orange.opacity(0.3 * intensity)
                let endColor = Color.orange.opacity(0.05 * intensity)
                // Create radial gradient
                let gradient = Gradient(colors: [midColor, startColor, endColor])
                let radialGradient = GraphicsContext.Shading.radialGradient(
                    gradient,
                    center: .zero,
                    startRadius: 5,
                    endRadius: 50 * intensity
                )
                // Draw gradient overlay (simplified positioning)
                let rect = CGRect(
                    x: CGFloat(range.location) * 10,
                    y: 20,
                    width: CGFloat(range.length) * 10,
                    height: 30
                )
                context.fill(
                    RoundedRectangle(cornerRadius: 15).path(in: rect),
                    with: radialGradient
                )
            }
        }
        .opacity(opacity)
        .blur(radius: 8)
        .blendMode(.plusLighter)
    }
}
// Particle Effect Component
struct SwarmParticlePosition: Identifiable {
    let id = UUID()
    var x: CGFloat
    var y: CGFloat
    var scale: CGFloat
    var opacity: Double
}
struct ParticleView: View {
    let particle: SwarmParticlePosition
    @State private var offset: CGSize = .zero
    @State private var rotation: Double = 0
    var body: some View {
        Circle()
            .fill(
                RadialGradient(
                    colors: [
                        Color.orange.opacity(particle.opacity),
                        Color.orange.opacity(0)
                    ],
                    center: UnitPoint.center,
                    startRadius: 0,
                    endRadius: 5
                )
            )
            .frame(width: 10 * particle.scale, height: 10 * particle.scale)
            .position(x: particle.x + offset.width, y: particle.y + offset.height)
            .rotationEffect(.degrees(rotation))
            .onAppear {
                withAnimation(
                    .easeInOut(duration: .random(in: 3...6))
                    .repeatForever(autoreverses: true)
                ) {
                    offset = CGSize(
                        width: .random(in: -30...30),
                        height: .random(in: -50...50)
                    )
                    rotation = .random(in: -180...180)
                }
            }
    }
}
struct SwarmTextView: UIViewRepresentable {
    let text: String
    let swarmHighlights: [(range: NSRange, highlight: SwarmHighlight)]
    @Binding var selectedHighlight: SwarmHighlight?
    @Binding var popoverPosition: CGPoint
    let geometry: GeometryProxy
    @Binding var newHighlightAnimation: [String: Bool]
    func makeUIView(context: Context) -> UITextView {
        let textView = UITextView()
        textView.isEditable = false
        textView.isSelectable = true
        textView.backgroundColor = .clear
        textView.textContainerInset = UIEdgeInsets(top: 20, left: 20, bottom: 20, right: 20)
        textView.delegate = context.coordinator
        return textView
    }
    func updateUIView(_ textView: UITextView, context: Context) {
        let attributedString = NSMutableAttributedString(string: text)
        // Base text styling with improved typography
        let paragraphStyle = NSMutableParagraphStyle()
        paragraphStyle.lineSpacing = 10
        paragraphStyle.paragraphSpacing = 20
        paragraphStyle.lineBreakMode = .byWordWrapping
        attributedString.addAttributes([
            .font: UIFont.systemFont(ofSize: 17, weight: .regular),
            .foregroundColor: UIColor.label,
            .paragraphStyle: paragraphStyle,
            .kern: 0.2
        ], range: NSRange(location: 0, length: text.count))
        // Apply swarm highlights with advanced visual effects
        for (range, highlight) in swarmHighlights {
            let intensity = highlight.intensity
            let isNewHighlight = newHighlightAnimation[highlight.id.uuidString] ?? false
            // Dynamic color based on intensity and animation state
            let baseAlpha = isNewHighlight ? 0.8 : 0.3
            let underlineColor = UIColor.systemOrange.withAlphaComponent(baseAlpha + (intensity * 0.7))
            // Multi-layer background effect
            let backgroundAlpha = isNewHighlight ? 0.2 : 0.05
            let backgroundColor = UIColor.systemOrange.withAlphaComponent(backgroundAlpha + (intensity * 0.15))
            // Apply attributes with animation consideration
            var attributes: [NSAttributedString.Key: Any] = [
                .backgroundColor: backgroundColor,
                .underlineStyle: NSUnderlineStyle.thick.rawValue,
                .underlineColor: underlineColor
            ]
            // Add glow effect for high-intensity highlights
            if intensity > 0.7 {
                attributes[.strokeWidth] = -1.0
                attributes[.strokeColor] = UIColor.systemOrange.withAlphaComponent(intensity * 0.5)
            }
            // Add shadow for new highlights
            if isNewHighlight {
                let shadow = NSShadow()
                shadow.shadowColor = UIColor.systemOrange.withAlphaComponent(0.5)
                shadow.shadowBlurRadius = 8
                shadow.shadowOffset = CGSize(width: 0, height: 2)
                attributes[.shadow] = shadow
            }
            attributedString.addAttributes(attributes, range: range)
        }
        textView.attributedText = attributedString
        context.coordinator.parent = self
        context.coordinator.highlights = swarmHighlights
        // Animate text view content changes
        if !newHighlightAnimation.isEmpty {
            UIView.animate(withDuration: 0.3) {
                textView.alpha = 0.95
            } completion: { _ in
                UIView.animate(withDuration: 0.2) {
                    textView.alpha = 1.0
                }
            }
        }
    }
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    class Coordinator: NSObject, UITextViewDelegate {
        var parent: SwarmTextView
        var highlights: [(range: NSRange, highlight: SwarmHighlight)] = []
        init(_ parent: SwarmTextView) {
            self.parent = parent
        }
        func textView(_ textView: UITextView, shouldInteractWith URL: URL, in characterRange: NSRange, interaction: UITextItemInteraction) -> Bool {
            // Check if tap is on a highlight
            if let tappedHighlight = highlights.first(where: { NSLocationInRange(characterRange.location, $0.range) }) {
                // Calculate popover position
                if let position = textView.position(from: textView.beginningOfDocument, offset: characterRange.location) {
                    let rect = textView.caretRect(for: position)
                    let globalRect = textView.convert(rect, to: nil)
                    DispatchQueue.main.async {
                        self.parent.selectedHighlight = tappedHighlight.highlight
                        self.parent.popoverPosition = CGPoint(
                            x: globalRect.midX,
                            y: globalRect.minY - 10
                        )
                        HapticManager.shared.impact(.light)
                    }
                }
            }
            return false
        }
    }
}
struct SwarmPopover: View {
    let highlight: SwarmHighlight
    let position: CGPoint
    let onDismiss: () -> Void
    @State private var isExpanded = false
    @State private var glowIntensity: Double = 0.5
    @State private var pulseScale: CGFloat = 1.0
    @State private var rotationAngle: Double = 0
    @State private var cardFlipRotation: Double = 0
    @State private var showBackSide = false
    @State private var floatingOffset: CGFloat = 0
    @Environment(\.colorScheme) var colorScheme
    var body: some View {
        ZStack {
            // Front side of card
            if !showBackSide {
                VStack(spacing: 0) {
                    // Header with stats
                    popoverHeader
                    // Expanded details with staggered animation
                    if isExpanded {
                        expandedContent
                    }
                }
                .frame(maxWidth: 360)
                .background(popoverBackground)
                .overlay(animatedBorderGlow)
                .rotation3DEffect(
                    .degrees(cardFlipRotation),
                    axis: (x: 0, y: 1, z: 0),
                    perspective: 1
                )
            }
            // Back side of card (detailed analytics)
            if showBackSide {
                SwarmAnalyticsView(highlight: highlight)
                    .frame(maxWidth: 360)
                    .background(popoverBackground)
                    .overlay(animatedBorderGlow)
                    .rotation3DEffect(
                        .degrees(cardFlipRotation + 180),
                        axis: (x: 0, y: 1, z: 0),
                        perspective: 1
                    )
            }
        }
        .scaleEffect(pulseScale)
        .offset(y: floatingOffset)
        .position(x: position.x, y: position.y)
        .onAppear {
            startAnimations()
        }
        .onTapGesture(count: 2) {
            // Double tap to flip card
            flipCard()
        }
        .onTapGesture {
            // Single tap does nothing (prevent dismissal)
        }
        .simultaneousGesture(
            DragGesture(minimumDistance: 30)
                .onEnded { _ in
                    HapticManager.shared.impact(.light)
                    withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                        onDismiss()
                    }
                }
        )
    }
    private func flipCard() {
        HapticManager.shared.impact(.medium)
        withAnimation(.spring(response: 0.6, dampingFraction: 0.8)) {
            cardFlipRotation += 180
            showBackSide.toggle()
        }
    }
    @ViewBuilder
    private var popoverHeader: some View {
        HStack {
            VStack(alignment: .leading, spacing: 6) {
                // Stats with animated counters
                statsView
                // Quoted text
                Text("\"\(highlight.text)\"")
                    .font(.footnote.italic())
                    .foregroundColor(.secondary)
                    .lineLimit(2)
                    .fixedSize(horizontal: false, vertical: true)
                    .opacity(0.9)
            }
            Spacer()
            // Animated expand button
            expandButton
        }
        .padding(16)
        .background(headerBackground)
    }
    @ViewBuilder
    private var statsView: some View {
        HStack(spacing: 10) {
            HStack(spacing: 4) {
                Image(systemName: "person.2.fill")
                    .font(.caption)
                    .foregroundColor(.orange)
                    .symbolEffect(.pulse, value: pulseScale)
                AnimatedCounter(value: highlight.totalHighlighters, suffix: " highlighters")
                    .font(.caption.weight(.medium))
            }
            if highlight.totalZaps > 0 {
                HStack(spacing: 4) {
                    Image(systemName: "bolt.fill")
                        .font(.caption)
                        .foregroundColor(.orange)
                        .symbolEffect(.bounce, value: pulseScale)
                    AnimatedCounter(value: highlight.totalZaps, suffix: " zaps")
                        .font(.caption.weight(.medium))
                }
            }
        }
    }
    @ViewBuilder
    private var expandButton: some View {
        Button(action: {
            HapticManager.shared.impact(.light)
            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                isExpanded.toggle()
                rotationAngle += 180
            }
        }) {
            ZStack {
                Circle()
                    .fill(Color.orange.opacity(0.1))
                    .frame(width: 36, height: 36)
                Image(systemName: "chevron.down")
                    .font(.system(size: 14, weight: .bold))
                    .foregroundColor(.orange)
                    .rotationEffect(.degrees(isExpanded ? 180 : 0))
            }
        }
        .scaleEffect(pulseScale)
    }
    @ViewBuilder
    private var headerBackground: some View {
        ZStack {
            // Gradient background
            LinearGradient(
                colors: [
                    colorScheme == .dark ? Color.black : Color.white,
                    colorScheme == .dark ? Color.black.opacity(0.8) : Color.white.opacity(0.95)
                ],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            // Intensity-based glow
            RadialGradient(
                colors: [
                    Color.orange.opacity(highlight.intensity * 0.2),
                    Color.clear
                ],
                center: .center,
                startRadius: 0,
                endRadius: 100
            )
            .opacity(glowIntensity)
        }
        .clipShape(RoundedRectangle(cornerRadius: 16))
        .overlay(
            RoundedRectangle(cornerRadius: 16)
                .strokeBorder(
                    LinearGradient(
                        colors: [
                            Color.orange.opacity(0.5),
                            Color.orange.opacity(0.2)
                        ],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    ),
                    lineWidth: 2
                )
        )
    }
    @ViewBuilder
    private var expandedContent: some View {
        VStack(spacing: 8) {
            ForEach(Array(highlight.highlights.enumerated()), id: \.element.id) { index, info in
                SwarmHighlightRow(info: info)
                    .transition(
                        .asymmetric(
                            insertion: .push(from: .trailing)
                                .combined(with: .opacity)
                                .animation(.spring(response: 0.4, dampingFraction: 0.8).delay(Double(index) * 0.05)),
                            removal: .scale(scale: 0.8).combined(with: .opacity)
                        )
                    )
            }
        }
        .padding(.horizontal, 12)
        .padding(.bottom, 12)
    }
    @ViewBuilder
    private var popoverBackground: some View {
        ZStack {
            // Main background
            RoundedRectangle(cornerRadius: 20)
                .fill(colorScheme == .dark ? Color.black.opacity(0.95) : Color.white.opacity(0.98))
            // Animated shadow layers
            ForEach(0..<3) { i in
                RoundedRectangle(cornerRadius: 20)
                    .fill(Color.clear)
                    .shadow(
                        color: Color.orange.opacity(0.2 - Double(i) * 0.05),
                        radius: 10 + CGFloat(i) * 10,
                        x: 0,
                        y: 5 + CGFloat(i) * 5
                    )
                    .opacity(glowIntensity)
            }
        }
    }
    @ViewBuilder
    private var animatedBorderGlow: some View {
        RoundedRectangle(cornerRadius: 20)
            .stroke(
                AngularGradient(
                    colors: [
                        Color.orange.opacity(0.6),
                        Color.orange.opacity(0.2),
                        Color.orange.opacity(0.6)
                    ],
                    center: .center,
                    angle: .degrees(rotationAngle)
                ),
                lineWidth: 2
            )
            .blur(radius: 2)
    }
    private func startAnimations() {
        // Glow animation
        withAnimation(.easeInOut(duration: 2).repeatForever(autoreverses: true)) {
            glowIntensity = 0.8
        }
        // Subtle pulse
        withAnimation(.easeInOut(duration: 1.5).repeatForever(autoreverses: true)) {
            pulseScale = 1.02
        }
        // Rotation for border gradient
        withAnimation(.linear(duration: 10).repeatForever(autoreverses: false)) {
            rotationAngle = 360
        }
        // Floating animation
        withAnimation(.easeInOut(duration: 2).repeatForever(autoreverses: true)) {
            floatingOffset = -10
        }
    }
}
// Animated counter component
struct AnimatedCounter: View {
    let value: Int
    let suffix: String
    @State private var displayValue: Int = 0
    var body: some View {
        Text("\(displayValue)\(suffix)")
            .onAppear {
                withAnimation(.easeOut(duration: 0.8)) {
                    displayValue = value
                }
            }
            .onChange(of: value) { _, newValue in
                withAnimation(.easeOut(duration: 0.5)) {
                    displayValue = newValue
                }
            }
    }
}
struct SwarmHighlightRow: View {
    let info: SwarmHighlight.HighlightInfo
    @State private var showZapAnimation = false
    @State private var isHovered = false
    @State private var zapParticles: [SwarmZapParticle] = []
    @Environment(\.colorScheme) var colorScheme
    @EnvironmentObject var appState: AppState
    var body: some View {
        HStack(alignment: .top, spacing: 12) {
            // Enhanced Avatar with glow effect
            ZStack {
                // Glow ring for high zappers
                if info.zapCount > 10 {
                    Circle()
                        .stroke(
                            LinearGradient(
                                colors: [Color.orange, Color.orange.opacity(0.3)],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ),
                            lineWidth: 2
                        )
                        .frame(width: 36, height: 36)
                        .blur(radius: 2)
                        .opacity(isHovered ? 1 : 0.5)
                }
                Group {
                    if let picture = info.profile?.picture {
                        AsyncImage(url: URL(string: picture)) { image in
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                        } placeholder: {
                            Circle()
                                .fill(
                                    LinearGradient(
                                        colors: [Color.orange.opacity(0.3), Color.orange.opacity(0.1)],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                        }
                    } else {
                        Circle()
                            .fill(
                                LinearGradient(
                                    colors: [Color.orange.opacity(0.3), Color.orange.opacity(0.1)],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .overlay(
                                Text(String(info.profile?.name?.first ?? "?"))
                                    .font(.caption.weight(.bold))
                                    .foregroundColor(.orange)
                            )
                    }
                }
                .frame(width: 32, height: 32)
                .clipShape(Circle())
                .overlay(
                    Circle()
                        .stroke(Color.orange.opacity(0.2), lineWidth: 1)
                )
                .scaleEffect(isHovered ? 1.1 : 1.0)
            }
            // Enhanced Content
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(info.profile?.displayName ?? info.profile?.name ?? "Anonymous")
                        .font(.footnote.weight(.semibold))
                        .foregroundColor(isHovered ? .orange : .primary)
                    Spacer()
                    // Enhanced zap counter with live animation
                    if info.zapCount > 0 {
                        HStack(spacing: 3) {
                            Image(systemName: "bolt.fill")
                                .font(.caption2)
                                .foregroundColor(.orange)
                                .symbolEffect(.bounce, value: info.zapCount)
                            Text("\(info.zapCount)")
                                .font(.caption2.monospacedDigit())
                                .foregroundColor(.orange)
                        }
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(
                            Capsule()
                                .fill(Color.orange.opacity(0.1))
                        )
                    }
                    Text(info.createdAt.formatted(.relative(presentation: .named)))
                        .font(.caption2)
                        .foregroundColor(.secondary)
                }
                if let note = info.note {
                    Text(note)
                        .font(.caption)
                        .foregroundColor(.secondary)
                        .lineLimit(isHovered ? 4 : 2)
                        .fixedSize(horizontal: false, vertical: true)
                        .animation(.easeInOut(duration: 0.2), value: isHovered)
                }
            }
            // Enhanced Zap button with particle effects
            ZStack {
                // Particle effects
                ForEach(zapParticles) { particle in
                    SwarmZapParticleView(particle: particle)
                }
                Button(action: {
                    performZap()
                }) {
                    ZStack {
                        // Background glow
                        Circle()
                            .fill(
                                RadialGradient(
                                    colors: [
                                        Color.orange.opacity(showZapAnimation ? 0.3 : 0.1),
                                        Color.clear
                                    ],
                                    center: .center,
                                    startRadius: 0,
                                    endRadius: 20
                                )
                            )
                            .frame(width: 40, height: 40)
                            .blur(radius: showZapAnimation ? 3 : 1)
                        Image(systemName: showZapAnimation ? "bolt.circle.fill" : "bolt.circle")
                            .font(.title3)
                            .foregroundStyle(
                                showZapAnimation ?
                                    AnyShapeStyle(LinearGradient(
                                        colors: [.orange, .yellow],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )) :
                                    AnyShapeStyle(Color.orange)
                            )
                            .scaleEffect(showZapAnimation ? 1.3 : 1.0)
                            .rotationEffect(.degrees(showZapAnimation ? 360 : 0))
                    }
                }
                .buttonStyle(.plain)
            }
        }
        .padding(.vertical, 10)
        .padding(.horizontal, 12)
        .background(
            ZStack {
                // Base background
                RoundedRectangle(cornerRadius: 12)
                    .fill(
                        colorScheme == .dark ?
                            Color.white.opacity(isHovered ? 0.08 : 0.04) :
                            Color.black.opacity(isHovered ? 0.04 : 0.02)
                    )
                // Hover glow
                if isHovered {
                    RoundedRectangle(cornerRadius: 12)
                        .stroke(
                            LinearGradient(
                                colors: [Color.orange.opacity(0.3), Color.orange.opacity(0.1)],
                                startPoint: .leading,
                                endPoint: .trailing
                            ),
                            lineWidth: 1
                        )
                        .blur(radius: 1)
                }
            }
        )
        .onHover { hovering in
            withAnimation(.easeInOut(duration: 0.2)) {
                isHovered = hovering
            }
        }
    }
    private func performZap() {
        HapticManager.shared.impact(.medium)
        // Create particle burst
        for i in 0..<8 {
            let angle = Double(i) * (360.0 / 8.0)
            let particle = SwarmZapParticle(
                angle: angle,
                distance: CGFloat.random(in: 30...60),
                duration: Double.random(in: 0.6...1.0)
            )
            zapParticles.append(particle)
        }
        withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {
            showZapAnimation = true
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            showZapAnimation = false
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            zapParticles.removeAll()
        }
        // Send actual zap
        Task {
            do {
                if appState.lightningService.isConnected {
                    try await appState.lightningService.sendSimpleZap(
                        amount: 21, // Default zap amount
                        to: info.author.pubkey,
                        comment: "⚡ Zapped via Highlighter"
                    )
                } else {
                    // Show wallet connection UI if not connected
                }
            } catch {
                HapticManager.shared.notification(.error)
            }
        }
    }
}
// Local particle type for swarm view to avoid conflict
struct SwarmZapParticle: Identifiable {
    let id = UUID()
    let angle: Double
    let distance: CGFloat
    let duration: Double
}
struct SwarmZapParticleView: View {
    let particle: SwarmZapParticle
    @State private var offset: CGSize = .zero
    @State private var opacity: Double = 1
    var body: some View {
        Image(systemName: "bolt.fill")
            .font(.caption2)
            .foregroundColor(.orange)
            .offset(offset)
            .opacity(opacity)
            .onAppear {
                let radians = particle.angle * .pi / 180
                let x = cos(radians) * particle.distance
                let y = sin(radians) * particle.distance
                withAnimation(.easeOut(duration: particle.duration)) {
                    offset = CGSize(width: x, height: y)
                    opacity = 0
                }
            }
    }
}
// MARK: - New Components for Enhanced Swarm Experience
// Cosmic background with floating particles
struct CosmicBackgroundView: View {
    let particles: [CosmicParticle]
    let activityLevel: Double
    @State private var animationProgress: CGFloat = 0
    var body: some View {
        TimelineView(.animation) { timeline in
            Canvas { context, size in
                let time = timeline.date.timeIntervalSinceReferenceDate
                for particle in particles {
                    let x = particle.x + cos(particle.angle * .pi / 180) * particle.speed * CGFloat(time.truncatingRemainder(dividingBy: 20))
                    let y = particle.y + sin(particle.angle * .pi / 180) * particle.speed * CGFloat(time.truncatingRemainder(dividingBy: 20))
                    let wrappedX = x.truncatingRemainder(dividingBy: size.width + 100) - 50
                    let wrappedY = y.truncatingRemainder(dividingBy: size.height + 100) - 50
                    context.fill(
                        Circle().path(in: CGRect(
                            x: wrappedX - particle.size/2,
                            y: wrappedY - particle.size/2,
                            width: particle.size,
                            height: particle.size
                        )),
                        with: .radialGradient(
                            Gradient(colors: [
                                Color.orange.opacity(0.3 + activityLevel * 0.4),
                                Color.orange.opacity(0)
                            ]),
                            center: .zero,
                            startRadius: 0,
                            endRadius: particle.size
                        )
                    )
                }
            }
        }
    }
}
// Live activity indicator showing real-time swarm engagement
struct LiveSwarmActivityIndicator: View {
    let activityLevel: Double
    let isPulsing: Bool
    @State private var rotationAngle: Double = 0
    @State private var ringExpansion: CGFloat = 1
    var body: some View {
        ZStack {
            // Outer pulsing ring
            Circle()
                .stroke(
                    AngularGradient(
                        colors: [
                            .orange.opacity(activityLevel),
                            .orange.opacity(activityLevel * 0.3),
                            .orange.opacity(activityLevel)
                        ],
                        center: .center,
                        angle: .degrees(rotationAngle)
                    ),
                    lineWidth: 3
                )
                .frame(width: 50 * ringExpansion, height: 50 * ringExpansion)
                .blur(radius: isPulsing ? 2 : 0)
            // Inner activity dots
            ForEach(0..<8) { index in
                Circle()
                    .fill(Color.orange)
                    .frame(width: 4, height: 4)
                    .offset(x: 15)
                    .rotationEffect(.degrees(Double(index) * 45 + rotationAngle))
                    .opacity(activityLevel > Double(index) / 8 ? 1 : 0.3)
                    .scaleEffect(isPulsing && activityLevel > Double(index) / 8 ? 1.2 : 1)
            }
        }
        .onAppear {
            withAnimation(.linear(duration: 2).repeatForever(autoreverses: false)) {
                rotationAngle = 360
            }
            withAnimation(.easeInOut(duration: 1).repeatForever(autoreverses: true)) {
                ringExpansion = 1.2
            }
        }
    }
}
// Ripple effect for new highlights
struct SwarmRippleEffect: Identifiable {
    let id = UUID()
    let x: CGFloat
    let y: CGFloat
}
struct SwarmRippleEffectView: View {
    let ripple: SwarmRippleEffect
    @State private var scale: CGFloat = 0.5
    @State private var opacity: Double = 1
    var body: some View {
        Circle()
            .stroke(
                LinearGradient(
                    colors: [.orange, .orange.opacity(0.5)],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                ),
                lineWidth: 2
            )
            .frame(width: 50 * scale, height: 50 * scale)
            .opacity(opacity)
            .position(x: ripple.x, y: ripple.y)
            .onAppear {
                withAnimation(.easeOut(duration: 2)) {
                    scale = 4
                    opacity = 0
                }
            }
    }
}
// Cosmic particle model
struct CosmicParticle: Identifiable {
    let id = UUID()
    let x: CGFloat
    let y: CGFloat
    let size: CGFloat
    let speed: CGFloat
    let angle: Double
}
// Enhanced swarm popover with 3D card flip
extension SwarmPopover {
    struct CardFlip3D: ViewModifier {
        let rotation: Double
        let axis: (x: CGFloat, y: CGFloat, z: CGFloat)
        func body(content: Content) -> some View {
            content
                .rotation3DEffect(
                    .degrees(rotation),
                    axis: axis,
                    anchor: .center,
                    anchorZ: 0,
                    perspective: 1
                )
        }
    }
}
// Analytics view for the back of the card
struct SwarmAnalyticsView: View {
    let highlight: SwarmHighlight
    @State private var chartAnimation: CGFloat = 0
    @State private var numberAnimation: Double = 0
    @Environment(\.colorScheme) var colorScheme
    var body: some View {
        VStack(spacing: 20) {
            // Header
            HStack {
                Image(systemName: "chart.line.uptrend.xyaxis")
                    .font(.title2)
                    .foregroundColor(.orange)
                    .symbolEffect(.pulse)
                Text("Swarm Analytics")
                    .font(.headline)
                    .foregroundColor(.primary)
                Spacer()
            }
            .padding()
            // Engagement metrics
            VStack(spacing: 16) {
                // Intensity meter
                IntensityMeterView(
                    intensity: highlight.intensity,
                    animation: chartAnimation
                )
                // Stats grid
                LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())], spacing: 16) {
                    StatCard(
                        icon: "person.2.fill",
                        value: Int(Double(highlight.totalHighlighters) * numberAnimation),
                        label: "Highlighters",
                        color: .orange
                    )
                    StatCard(
                        icon: "bolt.fill",
                        value: Int(Double(highlight.totalZaps) * numberAnimation),
                        label: "Total Zaps",
                        color: .yellow
                    )
                    StatCard(
                        icon: "clock.fill",
                        value: highlight.highlights.count,
                        label: "Time Periods",
                        color: .blue
                    )
                    StatCard(
                        icon: "chart.bar.fill",
                        value: Int(highlight.intensity * 100),
                        label: "Intensity %",
                        color: .purple
                    )
                }
                // Activity timeline
                ActivityTimelineView(highlights: highlight.highlights)
                    .opacity(chartAnimation)
            }
            .padding()
        }
        .onAppear {
            withAnimation(.easeOut(duration: 0.8)) {
                chartAnimation = 1
                numberAnimation = 1
            }
        }
    }
}
// Intensity meter component
struct IntensityMeterView: View {
    let intensity: Double
    let animation: CGFloat
    var body: some View {
        VStack(spacing: 8) {
            Text("Community Intensity")
                .font(.caption)
                .foregroundColor(.secondary)
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    // Background
                    Capsule()
                        .fill(Color.gray.opacity(0.2))
                        .frame(height: 20)
                    // Intensity bar
                    Capsule()
                        .fill(
                            LinearGradient(
                                colors: [.yellow, .orange, .red],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .frame(width: geometry.size.width * intensity * animation, height: 20)
                    // Glow effect
                    Capsule()
                        .fill(
                            LinearGradient(
                                colors: [.orange.opacity(0.6), .clear],
                                startPoint: .center,
                                endPoint: .trailing
                            )
                        )
                        .frame(width: geometry.size.width * intensity * animation, height: 20)
                        .blur(radius: 4)
                }
            }
            .frame(height: 20)
        }
    }
}
// Stat card component
struct StatCard: View {
    let icon: String
    let value: Int
    let label: String
    let color: Color
    @State private var scaleEffect: CGFloat = 0.8
    var body: some View {
        VStack(spacing: 8) {
            Image(systemName: icon)
                .font(.title2)
                .foregroundColor(color)
                .scaleEffect(scaleEffect)
            Text("\(value)")
                .font(.title3.bold().monospacedDigit())
                .foregroundColor(.primary)
            Text(label)
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(color.opacity(0.1))
                .overlay(
                    RoundedRectangle(cornerRadius: 12)
                        .stroke(color.opacity(0.3), lineWidth: 1)
                )
        )
        .onAppear {
            withAnimation(.spring(response: 0.5, dampingFraction: 0.6)) {
                scaleEffect = 1
            }
        }
    }
}
// Activity timeline view
struct ActivityTimelineView: View {
    let highlights: [SwarmHighlight.HighlightInfo]
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("Activity Timeline")
                .font(.caption)
                .foregroundColor(.secondary)
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 12) {
                    ForEach(highlights.prefix(10), id: \.id) { info in
                        VStack(spacing: 4) {
                            Circle()
                                .fill(Color.orange)
                                .frame(width: 8, height: 8)
                            Text(info.createdAt.formatted(.dateTime.hour().minute()))
                                .font(.system(size: 8))
                                .foregroundColor(.secondary)
                        }
                    }
                }
            }
        }
    }
}
</file>

<file path="Sources/Highlighter/Views/Highlights/TextSelectionView.swift">
import SwiftUI
import UIKit
import NDKSwift
struct TextSelectionView: View {
    let content: String
    let source: String?
    let author: String?
    @State private var selectedRange: NSRange?
    @State private var highlightCreationMode = false
    @State private var selectedText = ""
    @State private var contextBefore = ""
    @State private var contextAfter = ""
    @State private var showHighlightEditor = false
    @State private var selectionRect: CGRect = .zero
    @State private var highlightAnimation = false
    @State private var ripplePositions: [RipplePosition] = []
    @State private var selectionPulse = false
    @State private var buttonScale: CGFloat = 1.0
    @State private var selectionGlow: Double = 0
    @State private var showSelectionHint = false
    @State private var hintOpacity: Double = 1.0
    @Environment(\.dismiss) var dismiss
    @StateObject private var publishingService = PublishingService.shared
    private let selectionFeedback = UISelectionFeedbackGenerator()
    private let impactFeedback = UIImpactFeedbackGenerator(style: .medium)
    var body: some View {
        ZStack {
            // Background with gradient
            LinearGradient(
                colors: [
                    Color(uiColor: .systemBackground),
                    Color(uiColor: .systemBackground).opacity(0.95)
                ],
                startPoint: .top,
                endPoint: .bottom
            )
            .ignoresSafeArea()
            // Main content
            VStack(spacing: 0) {
                // Header
                header
                // Selectable text content
                SelectableTextView(
                    text: content,
                    selectedRange: $selectedRange,
                    selectionRect: $selectionRect,
                    onSelectionChange: handleSelectionChange
                )
                .overlay(alignment: .topLeading) {
                    // Selection highlight overlay
                    if highlightCreationMode && !selectionRect.isEmpty {
                        selectionOverlay
                    }
                }
                .overlay {
                    // Ripple effects
                    ForEach(ripplePositions) { ripple in
                        RippleEffectView(position: ripple.position)
                            .allowsHitTesting(false)
                    }
                }
            }
        }
        .sheet(isPresented: $showHighlightEditor) {
            HighlightEditorView(
                selectedText: selectedText,
                contextBefore: contextBefore,
                contextAfter: contextAfter,
                source: source,
                author: author,
                onPublish: publishHighlight
            )
        }
    }
    private var header: some View {
        VStack(spacing: 8) {
            HStack {
                Button("Cancel") {
                    dismiss()
                }
                .foregroundColor(.secondary)
                Spacer()
                Text("Select Text to Highlight")
                    .font(.headline)
                    .foregroundColor(.primary)
                Spacer()
                // Placeholder for balance
                Text("Cancel")
                    .foregroundColor(.clear)
            }
            .padding()
            if let source = source {
                Text(source)
                    .font(.footnote)
                    .foregroundColor(.secondary)
                    .padding(.horizontal)
            }
            Divider()
        }
        .background(.ultraThinMaterial)
    }
    private var selectionOverlay: some View {
        GeometryReader { geometry in
            ZStack {
                // Enhanced glowing selection rectangle with pulse
                RoundedRectangle(cornerRadius: 8)
                    .fill(
                        LinearGradient(
                            colors: [
                                Color.orange.opacity(0.25),
                                Color.orange.opacity(0.15)
                            ],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: selectionRect.width, height: selectionRect.height)
                    .position(x: selectionRect.midX, y: selectionRect.midY)
                    .overlay(
                        RoundedRectangle(cornerRadius: 8)
                            .strokeBorder(
                                LinearGradient(
                                    colors: [Color.orange, Color.orange.opacity(0.5)],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                ),
                                lineWidth: selectionPulse ? 3 : 2
                            )
                            .frame(width: selectionRect.width, height: selectionRect.height)
                            .position(x: selectionRect.midX, y: selectionRect.midY)
                    )
                    .scaleEffect(highlightAnimation ? 1.02 : 1.0)
                    .shadow(color: Color.orange.opacity(selectionGlow), radius: highlightAnimation ? 20 : 10)
                    .blur(radius: selectionPulse ? 0.5 : 0)
                // Selection handles at corners
                Group {
                    SelectionHandle()
                        .position(x: selectionRect.minX, y: selectionRect.minY)
                        .opacity(highlightAnimation ? 1 : 0)
                        .scaleEffect(selectionPulse ? 1.2 : 1.0)
                    SelectionHandle()
                        .position(x: selectionRect.maxX, y: selectionRect.maxY)
                        .opacity(highlightAnimation ? 1 : 0)
                        .scaleEffect(selectionPulse ? 1.2 : 1.0)
                }
                // Action buttons
                if !selectedText.isEmpty {
                    VStack(spacing: 8) {
                        Spacer()
                        HStack(spacing: 16) {
                            // Create highlight button with enhanced animation
                            Button(action: {
                                impactFeedback.impactOccurred()
                                withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {
                                    buttonScale = 0.9
                                }
                                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                                    withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {
                                        buttonScale = 1.0
                                    }
                                    createHighlight()
                                }
                            }) {
                                Label("Create Highlight", systemImage: "highlighter")
                                    .font(.system(size: 14, weight: .semibold))
                                    .foregroundColor(.white)
                                    .padding(.horizontal, 16)
                                    .padding(.vertical, 10)
                                    .background(
                                        LinearGradient(
                                            colors: [Color.orange, Color.orange.opacity(0.8)],
                                            startPoint: .leading,
                                            endPoint: .trailing
                                        )
                                    )
                                    .clipShape(Capsule())
                                    .shadow(color: Color.orange.opacity(0.4), radius: 8, y: 4)
                            }
                            .scaleEffect(buttonScale * (highlightAnimation ? 1.05 : 1.0))
                            // Copy button
                            Button(action: {
                                UIPasteboard.general.string = selectedText
                                HapticManager.shared.notification(.success)
                            }) {
                                Image(systemName: "doc.on.doc")
                                    .font(.system(size: 16, weight: .medium))
                                    .foregroundColor(.white)
                                    .frame(width: 40, height: 40)
                                    .background(Circle().fill(Color.secondary.opacity(0.8)))
                            }
                        }
                        .position(x: selectionRect.midX, y: selectionRect.maxY + 50)
                    }
                }
            }
            .animation(.spring(response: 0.3, dampingFraction: 0.7), value: highlightAnimation)
        }
    }
    private func handleSelectionChange(range: NSRange?, text: String) {
        selectedRange = range
        selectedText = text
        if let range = range, !text.isEmpty {
            // Haptic feedback on selection
            selectionFeedback.selectionChanged()
            highlightCreationMode = true
            extractContext(for: range)
            // Start multiple coordinated animations
            withAnimation(.easeInOut(duration: 0.3)) {
                highlightAnimation = true
                selectionGlow = 0.4
            }
            // Pulse animation
            withAnimation(.easeInOut(duration: 0.6).repeatCount(2, autoreverses: true)) {
                selectionPulse = true
            }
            // Glow animation
            withAnimation(.easeInOut(duration: 1.0).delay(0.3)) {
                selectionGlow = 0.6
            }
            // Add ripple effect at selection
            if !selectionRect.isEmpty {
                let ripple = RipplePosition(
                    id: UUID(),
                    position: CGPoint(x: selectionRect.midX, y: selectionRect.midY)
                )
                ripplePositions.append(ripple)
                // Remove ripple after animation
                DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                    ripplePositions.removeAll { $0.id == ripple.id }
                }
            }
            HapticManager.shared.impact(.light)
        } else {
            highlightCreationMode = false
            highlightAnimation = false
        }
    }
    private func extractContext(for range: NSRange) {
        let nsString = content as NSString
        let contextLength = 100 // Characters of context to capture
        // Extract context before
        let beforeStart = max(0, range.location - contextLength)
        let beforeLength = range.location - beforeStart
        if beforeLength > 0 {
            contextBefore = nsString.substring(with: NSRange(location: beforeStart, length: beforeLength))
            // Find the last sentence boundary
            if let lastPeriod = contextBefore.lastIndex(of: ".") {
                contextBefore = String(contextBefore[contextBefore.index(after: lastPeriod)...]).trimmingCharacters(in: .whitespacesAndNewlines)
            }
        }
        // Extract context after
        let afterStart = range.location + range.length
        let afterLength = min(contextLength, nsString.length - afterStart)
        if afterLength > 0 {
            contextAfter = nsString.substring(with: NSRange(location: afterStart, length: afterLength))
            // Find the first sentence boundary
            if let firstPeriod = contextAfter.firstIndex(of: ".") {
                contextAfter = String(contextAfter[...firstPeriod])
            }
        }
    }
    private func createHighlight() {
        HapticManager.shared.impact(.medium)
        showHighlightEditor = true
    }
    private func publishHighlight(comment: String?) {
        Task {
            do {
                // Create highlight event
                let highlight = HighlightEvent(
                    content: selectedText,
                    context: contextBefore + " [...] " + contextAfter,
                    source: source,
                    author: author,
                    comment: comment
                )
                // Publish to Nostr
                try await publishingService.publishHighlight(highlight)
                HapticManager.shared.notification(.success)
                dismiss()
            } catch {
                HapticManager.shared.notification(.error)
                // Failed to publish highlight
            }
        }
    }
}
// Custom UITextView wrapper for text selection
struct SelectableTextView: UIViewRepresentable {
    let text: String
    @Binding var selectedRange: NSRange?
    @Binding var selectionRect: CGRect
    let onSelectionChange: (NSRange?, String) -> Void
    func makeUIView(context: Context) -> UITextView {
        let textView = UITextView()
        textView.isEditable = false
        textView.isSelectable = true
        textView.backgroundColor = .clear
        textView.textContainerInset = UIEdgeInsets(top: 20, left: 20, bottom: 20, right: 20)
        textView.delegate = context.coordinator
        // Configure text style
        let paragraphStyle = NSMutableParagraphStyle()
        paragraphStyle.lineSpacing = 8
        paragraphStyle.paragraphSpacing = 16
        let attributes: [NSAttributedString.Key: Any] = [
            .font: UIFont.systemFont(ofSize: 17, weight: .regular),
            .foregroundColor: UIColor.label,
            .paragraphStyle: paragraphStyle
        ]
        textView.attributedText = NSAttributedString(string: text, attributes: attributes)
        return textView
    }
    func updateUIView(_ uiView: UITextView, context: Context) {
        // Update selection if needed
    }
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    class Coordinator: NSObject, UITextViewDelegate {
        var parent: SelectableTextView
        init(_ parent: SelectableTextView) {
            self.parent = parent
        }
        func textViewDidChangeSelection(_ textView: UITextView) {
            guard let selectedRange = textView.selectedTextRange,
                  !selectedRange.isEmpty else {
                parent.selectedRange = nil
                parent.selectionRect = .zero
                parent.onSelectionChange(nil, "")
                return
            }
            let range = textView.selectedRange
            let selectedText = (textView.text as NSString).substring(with: range)
            // Calculate selection rect
            if let start = textView.position(from: textView.beginningOfDocument, offset: range.location),
               let end = textView.position(from: start, offset: range.length),
               let textRange = textView.textRange(from: start, to: end) {
                let selectionRects = textView.selectionRects(for: textRange)
                var unionRect = CGRect.zero
                for selectionRect in selectionRects {
                    if unionRect.isEmpty {
                        unionRect = selectionRect.rect
                    } else {
                        unionRect = unionRect.union(selectionRect.rect)
                    }
                }
                // Convert to view coordinates
                let convertedRect = textView.convert(unionRect, to: textView.superview)
                parent.selectionRect = convertedRect
            }
            parent.selectedRange = range
            parent.onSelectionChange(range, selectedText)
        }
    }
}
// Ripple effect for selection
struct RipplePosition: Identifiable {
    let id: UUID
    let position: CGPoint
}
struct RippleEffectView: View {
    let position: CGPoint
    @State private var scale: CGFloat = 0.5
    @State private var opacity: Double = 0.8
    var body: some View {
        Circle()
            .stroke(
                LinearGradient(
                    colors: [Color.orange, Color.orange.opacity(0.3)],
                    startPoint: .center,
                    endPoint: .trailing
                ),
                lineWidth: 2
            )
            .frame(width: 60, height: 60)
            .scaleEffect(scale)
            .opacity(opacity)
            .position(position)
            .onAppear {
                withAnimation(.easeOut(duration: 1.5)) {
                    scale = 3
                    opacity = 0
                }
            }
    }
}
// Highlight editor sheet
struct HighlightEditorView: View {
    let selectedText: String
    let contextBefore: String
    let contextAfter: String
    let source: String?
    let author: String?
    let onPublish: (String?) -> Void
    @State private var comment = ""
    @State private var isPrivate = false
    @State private var showPreview = true
    @Environment(\.dismiss) var dismiss
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(spacing: 24) {
                    // Preview section
                    if showPreview {
                        VStack(alignment: .leading, spacing: 12) {
                            Label("Preview", systemImage: "eye")
                                .font(.headline)
                                .foregroundColor(.secondary)
                            HighlightPreviewCard(
                                text: selectedText,
                                contextBefore: contextBefore,
                                contextAfter: contextAfter,
                                source: source,
                                author: author
                            )
                        }
                        .padding(.horizontal)
                    }
                    // Comment section
                    VStack(alignment: .leading, spacing: 12) {
                        Label("Add Your Thoughts (Optional)", systemImage: "bubble.left")
                            .font(.headline)
                            .foregroundColor(.secondary)
                        TextField("What makes this passage special?", text: $comment, axis: .vertical)
                            .textFieldStyle(.roundedBorder)
                            .lineLimit(3...6)
                    }
                    .padding(.horizontal)
                    // Privacy toggle
                    Toggle(isOn: $isPrivate) {
                        Label("Keep Private", systemImage: isPrivate ? "lock.fill" : "lock.open")
                            .font(.system(size: 16, weight: .medium))
                    }
                    .padding(.horizontal)
                    .tint(.orange)
                    Spacer(minLength: 40)
                    // Action buttons
                    VStack(spacing: 12) {
                        Button(action: {
                            onPublish(comment.isEmpty ? nil : comment)
                        }) {
                            HStack {
                                Image(systemName: "highlighter")
                                Text("Create Highlight")
                            }
                            .font(.system(size: 17, weight: .semibold))
                            .foregroundColor(.white)
                            .frame(maxWidth: .infinity)
                            .padding(.vertical, 16)
                            .background(
                                LinearGradient(
                                    colors: [Color.orange, Color.orange.opacity(0.9)],
                                    startPoint: .leading,
                                    endPoint: .trailing
                                )
                            )
                            .clipShape(RoundedRectangle(cornerRadius: 12))
                            .shadow(color: Color.orange.opacity(0.3), radius: 8, y: 4)
                        }
                        Button("Cancel") {
                            dismiss()
                        }
                        .font(.system(size: 16, weight: .medium))
                        .foregroundColor(.secondary)
                    }
                    .padding(.horizontal)
                }
                .padding(.vertical)
            }
            .navigationTitle("New Highlight")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        withAnimation {
                            showPreview.toggle()
                        }
                    }) {
                        Image(systemName: showPreview ? "eye.slash" : "eye")
                            .foregroundColor(.orange)
                    }
                }
            }
        }
    }
}
// Preview card component
struct HighlightPreviewCard: View {
    let text: String
    let contextBefore: String
    let contextAfter: String
    let source: String?
    let author: String?
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Context and highlighted text
            HStack(alignment: .top, spacing: 0) {
                Text(contextBefore + " ")
                    .foregroundColor(.secondary)
                    .font(.system(size: 15))
                Text(text)
                    .foregroundColor(.primary)
                    .font(.system(size: 15, weight: .semibold))
                    .underline(color: .orange)
                    .background(Color.orange.opacity(0.1))
                Text(" " + contextAfter)
                    .foregroundColor(.secondary)
                    .font(.system(size: 15))
            }
            Divider()
            // Source info
            HStack {
                if let author = author {
                    Label(author, systemImage: "person")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                if let source = source {
                    if author != nil {
                        Text("•")
                            .foregroundColor(.secondary)
                    }
                    Label(source, systemImage: "book")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
                Spacer()
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color(uiColor: .secondarySystemBackground))
        )
        .overlay(
            RoundedRectangle(cornerRadius: 16)
                .strokeBorder(Color.orange.opacity(0.3), lineWidth: 1)
        )
    }
}
#Preview {
    TextSelectionView(
        content: """
        The art of programming is the art of organizing complexity, of mastering multitude and avoiding its bastard chaos as effectively as possible.
        Programming is one of the most difficult branches of applied mathematics; the poorer mathematicians had better remain pure mathematicians.
        The competent programmer is fully aware of the strictly limited size of his own skull; therefore he approaches the programming task in full humility, and among other things he avoids clever tricks like the plague.
        """,
        source: "A Discipline of Programming",
        author: "Edsger W. Dijkstra"
    )
}
// MARK: - Supporting Components
// Selection handle component for enhanced visual feedback
struct SelectionHandle: View {
    var body: some View {
        ZStack {
            Circle()
                .fill(Color.orange)
                .frame(width: 16, height: 16)
                .overlay(
                    Circle()
                        .stroke(Color.white, lineWidth: 2)
                )
                .shadow(color: Color.orange.opacity(0.4), radius: 4, x: 0, y: 2)
            // Inner glow
            Circle()
                .fill(
                    RadialGradient(
                        colors: [Color.orange.opacity(0.6), Color.clear],
                        center: .center,
                        startRadius: 0,
                        endRadius: 8
                    )
                )
                .frame(width: 24, height: 24)
                .allowsHitTesting(false)
        }
    }
}
</file>

<file path="Sources/Highlighter/Views/Import/ImportComponents.swift">
import SwiftUI
import UniformTypeIdentifiers
import WebKit
// MARK: - Shared Import Types
enum HighlightImportance {
    case high, medium, low
    var color: Color {
        switch self {
        case .high: return .orange
        case .medium: return .yellow
        case .low: return .gray
        }
    }
    var icon: String {
        switch self {
        case .high: return "star.fill"
        case .medium: return "star.leadinghalf.filled"
        case .low: return "star"
        }
    }
}
struct SuggestedHighlight: Identifiable, Equatable {
    let id = UUID()
    let text: String
    let context: String
    let confidence: Double
    let tags: [[String]]
    var isSelected: Bool = true
    var importance: HighlightImportance {
        switch confidence {
        case 0.8...: return .high
        case 0.6..<0.8: return .medium
        default: return .low
        }
    }
    static func == (lhs: SuggestedHighlight, rhs: SuggestedHighlight) -> Bool {
        lhs.id == rhs.id
    }
}
struct ExtractedContent: Identifiable {
    let id = UUID()
    let title: String
    let author: String?
    let content: String
    let source: ImportSource
    let suggestedHighlights: [SuggestedHighlight]
}
enum ImportSource: Identifiable {
    case file(URL)
    case web(URL)
    case text(String)
    var id: String {
        switch self {
        case .file(let url): return url.absoluteString
        case .web(let url): return url.absoluteString
        case .text(let string): return string.prefix(50).description
        }
    }
}
// MARK: - Ripple Button
struct RippleButton: View {
    let title: String
    let icon: String
    let action: () -> Void
    @State private var ripples: [Ripple] = []
    @State private var isPressed = false
    struct Ripple: Identifiable {
        let id = UUID()
        let position: CGPoint
        let startTime = Date()
    }
    var body: some View {
        GeometryReader { geometry in
            Button(action: {
                HapticManager.shared.impact(.medium)
                action()
            }) {
                ZStack {
                    // Background
                    RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                        .fill(Color.orange)
                        .scaleEffect(isPressed ? 0.98 : 1)
                    // Ripples
                    ForEach(ripples) { ripple in
                        RippleView(
                            position: ripple.position,
                            startTime: ripple.startTime,
                            size: geometry.size
                        )
                    }
                    // Content
                    HStack(spacing: .ds.small) {
                        Image(systemName: icon)
                        Text(title)
                    }
                    .font(.ds.bodyMedium)
                    .foregroundColor(.white)
                }
            }
            .buttonStyle(.plain)
            .onLongPressGesture(minimumDuration: 0, maximumDistance: .infinity) { pressing in
                withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                    isPressed = pressing
                }
            } perform: {}
            .simultaneousGesture(
                DragGesture(minimumDistance: 0)
                    .onChanged { value in
                        let newRipple = Ripple(position: value.location)
                        ripples.append(newRipple)
                        // Remove old ripples
                        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
                            ripples.removeAll { $0.id == newRipple.id }
                        }
                    }
            )
        }
        .frame(height: 50)
    }
}
struct RippleView: View {
    let position: CGPoint
    let startTime: Date
    let size: CGSize
    @State private var scale: CGFloat = 0
    @State private var opacity: Double = 0.5
    var body: some View {
        Circle()
            .fill(Color.white.opacity(opacity))
            .frame(width: 50, height: 50)
            .scaleEffect(scale)
            .position(position)
            .onAppear {
                let maxScale = max(size.width, size.height) / 25
                withAnimation(.easeOut(duration: 0.8)) {
                    scale = maxScale
                    opacity = 0
                }
            }
    }
}
// MARK: - Animated Mesh Background
struct AnimatedMeshBackground: View {
    @State private var phase: Double = 0
    @State private var colors: [Color] = [.orange.opacity(0.3), .purple.opacity(0.3), .blue.opacity(0.3)]
    var body: some View {
        TimelineView(.animation) { timeline in
            Canvas { context, size in
                drawMeshGradient(context: context, size: size, time: timeline.date.timeIntervalSinceReferenceDate)
            }
        }
        .blur(radius: 30)
    }
    private func drawMeshGradient(context: GraphicsContext, size: CGSize, time: TimeInterval) {
        let gridSpacing: CGFloat = 50
        let circleSize: CGFloat = 80
        let animationSpeed: Double = 0.5
        let waveAmplitude: Double = 20
        let spatialFrequency: Double = 0.01
        for y in stride(from: 0, to: size.height, by: gridSpacing) {
            for x in stride(from: 0, to: size.width, by: gridSpacing) {
                drawMeshCircle(
                    context: context,
                    x: x,
                    y: y,
                    time: time,
                    circleSize: circleSize,
                    animationSpeed: animationSpeed,
                    waveAmplitude: waveAmplitude,
                    spatialFrequency: spatialFrequency
                )
            }
        }
    }
    private func drawMeshCircle(
        context: GraphicsContext,
        x: CGFloat,
        y: CGFloat,
        time: TimeInterval,
        circleSize: CGFloat,
        animationSpeed: Double,
        waveAmplitude: Double,
        spatialFrequency: Double
    ) {
        let offsetX = sin(time * animationSpeed + Double(x) * spatialFrequency) * waveAmplitude
        let offsetY = cos(time * animationSpeed + Double(y) * spatialFrequency) * waveAmplitude
        let colorIndex = Int(x + y) % colors.count
        let color = colors[colorIndex]
        let circleRect = CGRect(
            x: x + offsetX,
            y: y + offsetY,
            width: circleSize,
            height: circleSize
        )
        let gradient = Gradient(colors: [color, color.opacity(0)])
        let radialGradient = GraphicsContext.Shading.radialGradient(
            gradient,
            center: CGPoint(x: circleRect.midX, y: circleRect.midY),
            startRadius: 0,
            endRadius: circleSize / 2
        )
        context.fill(
            Circle().path(in: circleRect),
            with: radialGradient
        )
    }
}
// MARK: - Confetti View
struct ConfettiView: View {
    @State private var particles: [ConfettiParticle] = []
    struct ConfettiParticle: Identifiable {
        let id = UUID()
        let color: Color
        let size: CGFloat
        let shape: ConfettiShape
        var position: CGPoint
        var velocity: CGVector
        var rotation: Double
        var rotationSpeed: Double
        enum ConfettiShape: CaseIterable {
            case circle, square, triangle
        }
    }
    var body: some View {
        TimelineView(.animation) { timeline in
            Canvas { context, size in
                _ = timeline.date.timeIntervalSinceReferenceDate
                for particle in particles {
                    var contextCopy = context
                    contextCopy.translateBy(x: particle.position.x, y: particle.position.y)
                    contextCopy.rotate(by: .degrees(particle.rotation))
                    let rect = CGRect(
                        x: -particle.size / 2,
                        y: -particle.size / 2,
                        width: particle.size,
                        height: particle.size
                    )
                    switch particle.shape {
                    case .circle:
                        contextCopy.fill(Circle().path(in: rect), with: .color(particle.color))
                    case .square:
                        contextCopy.fill(Rectangle().path(in: rect), with: .color(particle.color))
                    case .triangle:
                        let path = Path { path in
                            path.move(to: CGPoint(x: rect.midX, y: rect.minY))
                            path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY))
                            path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))
                            path.closeSubpath()
                        }
                        contextCopy.fill(path, with: .color(particle.color))
                    }
                }
            }
        }
        .onAppear {
            createParticles()
        }
        .onChange(of: particles.count) { _, _ in
            updateParticles()
        }
    }
    private func createParticles() {
        let colors: [Color] = [.orange, .yellow, .purple, .blue, .green, .pink]
        for _ in 0..<100 {
            let particle = ConfettiParticle(
                color: colors.randomElement()!,
                size: CGFloat.random(in: 5...15),
                shape: ConfettiParticle.ConfettiShape.allCases.randomElement()!,
                position: CGPoint(
                    x: CGFloat.random(in: 0...UIScreen.main.bounds.width),
                    y: -50
                ),
                velocity: CGVector(
                    dx: CGFloat.random(in: -100...100),
                    dy: CGFloat.random(in: 200...400)
                ),
                rotation: Double.random(in: 0...360),
                rotationSpeed: Double.random(in: -180...180)
            )
            particles.append(particle)
        }
        // Start physics simulation
        Timer.scheduledTimer(withTimeInterval: 1/60, repeats: true) { _ in
            updateParticles()
        }
    }
    private func updateParticles() {
        for i in particles.indices {
            particles[i].position.x += particles[i].velocity.dx * 0.016
            particles[i].position.y += particles[i].velocity.dy * 0.016
            particles[i].velocity.dy += 500 * 0.016 // gravity
            particles[i].rotation += particles[i].rotationSpeed * 0.016
            // Remove particles that fall off screen
            if particles[i].position.y > UIScreen.main.bounds.height + 50 {
                particles.remove(at: i)
                break
            }
        }
    }
}
// MARK: - Smart Highlight Suggestions
struct SmartHighlightSuggestions: View {
    let content: ExtractedContent
    let onComplete: ([SuggestedHighlight]) -> Void
    @State private var suggestions: [SuggestedHighlight]
    @State private var selectedCount: Int = 0
    @State private var showAIExplanation = false
    @State private var filterImportance: HighlightImportance?
    @Environment(\.dismiss) var dismiss
    init(content: ExtractedContent, onComplete: @escaping ([SuggestedHighlight]) -> Void) {
        self.content = content
        self.onComplete = onComplete
        self._suggestions = State(initialValue: content.suggestedHighlights)
    }
    var body: some View {
        NavigationStack {
            ZStack {
                // Background
                Color.ds.background
                    .ignoresSafeArea()
                ScrollView {
                    VStack(spacing: .ds.large) {
                        // Header with stats
                        suggestionHeader
                        // Filter chips
                        filterChips
                        // Suggestions list
                        LazyVStack(spacing: .ds.medium) {
                            ForEach(filteredSuggestions) { suggestion in
                                SuggestionCard(
                                    suggestion: suggestion,
                                    onToggle: { toggleSuggestion(suggestion) }
                                )
                                .transition(.asymmetric(
                                    insertion: .push(from: .trailing).combined(with: .opacity),
                                    removal: .push(from: .leading).combined(with: .opacity)
                                ))
                            }
                        }
                    }
                    .padding(.horizontal, .ds.screenPadding)
                    .padding(.bottom, 100)
                }
                // Floating action button
                VStack {
                    Spacer()
                    HStack {
                        Spacer()
                        ImportFloatingActionButton(
                            selectedCount: selectedCount,
                            action: {
                                onComplete(suggestions.filter { $0.isSelected })
                            }
                        )
                    }
                    .padding(.ds.screenPadding)
                }
            }
            .navigationTitle("AI Suggestions")
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: {
                        showAIExplanation = true
                    }) {
                        Image(systemName: "info.circle")
                    }
                }
            }
        }
        .sheet(isPresented: $showAIExplanation) {
            AIExplanationSheet()
        }
        .onChange(of: suggestions) { _, _ in
            selectedCount = suggestions.filter { $0.isSelected }.count
        }
    }
    @ViewBuilder
    private var suggestionHeader: some View {
        VStack(spacing: .ds.medium) {
            HStack {
                VStack(alignment: .leading, spacing: .ds.micro) {
                    Text("Found \(content.suggestedHighlights.count) highlights")
                        .font(.ds.title2)
                        .foregroundColor(.ds.text)
                    Text("From \"\(content.title)\"")
                        .font(.ds.body)
                        .foregroundColor(.ds.textSecondary)
                }
                Spacer()
                // Animated stats circle
                ZStack {
                    Circle()
                        .stroke(Color.ds.textTertiary.opacity(0.2), lineWidth: 4)
                        .frame(width: 60, height: 60)
                    Circle()
                        .trim(from: 0, to: CGFloat(selectedCount) / CGFloat(suggestions.count))
                        .stroke(
                            LinearGradient(
                                colors: [.orange, .yellow],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ),
                            style: StrokeStyle(lineWidth: 4, lineCap: .round)
                        )
                        .frame(width: 60, height: 60)
                        .rotationEffect(.degrees(-90))
                        .animation(.spring(response: 0.5, dampingFraction: 0.7), value: selectedCount)
                    Text("\(selectedCount)")
                        .font(.ds.headline)
                        .foregroundColor(.ds.text)
                        .contentTransition(.numericText())
                }
            }
            // Quick actions
            HStack(spacing: .ds.small) {
                Button(action: selectAll) {
                    Label("Select All", systemImage: "checkmark.square.fill")
                        .font(.ds.footnoteMedium)
                }
                .buttonStyle(.bordered)
                .controlSize(.small)
                Button(action: deselectAll) {
                    Label("Deselect All", systemImage: "square")
                        .font(.ds.footnoteMedium)
                }
                .buttonStyle(.bordered)
                .controlSize(.small)
                Spacer()
            }
        }
        .padding(.ds.medium)
        .background(Color.ds.surfaceSecondary)
        .clipShape(RoundedRectangle(cornerRadius: .ds.large, style: .continuous))
    }
    @ViewBuilder
    private var filterChips: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: .ds.small) {
                ForEach([HighlightImportance.high, .medium, .low], id: \.self) { importance in
                    FilterChip(
                        importance: importance,
                        isSelected: filterImportance == importance,
                        action: {
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                filterImportance = filterImportance == importance ? nil : importance
                            }
                        }
                    )
                }
            }
        }
    }
    private var filteredSuggestions: [SuggestedHighlight] {
        if let filter = filterImportance {
            return suggestions.filter { $0.importance == filter }
        }
        return suggestions
    }
    private func toggleSuggestion(_ suggestion: SuggestedHighlight) {
        if let index = suggestions.firstIndex(where: { $0.id == suggestion.id }) {
            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                suggestions[index].isSelected.toggle()
            }
            HapticManager.shared.impact(.light)
        }
    }
    private func selectAll() {
        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
            for i in suggestions.indices {
                suggestions[i].isSelected = true
            }
        }
        HapticManager.shared.impact(.medium)
    }
    private func deselectAll() {
        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
            for i in suggestions.indices {
                suggestions[i].isSelected = false
            }
        }
        HapticManager.shared.impact(.medium)
    }
}
// MARK: - Suggestion Card
struct SuggestionCard: View {
    let suggestion: SuggestedHighlight
    let onToggle: () -> Void
    @State private var isExpanded = false
    @State private var glowAnimation = false
    var body: some View {
        mainContent
            .padding(.ds.medium)
            .background(cardBackground)
            .overlay(glowOverlay)
            .onAppear(perform: startGlowAnimationIfNeeded)
    }
    @ViewBuilder
    private var mainContent: some View {
        VStack(alignment: .leading, spacing: .ds.small) {
            HStack(alignment: .top) {
                selectionCheckbox
                contentStack
                Spacer()
            }
            if isExpanded {
                expandedContextView
            }
        }
    }
    @ViewBuilder
    private var selectionCheckbox: some View {
        Button(action: onToggle) {
            ZStack {
                RoundedRectangle(cornerRadius: 6)
                    .fill(checkboxFillColor)
                    .overlay(
                        RoundedRectangle(cornerRadius: 6)
                            .stroke(checkboxStrokeColor, lineWidth: 2)
                    )
                    .frame(width: 24, height: 24)
                if suggestion.isSelected {
                    Image(systemName: "checkmark")
                        .font(.system(size: 14, weight: .bold))
                        .foregroundColor(.white)
                        .transition(.scale.combined(with: .opacity))
                }
            }
            .animation(.spring(response: 0.3, dampingFraction: 0.6), value: suggestion.isSelected)
        }
        .buttonStyle(.plain)
    }
    @ViewBuilder
    private var contentStack: some View {
        VStack(alignment: .leading, spacing: .ds.micro) {
            importanceIndicator
            highlightText
            if shouldShowMoreButton {
                showMoreButton
            }
        }
    }
    @ViewBuilder
    private var importanceIndicator: some View {
        HStack(spacing: .ds.micro) {
            Image(systemName: suggestion.importance.icon)
                .font(.caption)
                .foregroundColor(suggestion.importance.color)
            Text("\(Int(suggestion.confidence * 100))% confidence")
                .font(.ds.micro)
                .foregroundColor(.ds.textSecondary)
        }
    }
    @ViewBuilder
    private var highlightText: some View {
        Text(suggestion.text)
            .font(.ds.body)
            .foregroundColor(.ds.text)
            .lineLimit(isExpanded ? nil : 3)
            .fixedSize(horizontal: false, vertical: true)
    }
    @ViewBuilder
    private var showMoreButton: some View {
        Button(action: expandContent) {
            Text("Show more")
                .font(.ds.caption)
                .foregroundColor(.ds.primary)
        }
    }
    @ViewBuilder
    private var expandedContextView: some View {
        VStack(alignment: .leading, spacing: .ds.small) {
            Divider()
            Label("Context", systemImage: "text.alignleft")
                .font(.ds.footnoteMedium)
                .foregroundColor(.ds.textSecondary)
            Text(getContextPreview())
                .font(.ds.caption)
                .foregroundColor(.ds.textTertiary)
                .lineLimit(4)
                .padding(.ds.small)
                .background(Color.ds.surfaceSecondary.opacity(0.5))
                .clipShape(RoundedRectangle(cornerRadius: .ds.small))
        }
        .transition(.move(edge: .top).combined(with: .opacity))
    }
    @ViewBuilder
    private var cardBackground: some View {
        RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
            .fill(backgroundFillColor)
            .overlay(
                RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                    .stroke(borderStrokeColor, lineWidth: 1)
            )
    }
    @ViewBuilder
    private var glowOverlay: some View {
        if shouldShowGlow {
            RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                .stroke(
                    LinearGradient(
                        colors: glowGradientColors,
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    ),
                    lineWidth: 2
                )
                .blur(radius: 4)
        }
    }
    // MARK: - Computed Properties
    private var checkboxFillColor: Color {
        suggestion.isSelected ? suggestion.importance.color : Color.clear
    }
    private var checkboxStrokeColor: Color {
        suggestion.isSelected ? Color.clear : Color.ds.textTertiary
    }
    private var shouldShowMoreButton: Bool {
        !isExpanded && suggestion.text.count > 150
    }
    private var backgroundFillColor: Color {
        suggestion.isSelected ? suggestion.importance.color.opacity(0.05) : Color.ds.surfaceSecondary
    }
    private var borderStrokeColor: Color {
        suggestion.isSelected ? suggestion.importance.color.opacity(0.3) : Color.clear
    }
    private var shouldShowGlow: Bool {
        suggestion.importance == .high && glowAnimation
    }
    private var glowGradientColors: [Color] {
        [suggestion.importance.color.opacity(0.5), suggestion.importance.color.opacity(0)]
    }
    // MARK: - Helper Methods
    private func expandContent() {
        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
            isExpanded = true
        }
    }
    private func startGlowAnimationIfNeeded() {
        if suggestion.importance == .high {
            withAnimation(.easeInOut(duration: 2).repeatForever(autoreverses: true)) {
                glowAnimation = true
            }
        }
    }
    private func getContextPreview() -> String {
        // Extract context around the highlight
        let contextLength = 200
        if let range = suggestion.context.range(of: suggestion.text) {
            let startIndex = suggestion.context.index(range.lowerBound, offsetBy: -min(100, suggestion.context.distance(from: suggestion.context.startIndex, to: range.lowerBound)))
            let endIndex = suggestion.context.index(range.upperBound, offsetBy: min(100, suggestion.context.distance(from: range.upperBound, to: suggestion.context.endIndex)))
            return "..." + String(suggestion.context[startIndex..<endIndex]) + "..."
        }
        return suggestion.context.prefix(contextLength) + "..."
    }
}
// MARK: - Supporting Components
struct FilterChip: View {
    let importance: HighlightImportance
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            HStack(spacing: .ds.micro) {
                Image(systemName: importance.icon)
                Text(String(describing: importance).capitalized)
            }
            .font(.ds.footnoteMedium)
            .foregroundColor(isSelected ? .white : importance.color)
            .padding(.horizontal, .ds.base)
            .padding(.vertical, .ds.micro)
            .background(
                Capsule()
                    .fill(isSelected ? importance.color : importance.color.opacity(0.1))
            )
            .overlay(
                Capsule()
                    .stroke(importance.color, lineWidth: isSelected ? 0 : 1)
            )
        }
        .buttonStyle(.plain)
    }
}
struct ImportFloatingActionButton: View {
    let selectedCount: Int
    let action: () -> Void
    @State private var isPressed = false
    @State private var rotationAngle: Double = 0
    var body: some View {
        Button(action: {
            HapticManager.shared.impact(.medium)
            action()
        }) {
            HStack(spacing: .ds.small) {
                Image(systemName: "checkmark.circle.fill")
                    .rotationEffect(.degrees(rotationAngle))
                Text("Import \(selectedCount) Highlights")
                    .fontWeight(.semibold)
            }
            .font(.ds.bodyMedium)
            .foregroundColor(.white)
            .padding(.horizontal, .ds.large)
            .padding(.vertical, .ds.base)
            .background(
                LinearGradient(
                    colors: [.orange, .orange.opacity(0.8)],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
            )
            .clipShape(Capsule())
            .shadow(color: DesignSystem.Colors.secondary.opacity(0.3), radius: DesignSystem.Shadow.medium.radius, x: 0, y: DesignSystem.Shadow.medium.y)
            .scaleEffect(isPressed ? 0.95 : 1)
            .opacity(selectedCount > 0 ? 1 : 0.5)
        }
        .disabled(selectedCount == 0)
        .onLongPressGesture(minimumDuration: 0, maximumDistance: .infinity) { pressing in
            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                isPressed = pressing
            }
        } perform: {}
        .onChange(of: selectedCount) { _, _ in
            withAnimation(.spring(response: 0.5, dampingFraction: 0.6)) {
                rotationAngle += 360
            }
        }
    }
}
// MARK: - AI Explanation Sheet
struct AIExplanationSheet: View {
    @Environment(\.dismiss) var dismiss
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: .ds.large) {
                    // Header illustration
                    ZStack {
                        Circle()
                            .fill(
                                LinearGradient(
                                    colors: [.orange.opacity(0.2), .orange.opacity(0.05)],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .frame(width: 120, height: 120)
                        Image(systemName: "brain.filled.head.profile")
                            .font(.system(size: 60))
                            .foregroundStyle(
                                LinearGradient(
                                    colors: [.orange, .purple],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .symbolEffect(.pulse)
                    }
                    .frame(maxWidth: .infinity)
                    .padding(.top, .ds.large)
                    Text("How AI Suggestions Work")
                        .font(.ds.title2)
                        .foregroundColor(.ds.text)
                    VStack(alignment: .leading, spacing: .ds.medium) {
                        ExplanationRow(
                            icon: "doc.text.magnifyingglass",
                            title: "Content Analysis",
                            description: "Our AI analyzes the entire document to understand context and themes."
                        )
                        ExplanationRow(
                            icon: "brain",
                            title: "Smart Selection",
                            description: "Machine learning identifies the most insightful and quotable passages."
                        )
                        ExplanationRow(
                            icon: "star.fill",
                            title: "Confidence Scoring",
                            description: "Each suggestion is scored based on relevance, clarity, and impact."
                        )
                        ExplanationRow(
                            icon: "lock.fill",
                            title: "Privacy First",
                            description: "All processing happens locally. Your content never leaves your device."
                        )
                    }
                    Text("The AI looks for key insights, memorable quotes, important facts, and thought-provoking ideas that align with the Highlighter community's interests.")
                        .font(.ds.caption)
                        .foregroundColor(.ds.textSecondary)
                        .padding()
                        .background(Color.ds.surfaceSecondary)
                        .clipShape(RoundedRectangle(cornerRadius: .ds.medium))
                }
                .padding(.horizontal, .ds.screenPadding)
                .padding(.bottom, .ds.large)
            }
            .navigationTitle("About AI Suggestions")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
    }
}
struct ExplanationRow: View {
    let icon: String
    let title: String
    let description: String
    var body: some View {
        HStack(alignment: .top, spacing: .ds.medium) {
            Image(systemName: icon)
                .font(.title2)
                .foregroundStyle(
                    LinearGradient(
                        colors: [.orange, .yellow],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: 30)
            VStack(alignment: .leading, spacing: .ds.micro) {
                Text(title)
                    .font(.ds.bodyMedium)
                    .foregroundColor(.ds.text)
                Text(description)
                    .font(.ds.caption)
                    .foregroundColor(.ds.textSecondary)
            }
            Spacer()
        }
    }
}
// MARK: - Additional Support Types
struct ParticleSystem {
    var particles: [Particle] = []
    struct Particle: Identifiable {
        let id = UUID()
        var position: CGPoint
        var velocity: CGVector
        var color: Color
        var size: CGFloat
        var lifetime: Double
    }
}
enum PopularSource: String, CaseIterable {
    case medium = "Medium"
    case substack = "Substack"
    case arxiv = "arXiv"
    case wikipedia = "Wikipedia"
    var icon: String {
        switch self {
        case .medium: return "m.circle.fill"
        case .substack: return "s.circle.fill"
        case .arxiv: return "a.circle.fill"
        case .wikipedia: return "w.circle.fill"
        }
    }
    var baseURL: String {
        switch self {
        case .medium: return "https://medium.com/"
        case .substack: return "https://substack.com/"
        case .arxiv: return "https://arxiv.org/"
        case .wikipedia: return "https://wikipedia.org/"
        }
    }
}
struct PopularSourceCard: View {
    let source: PopularSource
    let onSelect: (String) -> Void
    @State private var isHovered = false
    var body: some View {
        Button(action: {
            onSelect(source.baseURL)
            HapticManager.shared.impact(.light)
        }) {
            VStack(spacing: .ds.small) {
                Text(source.icon)
                    .font(.system(size: 30))
                Text(source.rawValue)
                    .font(.ds.caption)
                    .foregroundColor(.ds.text)
            }
            .frame(maxWidth: .infinity)
            .padding(.ds.base)
            .background(
                RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                    .fill(isHovered ? Color.ds.surface : Color.ds.surfaceSecondary)
            )
            .scaleEffect(isHovered ? 1.05 : 1)
        }
        .buttonStyle(.plain)
        .onHover { hovering in
            withAnimation(.easeInOut(duration: 0.2)) {
                isHovered = hovering
            }
        }
    }
}
struct ArticlePreview: View {
    let html: String
    @State private var isLoading = true
    @State private var estimatedHeight: CGFloat = 300
    var body: some View {
        HTMLWebView(
            html: html,
            isLoading: $isLoading,
            estimatedHeight: $estimatedHeight
        )
        .frame(height: estimatedHeight)
        .background(Color.ds.surfaceSecondary)
        .overlay(
            Group {
                if isLoading {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle())
                        .scaleEffect(0.8)
                        .frame(maxWidth: .infinity, maxHeight: .infinity)
                        .background(Color.ds.surfaceSecondary.opacity(0.8))
                }
            }
        )
        .cornerRadius(DesignSystem.CornerRadius.medium)
    }
}
// MARK: - HTML WebView
struct HTMLWebView: UIViewRepresentable {
    let html: String
    @Binding var isLoading: Bool
    @Binding var estimatedHeight: CGFloat
    func makeUIView(context: Context) -> WKWebView {
        let webView = WKWebView()
        webView.navigationDelegate = context.coordinator
        webView.scrollView.isScrollEnabled = true
        webView.scrollView.bounces = false
        webView.backgroundColor = .clear
        webView.isOpaque = false
        // Configure for better content display
        let contentController = webView.configuration.userContentController
        let scriptSource = """
            var meta = document.createElement('meta');
            meta.name = 'viewport';
            meta.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
            document.getElementsByTagName('head')[0].appendChild(meta);
        """
        let script = WKUserScript(source: scriptSource, injectionTime: .atDocumentEnd, forMainFrameOnly: true)
        contentController.addUserScript(script)
        return webView
    }
    func updateUIView(_ webView: WKWebView, context: Context) {
        let styledHTML = """
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <style>
                body {
                    font-family: -apple-system, system-ui, sans-serif;
                    font-size: 14px;
                    line-height: 1.6;
                    color: \(isDarkMode ? "#E0E0E0" : "#333333");
                    background-color: transparent;
                    margin: 16px;
                    padding: 0;
                }
                img {
                    max-width: 100%;
                    height: auto;
                    border-radius: 8px;
                }
                a {
                    color: \(isDarkMode ? "#6FA3F5" : "#007AFF");
                    text-decoration: none;
                }
                h1, h2, h3, h4, h5, h6 {
                    color: \(isDarkMode ? "#FFFFFF" : "#000000");
                    margin-top: 16px;
                    margin-bottom: 8px;
                }
                p {
                    margin: 8px 0;
                }
                blockquote {
                    border-left: 4px solid \(isDarkMode ? "#6FA3F5" : "#007AFF");
                    padding-left: 16px;
                    margin-left: 0;
                    color: \(isDarkMode ? "#B0B0B0" : "#666666");
                }
                pre {
                    background-color: \(isDarkMode ? "#2C2C2E" : "#F2F2F7");
                    padding: 12px;
                    border-radius: 8px;
                    overflow-x: auto;
                }
                code {
                    background-color: \(isDarkMode ? "#2C2C2E" : "#F2F2F7");
                    padding: 2px 4px;
                    border-radius: 4px;
                    font-family: monospace;
                }
            </style>
        </head>
        <body>
            \(html)
        </body>
        </html>
        """
        webView.loadHTMLString(styledHTML, baseURL: nil)
    }
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    private var isDarkMode: Bool {
        UITraitCollection.current.userInterfaceStyle == .dark
    }
    class Coordinator: NSObject, WKNavigationDelegate {
        var parent: HTMLWebView
        init(_ parent: HTMLWebView) {
            self.parent = parent
        }
        func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
            parent.isLoading = false
            // Calculate content height
            webView.evaluateJavaScript("document.body.scrollHeight") { height, error in
                if let height = height as? CGFloat {
                    DispatchQueue.main.async {
                        self.parent.estimatedHeight = min(height + 32, 600) // Cap at 600
                    }
                }
            }
        }
        func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
            if navigationAction.navigationType == .linkActivated {
                if let url = navigationAction.request.url {
                    UIApplication.shared.open(url)
                    decisionHandler(.cancel)
                    return
                }
            }
            decisionHandler(.allow)
        }
    }
}
struct TipsCard: View {
    var body: some View {
        VStack(alignment: .leading, spacing: .ds.small) {
            Label("Tips for Better Results", systemImage: "lightbulb.fill")
                .font(.ds.footnoteMedium)
                .foregroundColor(.orange)
            VStack(alignment: .leading, spacing: .ds.micro) {
                TipRow(text: "Hold your device steady")
                TipRow(text: "Ensure good lighting")
                TipRow(text: "Capture text at a straight angle")
                TipRow(text: "Avoid shadows and glare")
            }
        }
        .padding(.ds.medium)
        .background(
            LinearGradient(
                colors: [.orange.opacity(0.1), .orange.opacity(0.05)],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        )
        .clipShape(RoundedRectangle(cornerRadius: .ds.medium, style: .continuous))
    }
}
struct TipRow: View {
    let text: String
    var body: some View {
        HStack(spacing: .ds.small) {
            Circle()
                .fill(Color.orange)
                .frame(width: 4, height: 4)
            Text(text)
                .font(.ds.caption)
                .foregroundColor(.ds.textSecondary)
        }
    }
}
// MARK: - Document Picker
struct DocumentPicker: UIViewControllerRepresentable {
    let allowedContentTypes: [UTType]
    let onPick: (URL) -> Void
    func makeUIViewController(context: Context) -> UIDocumentPickerViewController {
        let picker = UIDocumentPickerViewController(forOpeningContentTypes: allowedContentTypes)
        picker.delegate = context.coordinator
        return picker
    }
    func updateUIViewController(_ uiViewController: UIDocumentPickerViewController, context: Context) {}
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    class Coordinator: NSObject, UIDocumentPickerDelegate {
        let parent: DocumentPicker
        init(_ parent: DocumentPicker) {
            self.parent = parent
        }
        func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {
            if let url = urls.first {
                parent.onPick(url)
            }
        }
    }
}
// MARK: - Camera Picker
struct CameraPicker: UIViewControllerRepresentable {
    @Binding var image: UIImage?
    let onCapture: (UIImage?) -> Void
    func makeUIViewController(context: Context) -> UIImagePickerController {
        let picker = UIImagePickerController()
        picker.sourceType = .camera
        picker.delegate = context.coordinator
        return picker
    }
    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }
    class Coordinator: NSObject, UIImagePickerControllerDelegate, UINavigationControllerDelegate {
        let parent: CameraPicker
        init(_ parent: CameraPicker) {
            self.parent = parent
        }
        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
            if let image = info[.originalImage] as? UIImage {
                parent.image = image
                parent.onCapture(image)
            }
            picker.dismiss(animated: true)
        }
        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
            picker.dismiss(animated: true)
        }
    }
}
</file>

<file path="Sources/Highlighter/Views/Lightning/LightningPaymentFlowView.swift">
import SwiftUI
import NDKSwift
struct LightningPaymentFlowView: View {
    @StateObject private var lightningService = LightningService()
    @State private var selectedAmount = 1000
    @State private var customAmount = ""
    @State private var showingPaymentFlow = false
    @State private var currentPaymentStep: PaymentStep = .selectAmount
    @State private var splitVisualizationScale: CGFloat = 0
    @State private var particles: [LightningParticle] = []
    @State private var glowIntensity: Double = 0
    @State private var successScale: CGFloat = 0
    @State private var paymentComplete = false
    @State private var rotationAngle: Double = 0
    @State private var flowAnimation: CGFloat = 0
    @State private var splitAnimations: [String: CGFloat] = [:]
    @State private var lightningBoltAnimation = false
    @State private var coinFlipRotation: Double = 0
    @State private var activePayment: LightningService.ActivePayment?
    @State private var selectedSplitConfiguration = 0
    @State private var customSplitConfig = LightningService.SplitConfiguration.highlight
    @State private var showCustomSplitEditor = false
    @Namespace private var animation
    @Environment(\.dismiss) var dismiss
    @Environment(\.colorScheme) var colorScheme
    // Payment target info
    let highlight: HighlightEvent
    let authorProfile: NDKUserProfile?
    let highlighterProfile: NDKUserProfile?
    let curatorProfile: NDKUserProfile?
    private let predefinedAmounts = [100, 500, 1000, 5000, 10000, 50000]
    private let splitConfigurations = [
        ("Default", LightningService.SplitConfiguration.highlight),
        ("Author Focus", LightningService.SplitConfiguration(author: 0.7, highlighter: 0.2, curator: 0.05, platform: 0.05)),
        ("Equal Split", LightningService.SplitConfiguration(author: 0.32, highlighter: 0.32, curator: 0.31, platform: 0.05)),
        ("Custom", LightningService.SplitConfiguration.highlight)
    ]
    enum PaymentStep {
        case selectAmount
        case configureSplits
        case processingPayment
        case visualizingSplits
        case complete
    }
    var body: some View {
        ZStack {
            // Background gradient
            backgroundGradient
            // Particle effects layer
            ParticleEffectsLayer(particles: $particles)
                .allowsHitTesting(false)
            // Main content
            VStack(spacing: 0) {
                // Header
                paymentHeader
                // Content based on step
                Group {
                    switch currentPaymentStep {
                    case .selectAmount:
                        amountSelectionView
                            .transition(.asymmetric(
                                insertion: .scale(scale: 0.9).combined(with: .opacity),
                                removal: .scale(scale: 1.1).combined(with: .opacity)
                            ))
                    case .configureSplits:
                        splitConfigurationView
                            .transition(.asymmetric(
                                insertion: .push(from: .trailing),
                                removal: .push(from: .leading)
                            ))
                    case .processingPayment:
                        processingView
                            .transition(.scale.combined(with: .opacity))
                    case .visualizingSplits:
                        splitVisualizationView
                            .transition(.scale.combined(with: .opacity))
                    case .complete:
                        completionView
                            .transition(.asymmetric(
                                insertion: .scale(scale: 1.2).combined(with: .opacity),
                                removal: .scale(scale: 0.8).combined(with: .opacity)
                            ))
                    }
                }
                .animation(.spring(response: 0.6, dampingFraction: 0.8), value: currentPaymentStep)
                Spacer()
                // Action buttons
                actionButtons
            }
            .padding()
        }
        .onAppear {
            startAnimations()
        }
        .onChange(of: activePayment?.status) { _, newStatus in
            handlePaymentStatusChange(newStatus)
        }
    }
    // MARK: - Background
    @ViewBuilder
    private var backgroundGradient: some View {
        ZStack {
            LinearGradient(
                colors: [
                    Color.ds.background,
                    Color.ds.primary.opacity(0.05)
                ],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            // Animated gradient overlay
            RadialGradient(
                colors: [
                    Color.ds.primary.opacity(glowIntensity * 0.3),
                    Color.clear
                ],
                center: .center,
                startRadius: 50,
                endRadius: 300
            )
            .scaleEffect(1 + glowIntensity)
            .blur(radius: 20)
        }
        .ignoresSafeArea()
    }
    // MARK: - Header
    @ViewBuilder
    private var paymentHeader: some View {
        VStack(spacing: 16) {
            // Lightning bolt icon with animation
            ZStack {
                // Glow effect
                Circle()
                    .fill(
                        RadialGradient(
                            colors: [
                                Color.orange.opacity(0.6),
                                Color.orange.opacity(0.2),
                                Color.clear
                            ],
                            center: .center,
                            startRadius: 10,
                            endRadius: 50
                        )
                    )
                    .frame(width: 100, height: 100)
                    .scaleEffect(lightningBoltAnimation ? 1.2 : 1)
                    .blur(radius: lightningBoltAnimation ? 15 : 10)
                Image(systemName: "bolt.circle.fill")
                    .font(.system(size: 60))
                    .foregroundStyle(
                        LinearGradient(
                            colors: [.orange, .yellow],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .rotationEffect(.degrees(lightningBoltAnimation ? 5 : -5))
                    .scaleEffect(lightningBoltAnimation ? 1.1 : 1)
            }
            Text("Lightning Payment")
                .font(.ds.title2)
                .fontWeight(.bold)
            // Balance display
            if lightningService.isConnected {
                HStack {
                    Image(systemName: "bitcoinsign.circle.fill")
                        .foregroundColor(.orange)
                    Text("\(lightningService.balance) sats")
                        .font(.ds.callout)
                        .monospacedDigit()
                }
                .padding(.horizontal, 16)
                .padding(.vertical, 8)
                .background(
                    Capsule()
                        .fill(Color.ds.backgroundSecondary)
                        .overlay(
                            Capsule()
                                .strokeBorder(Color.ds.border, lineWidth: 1)
                        )
                )
            }
        }
        .padding(.vertical, 24)
    }
    // MARK: - Amount Selection
    @ViewBuilder
    private var amountSelectionView: some View {
        VStack(spacing: 24) {
            Text("Select Amount")
                .font(.ds.headline)
                .foregroundColor(.ds.textSecondary)
            // Predefined amounts grid
            LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible()), GridItem(.flexible())], spacing: 16) {
                ForEach(predefinedAmounts, id: \.self) { amount in
                    AmountButton(
                        amount: amount,
                        isSelected: selectedAmount == amount,
                        action: {
                            withAnimation(.spring(response: 0.3)) {
                                selectedAmount = amount
                                customAmount = ""
                                HapticManager.shared.impact(.light)
                            }
                        }
                    )
                }
            }
            // Custom amount input
            VStack(spacing: 12) {
                Text("Or enter custom amount")
                    .font(.ds.caption)
                    .foregroundColor(.ds.textSecondary)
                HStack {
                    TextField("Amount in sats", text: $customAmount)
                        .keyboardType(.numberPad)
                        .textFieldStyle(.roundedBorder)
                        .onChange(of: customAmount) { _, newValue in
                            if let amount = Int(newValue) {
                                selectedAmount = amount
                            }
                        }
                    Text("sats")
                        .font(.ds.callout)
                        .foregroundColor(.ds.textSecondary)
                }
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(Color.ds.backgroundSecondary)
            )
        }
        .padding(.vertical)
    }
    // MARK: - Split Configuration
    @ViewBuilder
    private var splitConfigurationView: some View {
        VStack(spacing: 24) {
            Text("Configure Payment Splits")
                .font(.ds.headline)
                .foregroundColor(.ds.textSecondary)
            // Split configuration options
            VStack(spacing: 12) {
                ForEach(Array(splitConfigurations.enumerated()), id: \.offset) { index, config in
                    SplitConfigurationCard(
                        title: config.0,
                        configuration: index == 3 ? customSplitConfig : config.1,
                        isSelected: selectedSplitConfiguration == index,
                        isCustom: index == 3,
                        amount: selectedAmount,
                        authorName: authorProfile?.displayName ?? "Author",
                        highlighterName: highlighterProfile?.displayName ?? "Highlighter",
                        curatorName: curatorProfile?.displayName ?? "Curator",
                        onSelect: {
                            withAnimation(.spring(response: 0.3)) {
                                selectedSplitConfiguration = index
                                if index == 3 {
                                    showCustomSplitEditor = true
                                }
                                HapticManager.shared.impact(.light)
                            }
                        }
                    )
                }
            }
            // Visual preview of splits
            SplitPreviewVisualization(
                configuration: selectedSplitConfiguration == 3 ? customSplitConfig : splitConfigurations[selectedSplitConfiguration].1,
                totalAmount: selectedAmount,
                animationProgress: splitVisualizationScale
            )
        }
        .padding(.vertical)
        .sheet(isPresented: $showCustomSplitEditor) {
            CustomSplitEditorView(configuration: $customSplitConfig)
        }
    }
    // MARK: - Processing View
    @ViewBuilder
    private var processingView: some View {
        VStack(spacing: 32) {
            animatedLightningBolt
            Text("Processing Payment")
                .font(.ds.title3)
                .fontWeight(.semibold)
            if let payment = activePayment {
                PaymentStatusIndicator(payment: payment)
            }
        }
        .onAppear {
            processPayment()
        }
    }
    @ViewBuilder
    private var animatedLightningBolt: some View {
        ZStack {
            animatedCircles
            lightningBoltIcon
        }
    }
    @ViewBuilder
    private var animatedCircles: some View {
        ForEach(0..<3) { index in
            animatedCircle(for: index)
        }
    }
    @ViewBuilder
    private func animatedCircle(for index: Int) -> some View {
        Circle()
            .stroke(lightningGradient, lineWidth: 2)
            .frame(width: circleSize(for: index), height: circleSize(for: index))
            .scaleEffect(flowAnimation)
            .opacity(Double(1 - (flowAnimation * 0.3)))
            .animation(circleAnimation(for: index), value: flowAnimation)
    }
    private var lightningBoltIcon: some View {
        Image(systemName: "bolt.circle.fill")
            .font(.system(size: 80))
            .foregroundStyle(lightningGradient)
            .rotationEffect(.degrees(rotationAngle))
    }
    private var lightningGradient: LinearGradient {
        LinearGradient(
            colors: [.orange, .yellow],
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
    }
    private func circleSize(for index: Int) -> CGFloat {
        100 + CGFloat(index) * 40
    }
    private func circleAnimation(for index: Int) -> Animation {
        .easeOut(duration: 1.5)
            .repeatForever(autoreverses: false)
            .delay(Double(index) * 0.3)
    }
    // MARK: - Split Visualization
    @ViewBuilder
    private var splitVisualizationView: some View {
        VStack(spacing: 32) {
            Text("Splitting Payment")
                .font(.ds.title3)
                .fontWeight(.semibold)
            // Animated split visualization
            SplitFlowVisualization(
                payment: activePayment,
                animationProgress: flowAnimation,
                particles: $particles
            )
            // Split progress indicators
            if let payment = activePayment {
                VStack(spacing: 16) {
                    ForEach(Array(payment.splits.enumerated()), id: \.element.recipientPubkey) { index, split in
                        SplitProgressRow(
                            split: split,
                            animationProgress: splitAnimations[split.id.uuidString] ?? 0
                        )
                        .onAppear {
                            withAnimation(.spring(response: 0.5).delay(Double(payment.splits.firstIndex(where: { $0.id == split.id }) ?? 0) * 0.2)) {
                                splitAnimations[split.id.uuidString] = 1
                            }
                        }
                    }
                }
                .padding()
                .background(
                    RoundedRectangle(cornerRadius: 16)
                        .fill(Color.ds.backgroundSecondary)
                )
            }
        }
        .padding(.vertical)
    }
    // MARK: - Completion View
    @ViewBuilder
    private var completionView: some View {
        VStack(spacing: 32) {
            // Success animation
            ZStack {
                // Confetti particles
                ForEach(0..<20) { _ in
                    ConfettiParticle()
                }
                // Success checkmark
                Circle()
                    .fill(
                        LinearGradient(
                            colors: [.green, .green.opacity(0.7)],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: 100, height: 100)
                    .scaleEffect(successScale)
                    .overlay(
                        Image(systemName: "checkmark")
                            .font(.system(size: 50, weight: .bold))
                            .foregroundColor(.white)
                            .scaleEffect(successScale)
                    )
            }
            Text("Payment Complete!")
                .font(.ds.title2)
                .fontWeight(.bold)
            // Transaction summary
            if let payment = activePayment {
                TransactionSummaryCard(payment: payment)
            }
            // Share button
            Button(action: shareTransaction) {
                Label("Share Transaction", systemImage: "square.and.arrow.up")
            }
            .unifiedSecondaryButton()
        }
        .padding(.vertical)
        .onAppear {
            withAnimation(.spring(response: 0.6, dampingFraction: 0.6)) {
                successScale = 1
            }
            HapticManager.shared.notification(.success)
        }
    }
    // MARK: - Action Buttons
    @ViewBuilder
    private var actionButtons: some View {
        HStack(spacing: 16) {
            if currentPaymentStep != .complete {
                Button("Cancel") {
                    HapticManager.shared.impact(.light)
                    dismiss()
                }
                .unifiedSecondaryButton()
            }
            switch currentPaymentStep {
            case .selectAmount:
                Button("Continue") {
                    withAnimation(.spring(response: 0.5)) {
                        currentPaymentStep = .configureSplits
                        splitVisualizationScale = 1
                    }
                    HapticManager.shared.impact(.medium)
                }
                .unifiedPrimaryButton()
                .disabled(selectedAmount < 1)
            case .configureSplits:
                Button("Send Payment") {
                    withAnimation(.spring(response: 0.5)) {
                        currentPaymentStep = .processingPayment
                    }
                    HapticManager.shared.impact(.medium)
                }
                .unifiedPrimaryButton()
            case .processingPayment, .visualizingSplits:
                EmptyView()
            case .complete:
                Button("Done") {
                    HapticManager.shared.impact(.light)
                    dismiss()
                }
                .unifiedPrimaryButton()
            }
        }
        .padding(.vertical)
    }
    // MARK: - Helper Methods
    private func startAnimations() {
        withAnimation(.easeInOut(duration: 2).repeatForever(autoreverses: true)) {
            glowIntensity = 0.8
            lightningBoltAnimation = true
        }
        withAnimation(.linear(duration: 3).repeatForever(autoreverses: false)) {
            rotationAngle = 360
        }
        Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { _ in
            generateLightningParticles()
        }
    }
    private func processPayment() {
        Task {
            // Create payment with actual splits
            let splits = selectedSplitConfiguration == 3 ? customSplitConfig : splitConfigurations[selectedSplitConfiguration].1
            let paymentSplits = [
                LightningService.PaymentSplit(
                    recipientPubkey: highlight.pubkey,
                    amount: Int(Double(selectedAmount) * splits.highlighterPercentage),
                    role: .highlighter,
                    isOriginal: true
                ),
                LightningService.PaymentSplit(
                    recipientPubkey: highlight.author,
                    amount: Int(Double(selectedAmount) * splits.authorPercentage),
                    role: .author,
                    isOriginal: false
                ),
                LightningService.PaymentSplit(
                    recipientPubkey: highlight.pubkey, // Use highlight pubkey as fallback
                    amount: Int(Double(selectedAmount) * splits.curatorPercentage),
                    role: .curator,
                    isOriginal: false
                )
            ].filter { $0.amount > 0 }
            let payment = LightningService.ActivePayment(
                id: UUID(),
                totalAmount: selectedAmount,
                splits: paymentSplits,
                highlightId: highlight.id,
                comment: nil,
                status: .pending,
                timestamp: Date()
            )
            await MainActor.run {
                activePayment = payment
                flowAnimation = 1
            }
        }
    }
    private func handlePaymentStatusChange(_ status: LightningService.ActivePayment.PaymentStatus?) {
        guard let status = status else { return }
        switch status {
        case .splitting:
            withAnimation(.spring(response: 0.5)) {
                currentPaymentStep = .visualizingSplits
            }
        case .completed:
            withAnimation(.spring(response: 0.6).delay(0.5)) {
                currentPaymentStep = .complete
                paymentComplete = true
            }
        default:
            break
        }
    }
    private func generateLightningParticles() {
        if paymentComplete { return }
        if Bool.random() {
            let particle = LightningParticle(
                x: .random(in: 0...UIScreen.main.bounds.width),
                y: UIScreen.main.bounds.height + 50,
                targetY: .random(in: 100...UIScreen.main.bounds.height - 100),
                color: [.orange, .yellow].randomElement()!,
                size: .random(in: 2...6),
                duration: .random(in: 1...3)
            )
            particles.append(particle)
            // Remove old particles
            particles = particles.filter { particle in
                particle.createdAt.timeIntervalSinceNow > -particle.duration
            }
        }
    }
    private func shareTransaction() {
        guard let payment = activePayment else { return }
        let transactionSummary = """
        ⚡️ Lightning Payment Complete!
        Total: \(payment.totalAmount) sats
        Split to:
        \(payment.splits.map { "• \($0.recipientName): \($0.amount) sats" }.joined(separator: "\n"))
        Powered by Highlighter 🎯
        """
        let activityVC = UIActivityViewController(
            activityItems: [transactionSummary],
            applicationActivities: nil
        )
        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let window = windowScene.windows.first,
           let rootVC = window.rootViewController {
            if let presentedVC = rootVC.presentedViewController {
                presentedVC.present(activityVC, animated: true)
            } else {
                rootVC.present(activityVC, animated: true)
            }
        }
        HapticManager.shared.impact(.medium)
    }
}
// MARK: - Supporting Views
struct AmountButton: View {
    let amount: Int
    let isSelected: Bool
    let action: () -> Void
    @State private var isPressed = false
    var body: some View {
        Button(action: action) {
            VStack(spacing: 4) {
                Image(systemName: "bitcoinsign.circle.fill")
                    .font(.title2)
                    .foregroundColor(isSelected ? .white : .orange)
                Text("\(amount)")
                    .font(.ds.headline)
                    .monospacedDigit()
                    .foregroundColor(isSelected ? .white : .ds.text)
                Text("sats")
                    .font(.ds.caption)
                    .foregroundColor(isSelected ? .white.opacity(0.8) : .ds.textSecondary)
            }
            .frame(maxWidth: .infinity)
            .padding(.vertical, 16)
            .background(
                RoundedRectangle(cornerRadius: 12)
                    .fill(isSelected ? Color.ds.primary : Color.ds.backgroundSecondary)
                    .overlay(
                        RoundedRectangle(cornerRadius: 12)
                            .strokeBorder(
                                isSelected ? Color.clear : Color.ds.border,
                                lineWidth: 1
                            )
                    )
            )
            .scaleEffect(isPressed ? 0.95 : 1)
        }
        .buttonStyle(PlainButtonStyle())
        .onLongPressGesture(minimumDuration: 0, maximumDistance: .infinity, pressing: { pressing in
            withAnimation(.spring(response: 0.3)) {
                isPressed = pressing
            }
        }, perform: {})
    }
}
struct SplitConfigurationCard: View {
    let title: String
    let configuration: LightningService.SplitConfiguration
    let isSelected: Bool
    let isCustom: Bool
    let amount: Int
    let authorName: String
    let highlighterName: String
    let curatorName: String
    let onSelect: () -> Void
    var body: some View {
        Button(action: onSelect) {
            VStack(alignment: .leading, spacing: 12) {
                HStack {
                    Text(title)
                        .font(.ds.headline)
                        .foregroundColor(isSelected ? .white : .ds.text)
                    Spacer()
                    if isSelected {
                        Image(systemName: "checkmark.circle.fill")
                            .foregroundColor(.white)
                    }
                }
                if !isCustom {
                    // Split breakdown
                    VStack(spacing: 8) {
                        SplitRow(
                            icon: "person.fill",
                            label: authorName,
                            percentage: configuration.author,
                            amount: Int(Double(amount) * configuration.author),
                            color: .purple,
                            isSelected: isSelected
                        )
                        SplitRow(
                            icon: "highlighter",
                            label: highlighterName,
                            percentage: configuration.highlighter,
                            amount: Int(Double(amount) * configuration.highlighter),
                            color: .orange,
                            isSelected: isSelected
                        )
                        SplitRow(
                            icon: "folder.fill",
                            label: curatorName,
                            percentage: configuration.curator,
                            amount: Int(Double(amount) * configuration.curator),
                            color: .blue,
                            isSelected: isSelected
                        )
                        SplitRow(
                            icon: "building.2.fill",
                            label: "Platform",
                            percentage: configuration.platform,
                            amount: Int(Double(amount) * configuration.platform),
                            color: .gray,
                            isSelected: isSelected
                        )
                    }
                } else {
                    Text("Tap to customize split percentages")
                        .font(.ds.caption)
                        .foregroundColor(isSelected ? .white.opacity(0.8) : .ds.textSecondary)
                }
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 16)
                    .fill(isSelected ? Color.ds.primary : Color.ds.backgroundSecondary)
                    .overlay(
                        RoundedRectangle(cornerRadius: 16)
                            .strokeBorder(
                                isSelected ? Color.clear : Color.ds.border,
                                lineWidth: 1
                            )
                    )
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}
struct SplitRow: View {
    let icon: String
    let label: String
    let percentage: Double
    let amount: Int
    let color: Color
    let isSelected: Bool
    var body: some View {
        HStack {
            Image(systemName: icon)
                .font(.caption)
                .foregroundColor(isSelected ? .white : color)
                .frame(width: 20)
            Text(label)
                .font(.ds.caption)
                .foregroundColor(isSelected ? .white : .ds.text)
            Spacer()
            Text("\(Int(percentage * 100))%")
                .font(.ds.caption.monospacedDigit())
                .foregroundColor(isSelected ? .white.opacity(0.8) : .ds.textSecondary)
            Text("·")
                .foregroundColor(isSelected ? .white.opacity(0.5) : .ds.textTertiary)
            Text("\(amount) sats")
                .font(.ds.caption.monospacedDigit())
                .foregroundColor(isSelected ? .white : .ds.text)
        }
    }
}
struct SplitPreviewVisualization: View {
    let configuration: LightningService.SplitConfiguration
    let totalAmount: Int
    let animationProgress: CGFloat
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // Background circle
                Circle()
                    .fill(Color.ds.backgroundSecondary)
                    .overlay(
                        Circle()
                            .strokeBorder(Color.ds.border, lineWidth: 1)
                    )
                // Split segments
                SplitSegment(
                    startAngle: 0,
                    endAngle: configuration.author * 360,
                    color: .purple,
                    label: "Author",
                    amount: Int(Double(totalAmount) * configuration.author),
                    animationProgress: animationProgress
                )
                SplitSegment(
                    startAngle: configuration.author * 360,
                    endAngle: (configuration.author + configuration.highlighter) * 360,
                    color: .orange,
                    label: "Highlighter",
                    amount: Int(Double(totalAmount) * configuration.highlighter),
                    animationProgress: animationProgress
                )
                SplitSegment(
                    startAngle: (configuration.author + configuration.highlighter) * 360,
                    endAngle: (configuration.author + configuration.highlighter + configuration.curator) * 360,
                    color: .blue,
                    label: "Curator",
                    amount: Int(Double(totalAmount) * configuration.curator),
                    animationProgress: animationProgress
                )
                SplitSegment(
                    startAngle: (configuration.author + configuration.highlighter + configuration.curator) * 360,
                    endAngle: 360,
                    color: .gray,
                    label: "Platform",
                    amount: Int(Double(totalAmount) * configuration.platform),
                    animationProgress: animationProgress
                )
                // Center total
                VStack {
                    Text("\(totalAmount)")
                        .font(.ds.title2)
                        .fontWeight(.bold)
                        .monospacedDigit()
                    Text("sats")
                        .font(.ds.caption)
                        .foregroundColor(.ds.textSecondary)
                }
                .scaleEffect(animationProgress)
            }
        }
        .aspectRatio(1, contentMode: .fit)
        .frame(height: 200)
    }
}
struct SplitSegment: View {
    let startAngle: Double
    let endAngle: Double
    let color: Color
    let label: String
    let amount: Int
    let animationProgress: CGFloat
    var body: some View {
        GeometryReader { geometry in
            let center = CGPoint(x: geometry.size.width / 2, y: geometry.size.height / 2)
            let radius = min(geometry.size.width, geometry.size.height) / 2 - 10
            Path { path in
                path.move(to: center)
                path.addArc(
                    center: center,
                    radius: radius,
                    startAngle: .degrees(startAngle - 90),
                    endAngle: .degrees(startAngle + (endAngle - startAngle) * Double(animationProgress) - 90),
                    clockwise: false
                )
                path.closeSubpath()
            }
            .fill(color.opacity(0.8))
            .overlay(
                Path { path in
                    path.move(to: center)
                    path.addArc(
                        center: center,
                        radius: radius,
                        startAngle: .degrees(startAngle - 90),
                        endAngle: .degrees(startAngle + (endAngle - startAngle) * Double(animationProgress) - 90),
                        clockwise: false
                    )
                    path.closeSubpath()
                }
                .stroke(color, lineWidth: 2)
            )
        }
    }
}
struct PaymentStatusIndicator: View {
    let payment: LightningService.ActivePayment
    @State private var pulseAnimation = false
    var body: some View {
        VStack(spacing: 12) {
            HStack(spacing: 8) {
                statusIcon
                    .scaleEffect(pulseAnimation ? 1.2 : 1)
                Text(statusText)
                    .font(.ds.callout)
                    .foregroundColor(.ds.textSecondary)
            }
            if case .processing = payment.status {
                ProgressView()
                    .progressViewStyle(CircularProgressViewStyle())
                    .tint(.orange)
            }
        }
        .onAppear {
            withAnimation(.easeInOut(duration: 0.8).repeatForever(autoreverses: true)) {
                pulseAnimation = true
            }
        }
    }
    @ViewBuilder
    private var statusIcon: some View {
        switch payment.status {
        case .pending:
            Image(systemName: "clock.fill")
                .foregroundColor(.orange)
        case .processing:
            Image(systemName: "bolt.circle.fill")
                .foregroundColor(.orange)
        case .splitting:
            Image(systemName: "arrow.triangle.branch")
                .foregroundColor(.blue)
        case .completed:
            Image(systemName: "checkmark.circle.fill")
                .foregroundColor(.green)
        case .failed:
            Image(systemName: "xmark.circle.fill")
                .foregroundColor(.red)
        case .preparing:
            Image(systemName: "gearshape.fill")
                .foregroundColor(.gray)
        case .sending:
            Image(systemName: "paperplane.fill")
                .foregroundColor(.blue)
        }
    }
    private var statusText: String {
        switch payment.status {
        case .pending:
            return "Preparing payment..."
        case .processing:
            return "Processing payment..."
        case .splitting:
            return "Distributing splits..."
        case .completed:
            return "Payment complete!"
        case .failed:
            return "Payment failed"
        case .preparing:
            return "Preparing transaction..."
        case .sending:
            return "Sending payment..."
        }
    }
}
// MARK: - Particle Effects
struct ParticleEffectsLayer: View {
    @Binding var particles: [LightningParticle]
    var body: some View {
        ZStack {
            ForEach(particles) { particle in
                LightningParticleView(particle: particle)
            }
        }
    }
}
struct LightningParticle: Identifiable {
    let id = UUID()
    let x: CGFloat
    let y: CGFloat
    let targetY: CGFloat
    let color: Color
    let size: CGFloat
    let duration: TimeInterval
    let createdAt = Date()
}
struct LightningParticleView: View {
    let particle: LightningParticle
    @State private var offset: CGFloat = 0
    @State private var opacity: Double = 1
    var body: some View {
        Circle()
            .fill(
                RadialGradient(
                    colors: [particle.color, particle.color.opacity(0)],
                    center: .center,
                    startRadius: 0,
                    endRadius: particle.size
                )
            )
            .frame(width: particle.size * 2, height: particle.size * 2)
            .position(x: particle.x, y: particle.y - offset)
            .opacity(opacity)
            .onAppear {
                withAnimation(.easeOut(duration: particle.duration)) {
                    offset = particle.y - particle.targetY
                    opacity = 0
                }
            }
    }
}
// MARK: - Additional Supporting Views
struct SplitFlowVisualization: View {
    let payment: LightningService.ActivePayment?
    let animationProgress: CGFloat
    @Binding var particles: [LightningParticle]
    @State private var pathAnimation: CGFloat = 0
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // Center source point
                Circle()
                    .fill(
                        RadialGradient(
                            colors: [Color.orange, Color.orange.opacity(0.3)],
                            center: .center,
                            startRadius: 5,
                            endRadius: 25
                        )
                    )
                    .frame(width: 50, height: 50)
                    .position(x: geometry.size.width / 2, y: geometry.size.height / 2)
                    .overlay(
                        Image(systemName: "bolt.fill")
                            .foregroundColor(.white)
                            .position(x: geometry.size.width / 2, y: geometry.size.height / 2)
                    )
                // Animated paths to recipients
                if let payment = payment {
                    ForEach(Array(payment.splits.enumerated()), id: \.element.id) { index, split in
                        SplitPathView(
                            split: split,
                            index: index,
                            totalSplits: payment.splits.count,
                            centerPoint: CGPoint(x: geometry.size.width / 2, y: geometry.size.height / 2),
                            geometry: geometry,
                            animationProgress: animationProgress * pathAnimation
                        )
                    }
                }
            }
        }
        .frame(height: 300)
        .onAppear {
            withAnimation(.easeInOut(duration: 1.5)) {
                pathAnimation = 1
            }
        }
    }
}
struct SplitPathView: View {
    let split: LightningService.PaymentSplit
    let index: Int
    let totalSplits: Int
    let centerPoint: CGPoint
    let geometry: GeometryProxy
    let animationProgress: CGFloat
    private var endPoint: CGPoint {
        let angle = (Double(index) / Double(totalSplits)) * 2 * .pi - .pi / 2
        let radius = min(geometry.size.width, geometry.size.height) * 0.35
        return CGPoint(
            x: centerPoint.x + Foundation.cos(angle) * radius,
            y: centerPoint.y + Foundation.sin(angle) * radius
        )
    }
    var body: some View {
        ZStack {
            // Animated path
            Path { path in
                path.move(to: centerPoint)
                let controlPoint = CGPoint(
                    x: (centerPoint.x + endPoint.x) / 2,
                    y: (centerPoint.y + endPoint.y) / 2 - 30
                )
                path.addQuadCurve(to: endPoint, control: controlPoint)
            }
            .trim(from: 0, to: animationProgress)
            .stroke(
                LinearGradient(
                    colors: [split.type.color, split.type.color.opacity(0.3)],
                    startPoint: .leading,
                    endPoint: .trailing
                ),
                style: StrokeStyle(lineWidth: 3, lineCap: .round)
            )
            // Recipient circle
            Circle()
                .fill(split.type.color)
                .frame(width: 60, height: 60)
                .overlay(
                    VStack(spacing: 4) {
                        Image(systemName: split.type.icon)
                            .font(.title3)
                            .foregroundColor(.white)
                        Text("\(split.amount)")
                            .font(.caption2)
                            .fontWeight(.bold)
                            .foregroundColor(.white)
                    }
                )
                .position(endPoint)
                .scaleEffect(animationProgress)
                .opacity(animationProgress)
        }
    }
}
struct SplitProgressRow: View {
    let split: LightningService.PaymentSplit
    let animationProgress: CGFloat
    var body: some View {
        HStack {
            Image(systemName: split.type.icon)
                .font(.title3)
                .foregroundColor(split.type.color)
                .scaleEffect(animationProgress)
            VStack(alignment: .leading, spacing: 4) {
                Text(split.recipientName)
                    .font(.ds.callout)
                    .fontWeight(.medium)
                Text("\(split.amount) sats (\(Int(split.percentage * 100))%)")
                    .font(.ds.caption)
                    .foregroundColor(.ds.textSecondary)
            }
            Spacer()
            statusView
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.ds.surface.opacity(0.5))
                .opacity(animationProgress)
        )
    }
    @ViewBuilder
    private var statusView: some View {
        switch split.status {
        case .pending:
            Image(systemName: "clock.fill")
                .foregroundColor(.orange)
        case .sending:
            ProgressView()
                .progressViewStyle(CircularProgressViewStyle())
                .scaleEffect(0.8)
        case .completed:
            Image(systemName: "checkmark.circle.fill")
                .foregroundColor(.green)
        case .failed:
            Image(systemName: "xmark.circle.fill")
                .foregroundColor(.red)
        }
    }
}
struct TransactionSummaryCard: View {
    let payment: LightningService.ActivePayment
    var body: some View {
        VStack(spacing: 16) {
            HStack {
                Text("Transaction Summary")
                    .font(.ds.headline)
                    .fontWeight(.semibold)
                Spacer()
                Text(payment.timestamp.formatted(.relative(presentation: .named)))
                    .font(.ds.caption)
                    .foregroundColor(.ds.textSecondary)
            }
            Divider()
            // Total amount
            HStack {
                Text("Total Amount")
                    .font(.ds.callout)
                    .foregroundColor(.ds.textSecondary)
                Spacer()
                Text("\(payment.totalAmount) sats")
                    .font(.ds.callout)
                    .fontWeight(.medium)
                    .monospacedDigit()
            }
            // Split details
            ForEach(payment.splits) { split in
                HStack {
                    HStack(spacing: 8) {
                        Image(systemName: split.type.icon)
                            .font(.caption)
                            .foregroundColor(split.type.color)
                        Text(split.recipientName)
                            .font(.ds.caption)
                    }
                    Spacer()
                    Text("\(split.amount) sats")
                        .font(.ds.caption)
                        .monospacedDigit()
                }
            }
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.ds.backgroundSecondary)
        )
    }
}
struct ConfettiParticle: View {
    @State private var offset = CGSize.zero
    @State private var rotation: Double = 0
    @State private var opacity: Double = 1
    private let color = [Color.orange, .yellow, .green, .blue, .purple].randomElement()!
    private let size = CGFloat.random(in: 8...16)
    private let shape = [true, false].randomElement()! // true = circle, false = rectangle
    var body: some View {
        Group {
            if shape {
                Circle()
                    .fill(color)
                    .frame(width: size, height: size)
            } else {
                Rectangle()
                    .fill(color)
                    .frame(width: size, height: size * 0.6)
            }
        }
        .rotationEffect(.degrees(rotation))
        .offset(offset)
        .opacity(opacity)
        .onAppear {
            withAnimation(.easeOut(duration: Double.random(in: 2...3))) {
                offset = CGSize(
                    width: .random(in: -200...200),
                    height: .random(in: -300...100)
                )
                rotation = .random(in: -720...720)
                opacity = 0
            }
        }
    }
}
struct CustomSplitEditorView: View {
    @Binding var configuration: LightningService.SplitConfiguration
    @Environment(\.dismiss) var dismiss
    @State private var authorPercentage: Double = 50
    @State private var highlighterPercentage: Double = 30
    @State private var curatorPercentage: Double = 15
    @State private var platformPercentage: Double = 5
    var body: some View {
        NavigationView {
            Form {
                Section("Split Configuration") {
                    VStack(spacing: 20) {
                        SliderRow(
                            label: "Author",
                            value: $authorPercentage,
                            color: .purple
                        )
                        SliderRow(
                            label: "Highlighter",
                            value: $highlighterPercentage,
                            color: .orange
                        )
                        SliderRow(
                            label: "Curator",
                            value: $curatorPercentage,
                            color: .blue
                        )
                        SliderRow(
                            label: "Platform",
                            value: $platformPercentage,
                            color: .gray
                        )
                    }
                    .padding(.vertical)
                }
                Section {
                    HStack {
                        Text("Total")
                            .fontWeight(.medium)
                        Spacer()
                        Text("\(Int(authorPercentage + highlighterPercentage + curatorPercentage + platformPercentage))%")
                            .fontWeight(.bold)
                            .foregroundColor(totalIs100 ? .green : .red)
                    }
                }
            }
            .navigationTitle("Custom Split")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .cancellationAction) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .confirmationAction) {
                    Button("Save") {
                        saveSplit()
                    }
                    .disabled(!totalIs100)
                }
            }
        }
        .onAppear {
            authorPercentage = configuration.author * 100
            highlighterPercentage = configuration.highlighter * 100
            curatorPercentage = configuration.curator * 100
            platformPercentage = configuration.platform * 100
        }
    }
    private var totalIs100: Bool {
        abs((authorPercentage + highlighterPercentage + curatorPercentage + platformPercentage) - 100) < 0.1
    }
    private func saveSplit() {
        configuration = LightningService.SplitConfiguration(
            author: authorPercentage / 100,
            highlighter: highlighterPercentage / 100,
            curator: curatorPercentage / 100,
            platform: platformPercentage / 100
        )
        dismiss()
    }
}
struct SliderRow: View {
    let label: String
    @Binding var value: Double
    let color: Color
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text(label)
                    .font(.ds.callout)
                    .fontWeight(.medium)
                Spacer()
                Text("\(Int(value))%")
                    .font(.ds.callout.monospacedDigit())
                    .fontWeight(.bold)
                    .foregroundColor(color)
            }
            Slider(value: $value, in: 0...100, step: 1)
                .tint(color)
        }
    }
}
// MARK: - Preview
struct LightningPaymentFlowView_Previews: PreviewProvider {
    static var previews: some View {
        LightningPaymentFlowView(
            highlight: HighlightEvent(
                content: "Test highlight",
                context: nil,
                source: nil,
                author: "author_pubkey",
                comment: nil
            ),
            authorProfile: nil,
            highlighterProfile: nil,
            curatorProfile: nil
        )
    }
}
</file>

<file path="Sources/Highlighter/Views/Lightning/LightningWalletView.swift">
import SwiftUI
import NDKSwift
struct LightningWalletView: View {
    @EnvironmentObject var appState: AppState
    @StateObject private var lightning = LightningService()
    @State private var showConnectSheet = false
    @State private var showSplitConfiguration = false
    @State private var selectedTransaction: LightningService.ZapTransaction?
    @State private var pulseAnimation = false
    @State private var balanceRevealAnimation = false
    @State private var connectionString = ""
    @Environment(\.dismiss) var dismiss
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(spacing: .ds.large) {
                    // Wallet Status Card
                    walletStatusCard
                        .premiumEntrance(delay: 0.1)
                    if lightning.isConnected {
                        // Balance Card
                        balanceCard
                            .premiumEntrance(delay: 0.2)
                        // Split Configuration
                        splitConfigurationCard
                            .premiumEntrance(delay: 0.3)
                        // Recent Transactions
                        if !lightning.recentZaps.isEmpty {
                            recentTransactionsSection
                                .premiumEntrance(delay: 0.4)
                        }
                    }
                }
                .padding(.horizontal, .ds.screenPadding)
                .padding(.bottom, 100)
            }
            .background(
                ZStack {
                    DesignSystem.Colors.background
                    MeshGradientBackground()
                        .opacity(0.3)
                        .ignoresSafeArea()
                }
            )
            .navigationTitle("Lightning Wallet")
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
        .sheet(isPresented: $showConnectSheet) {
            ConnectWalletSheet(
                connectionString: $connectionString,
                onConnect: { connection in
                    Task {
                        do {
                            try await lightning.connectWallet(connectionString: connection)
                        } catch {
                        }
                    }
                }
            )
        }
        .sheet(isPresented: $showSplitConfiguration) {
            SplitConfigurationSheet(
                configuration: lightning.splitConfig,
                onSave: { config in
                    lightning.updateSplitConfiguration(config)
                }
            )
        }
        .sheet(item: $selectedTransaction) { transaction in
            TransactionDetailSheet(transaction: transaction)
        }
        .onAppear {
            lightning.setNDK(appState.ndk!, signer: appState.activeSigner)
        }
    }
    // MARK: - Components
    @ViewBuilder
    private var walletStatusCard: some View {
        VStack(spacing: .ds.medium) {
            HStack {
                VStack(alignment: .leading, spacing: .ds.small) {
                    HStack(spacing: .ds.small) {
                        Circle()
                            .fill(lightning.isConnected ? Color.green : Color.red)
                            .frame(width: 10, height: 10)
                            .overlay(
                                Circle()
                                    .stroke(lightning.isConnected ? Color.green : Color.red, lineWidth: 2)
                                    .scaleEffect(pulseAnimation ? 1.5 : 1)
                                    .opacity(pulseAnimation ? 0 : 1)
                            )
                            .onAppear {
                                withAnimation(.easeInOut(duration: 2).repeatForever(autoreverses: false)) {
                                    pulseAnimation = true
                                }
                            }
                        Text(lightning.isConnected ? "Connected" : "Not Connected")
                            .font(.ds.headline)
                            .foregroundColor(.ds.text)
                    }
                    if let walletInfo = lightning.walletInfo {
                        Text(walletInfo.alias)
                            .font(.ds.caption)
                            .foregroundColor(.ds.textSecondary)
                    }
                }
                Spacer()
                Button(action: {
                    if lightning.isConnected {
                        lightning.disconnectWallet()
                    } else {
                        showConnectSheet = true
                    }
                }) {
                    Label(
                        lightning.isConnected ? "Disconnect" : "Connect",
                        systemImage: lightning.isConnected ? "bolt.slash" : "bolt"
                    )
                    .font(.ds.footnoteMedium)
                }
                .unifiedSecondaryButton()
            }
            if let error = lightning.connectionError {
                HStack {
                    Image(systemName: "exclamationmark.triangle")
                        .foregroundColor(.ds.error)
                    Text(error)
                        .font(.ds.caption)
                        .foregroundColor(.ds.error)
                    Spacer()
                }
                .padding(.top, .ds.small)
            }
        }
        .padding(.ds.medium)
        .modernCard()
    }
    private var balanceCard: some View {
        let balanceView = VStack(alignment: .leading, spacing: .ds.micro) {
            Text("Balance")
                .font(.ds.caption)
                .foregroundColor(.ds.textSecondary)
            HStack(alignment: .firstTextBaseline, spacing: .ds.micro) {
                Text("\(lightning.balance.formatted())")
                    .font(.system(size: 36, weight: .bold, design: .rounded))
                    .foregroundColor(.ds.text)
                Text("sats")
                    .font(.ds.body)
                    .foregroundColor(.ds.textSecondary)
            }
        }
        let lightningIcon = Image(systemName: "bolt.fill")
            .font(.system(size: 30))
            .foregroundColor(.orange)
        return VStack(spacing: .ds.medium) {
            HStack {
                balanceView
                Spacer()
                lightningIcon
            }
        }
        .padding(.ds.large)
        .background(
            LinearGradient(
                colors: [
                    Color.orange.opacity(0.1),
                    Color.orange.opacity(0.05)
                ],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        )
        .clipShape(RoundedRectangle(cornerRadius: .ds.large, style: .continuous))
        .modernCard()
    }
    @ViewBuilder
    private var splitConfigurationCard: some View {
        VStack(spacing: .ds.medium) {
            HStack {
                Label("Smart Splits", systemImage: "chart.pie.fill")
                    .font(.ds.headline)
                    .foregroundColor(.ds.text)
                Spacer()
                Button("Configure") {
                    showSplitConfiguration = true
                    HapticManager.shared.impact(.light)
                }
                .font(.ds.footnoteMedium)
                .foregroundColor(.ds.primary)
            }
            // Visual split representation
            HStack(spacing: .ds.small) {
                SplitIndicator(
                    label: "Author",
                    percentage: lightning.splitConfig.authorPercentage,
                    color: .blue
                )
                SplitIndicator(
                    label: "Highlighter",
                    percentage: lightning.splitConfig.highlighterPercentage,
                    color: .orange
                )
                SplitIndicator(
                    label: "Curator",
                    percentage: lightning.splitConfig.curatorPercentage,
                    color: .purple
                )
            }
        }
        .padding(.ds.medium)
        .modernCard()
    }
    @ViewBuilder
    private var recentTransactionsSection: some View {
        VStack(alignment: .leading, spacing: .ds.medium) {
            HStack {
                Label("Recent Zaps", systemImage: "clock.arrow.circlepath")
                    .font(.ds.headline)
                    .foregroundColor(.ds.text)
                Spacer()
            }
            VStack(spacing: .ds.small) {
                ForEach(lightning.recentZaps) { transaction in
                    TransactionRow(
                        transaction: transaction,
                        onTap: {
                            selectedTransaction = transaction
                            HapticManager.shared.impact(.light)
                        }
                    )
                }
            }
        }
    }
}
// MARK: - Supporting Views
struct SplitIndicator: View {
    let label: String
    let percentage: Double
    let color: Color
    @State private var animatedPercentage: Double = 0
    var body: some View {
        VStack(spacing: .ds.micro) {
            ZStack {
                Circle()
                    .stroke(color.opacity(0.2), lineWidth: 4)
                    .frame(width: 60, height: 60)
                Circle()
                    .trim(from: 0, to: animatedPercentage)
                    .stroke(color, style: StrokeStyle(lineWidth: 4, lineCap: .round))
                    .frame(width: 60, height: 60)
                    .rotationEffect(.degrees(-90))
                Text("\(Int(percentage * 100))%")
                    .font(.ds.captionMedium)
                    .foregroundColor(.ds.text)
            }
            Text(label)
                .font(.ds.micro)
                .foregroundColor(.ds.textSecondary)
        }
        .onAppear {
            withAnimation(.spring(response: 0.5, dampingFraction: 0.7)) {
                animatedPercentage = percentage
            }
        }
    }
}
struct TransactionRow: View {
    let transaction: LightningService.ZapTransaction
    let onTap: () -> Void
    @State private var isPressed = false
    var body: some View {
        Button(action: onTap) {
            HStack {
                // Icon with animation
                ZStack {
                    Circle()
                        .fill(Color.orange.opacity(0.1))
                        .frame(width: 40, height: 40)
                    Image(systemName: "bolt.fill")
                        .font(.system(size: 16))
                        .foregroundColor(.orange)
                        .rotationEffect(.degrees(isPressed ? 360 : 0))
                }
                VStack(alignment: .leading, spacing: .ds.micro) {
                    Text(transaction.formattedAmount)
                        .font(.ds.bodyMedium)
                        .foregroundColor(.ds.text)
                    if let comment = transaction.comment {
                        Text(comment)
                            .font(.ds.caption)
                            .foregroundColor(.ds.textSecondary)
                            .lineLimit(1)
                    }
                }
                Spacer()
                VStack(alignment: .trailing, spacing: .ds.micro) {
                    Text(transaction.timestamp.formatted(.relative(presentation: .named)))
                        .font(.ds.caption)
                        .foregroundColor(.ds.textTertiary)
                    HStack(spacing: 2) {
                        ForEach(0..<transaction.splits.count, id: \.self) { _ in
                            Circle()
                                .fill(Color.orange)
                                .frame(width: 4, height: 4)
                        }
                    }
                }
                Image(systemName: "chevron.right")
                    .font(.ds.caption)
                    .foregroundColor(.ds.textTertiary)
            }
            .padding(.ds.base)
            .background(Color.ds.surfaceSecondary)
            .clipShape(RoundedRectangle(cornerRadius: .ds.medium, style: .continuous))
            .scaleEffect(isPressed ? 0.98 : 1)
        }
        .buttonStyle(PlainButtonStyle())
        .onLongPressGesture(minimumDuration: 0, maximumDistance: .infinity) { pressing in
            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                isPressed = pressing
            }
        } perform: {
            onTap()
        }
    }
}
// MARK: - Sheets
struct ConnectWalletSheet: View {
    @Binding var connectionString: String
    let onConnect: (String) -> Void
    @State private var isScanning = false
    @State private var showPasteAnimation = false
    @Environment(\.dismiss) var dismiss
    var body: some View {
        NavigationStack {
            VStack(spacing: .ds.large) {
                // Header illustration
                ZStack {
                    Circle()
                        .fill(
                            LinearGradient(
                                colors: [.orange.opacity(0.2), .orange.opacity(0.05)],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 120, height: 120)
                    Image(systemName: "bolt.circle.fill")
                        .font(.system(size: 60))
                        .foregroundStyle(
                            LinearGradient(
                                colors: [.orange, .yellow],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .symbolEffect(.pulse)
                }
                .padding(.top, .ds.large)
                VStack(spacing: .ds.small) {
                    Text("Connect Your Lightning Wallet")
                        .font(.ds.title2)
                        .foregroundColor(.ds.text)
                    Text("Use Nostr Wallet Connect to link your Lightning wallet")
                        .font(.ds.body)
                        .foregroundColor(.ds.textSecondary)
                        .multilineTextAlignment(.center)
                }
                // Connection string input
                VStack(alignment: .leading, spacing: .ds.small) {
                    Label("Connection String", systemImage: "link")
                        .font(.ds.footnoteMedium)
                        .foregroundColor(.ds.textSecondary)
                    HStack {
                        TextField("nostr+walletconnect://...", text: $connectionString)
                            .textFieldStyle(.plain)
                            .font(.ds.callout)
                        if !connectionString.isEmpty {
                            Button(action: {
                                connectionString = ""
                                HapticManager.shared.impact(.light)
                            }) {
                                Image(systemName: "xmark.circle.fill")
                                    .foregroundColor(.ds.textTertiary)
                            }
                        }
                    }
                    .padding(.ds.base)
                    .background(Color.ds.surfaceSecondary)
                    .clipShape(RoundedRectangle(cornerRadius: .ds.medium, style: .continuous))
                }
                HStack(spacing: .ds.medium) {
                    Button(action: {
                        if let pasteString = UIPasteboard.general.string {
                            connectionString = pasteString
                            showPasteAnimation = true
                            HapticManager.shared.notification(.success)
                            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                                showPasteAnimation = false
                            }
                        }
                    }) {
                        Label("Paste", systemImage: showPasteAnimation ? "checkmark" : "doc.on.clipboard")
                            .frame(maxWidth: .infinity)
                    }
                    .unifiedSecondaryButton()
                    .disabled(UIPasteboard.general.string == nil)
                    Button(action: {
                        isScanning = true
                        HapticManager.shared.impact(.light)
                    }) {
                        Label("Scan QR", systemImage: "qrcode.viewfinder")
                            .frame(maxWidth: .infinity)
                    }
                    .unifiedSecondaryButton()
                }
                Spacer()
                Button(action: {
                    onConnect(connectionString)
                    dismiss()
                }) {
                    Text("Connect Wallet")
                        .frame(maxWidth: .infinity)
                }
                .unifiedPrimaryButton()
                .disabled(connectionString.isEmpty || !connectionString.hasPrefix("nostr+walletconnect://"))
            }
            .padding(.horizontal, .ds.screenPadding)
            .navigationTitle("Connect Wallet")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
        }
    }
}
struct SplitConfigurationSheet: View {
    @State var configuration: LightningService.SplitConfiguration
    let onSave: (LightningService.SplitConfiguration) -> Void
    @State private var showInvalidAlert = false
    @Environment(\.dismiss) var dismiss
    var totalPercentage: Double {
        configuration.authorPercentage + configuration.highlighterPercentage + configuration.curatorPercentage
    }
    var isValid: Bool {
        abs(totalPercentage - 1.0) < 0.001
    }
    var body: some View {
        NavigationStack {
            VStack(spacing: .ds.large) {
                // Visual representation
                ZStack {
                    // Background circle
                    Circle()
                        .fill(Color.ds.surfaceSecondary)
                        .frame(width: 200, height: 200)
                    // Pie chart
                    PieChart(
                        data: [
                            (value: configuration.authorPercentage, color: .blue),
                            (value: configuration.highlighterPercentage, color: .orange),
                            (value: configuration.curatorPercentage, color: .purple)
                        ]
                    )
                    .frame(width: 180, height: 180)
                }
                .padding(.top, .ds.large)
                // Sliders
                VStack(spacing: .ds.medium) {
                    SplitSlider(
                        label: "Author",
                        value: $configuration.authorPercentage,
                        color: .blue
                    )
                    SplitSlider(
                        label: "Highlighter",
                        value: $configuration.highlighterPercentage,
                        color: .orange
                    )
                    SplitSlider(
                        label: "Curator",
                        value: $configuration.curatorPercentage,
                        color: .purple
                    )
                }
                // Total indicator
                HStack {
                    Text("Total")
                        .font(.ds.bodyMedium)
                        .foregroundColor(.ds.text)
                    Spacer()
                    Text("\(Int(totalPercentage * 100))%")
                        .font(.ds.bodyMedium)
                        .foregroundColor(isValid ? .green : .red)
                        .contentTransition(.numericText())
                }
                .padding()
                .background(Color.ds.surfaceSecondary)
                .clipShape(RoundedRectangle(cornerRadius: .ds.medium, style: .continuous))
                if !isValid {
                    HStack {
                        Image(systemName: "exclamationmark.triangle")
                            .foregroundColor(.ds.error)
                        Text("Splits must total 100%")
                            .font(.ds.caption)
                            .foregroundColor(.ds.error)
                        Spacer()
                    }
                }
                Spacer()
                Button(action: {
                    if isValid {
                        onSave(configuration)
                        dismiss()
                    } else {
                        showInvalidAlert = true
                        HapticManager.shared.notification(.error)
                    }
                }) {
                    Text("Save Configuration")
                        .frame(maxWidth: .infinity)
                }
                .unifiedPrimaryButton()
                .disabled(!isValid)
            }
            .padding(.horizontal, .ds.screenPadding)
            .navigationTitle("Configure Splits")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
        }
        .alert("Invalid Configuration", isPresented: $showInvalidAlert) {
            Button("OK") {}
        } message: {
            Text("Please adjust the percentages to total 100%")
        }
    }
}
struct SplitSlider: View {
    let label: String
    @Binding var value: Double
    let color: Color
    var body: some View {
        VStack(alignment: .leading, spacing: .ds.small) {
            HStack {
                Label(label, systemImage: "circle.fill")
                    .font(.ds.bodyMedium)
                    .foregroundColor(.ds.text)
                    .symbolRenderingMode(.multicolor)
                    .foregroundStyle(color, color)
                Spacer()
                Text("\(Int(value * 100))%")
                    .font(.ds.bodyMedium)
                    .foregroundColor(.ds.text)
                    .contentTransition(.numericText())
            }
            Slider(value: $value, in: 0...1, step: 0.05) {
                EmptyView()
            } onEditingChanged: { _ in
                HapticManager.shared.impact(.light)
            }
            .tint(color)
        }
    }
}
struct TransactionDetailSheet: View {
    let transaction: LightningService.ZapTransaction
    @Environment(\.dismiss) var dismiss
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(spacing: .ds.large) {
                    // Header with total amount
                    VStack(spacing: .ds.small) {
                        ZStack {
                            Circle()
                                .fill(
                                    LinearGradient(
                                        colors: [.orange.opacity(0.2), .orange.opacity(0.05)],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                                .frame(width: 100, height: 100)
                            Image(systemName: "bolt.fill")
                                .font(.system(size: 40))
                                .foregroundStyle(
                                    LinearGradient(
                                        colors: [.orange, .yellow],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                        }
                        Text(transaction.formattedAmount)
                            .font(.ds.largeTitle)
                            .foregroundColor(.ds.text)
                        Text(transaction.timestamp.formatted(.dateTime))
                            .font(.ds.caption)
                            .foregroundColor(.ds.textSecondary)
                    }
                    .padding(.top, .ds.large)
                    if let comment = transaction.comment {
                        VStack(alignment: .leading, spacing: .ds.small) {
                            Label("Comment", systemImage: "text.bubble")
                                .font(.ds.footnoteMedium)
                                .foregroundColor(.ds.textSecondary)
                            Text(comment)
                                .font(.ds.body)
                                .foregroundColor(.ds.text)
                                .padding()
                                .frame(maxWidth: .infinity, alignment: .leading)
                                .background(Color.ds.surfaceSecondary)
                                .clipShape(RoundedRectangle(cornerRadius: .ds.medium, style: .continuous))
                        }
                    }
                    // Split breakdown
                    VStack(alignment: .leading, spacing: .ds.medium) {
                        Label("Payment Splits", systemImage: "chart.pie")
                            .font(.ds.headline)
                            .foregroundColor(.ds.text)
                        ForEach(transaction.splits, id: \.paymentHash) { split in
                            SplitDetailRow(split: split, profiles: [:])
                        }
                    }
                }
                .padding(.horizontal, .ds.screenPadding)
                .padding(.bottom, .ds.large)
            }
            .navigationTitle("Transaction Details")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
    }
}
struct SplitDetailRow: View {
    let split: LightningService.SubTransaction
    let profiles: [String: NDKUserProfile]
    var roleIcon: String {
        switch split.role {
        case .author: return "person.text.rectangle"
        case .highlighter: return "highlighter"
        case .curator: return "person.crop.square.filled.and.at.rectangle"
        }
    }
    var roleColor: Color {
        switch split.role {
        case .author: return .blue
        case .highlighter: return .orange
        case .curator: return .purple
        }
    }
    var body: some View {
        HStack {
            ZStack {
                Circle()
                    .fill(roleColor.opacity(0.1))
                    .frame(width: 40, height: 40)
                Image(systemName: roleIcon)
                    .font(.system(size: 16))
                    .foregroundColor(roleColor)
            }
            VStack(alignment: .leading, spacing: .ds.micro) {
                Text(split.role.rawValue.capitalized)
                    .font(.ds.footnoteMedium)
                    .foregroundColor(.ds.text)
                if let profile = profiles[split.recipientPubkey] {
                    Text(profile.displayName ?? PubkeyFormatter.formatShort(split.recipientPubkey))
                        .font(.ds.caption)
                        .foregroundColor(.ds.textSecondary)
                } else {
                    Text(PubkeyFormatter.formatShort(split.recipientPubkey))
                        .font(.ds.caption)
                        .foregroundColor(.ds.textSecondary)
                }
            }
            Spacer()
            Text("\(split.amount) sats")
                .font(.ds.bodyMedium)
                .foregroundColor(.ds.text)
        }
        .padding(.ds.base)
        .background(Color.ds.surfaceSecondary)
        .clipShape(RoundedRectangle(cornerRadius: .ds.medium, style: .continuous))
    }
}
// MARK: - Pie Chart
struct PieChart: View {
    let data: [(value: Double, color: Color)]
    @State private var animationProgress: Double = 0
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                ForEach(0..<data.count, id: \.self) { index in
                    PieSlice(
                        startAngle: startAngle(for: index),
                        endAngle: endAngle(for: index),
                        color: data[index].color
                    )
                    .scaleEffect(animationProgress)
                    .animation(
                        .spring(response: 0.5, dampingFraction: 0.7)
                        .delay(Double(index) * 0.1),
                        value: animationProgress
                    )
                }
            }
            .onAppear {
                animationProgress = 1
            }
        }
    }
    private func startAngle(for index: Int) -> Angle {
        let values = data.prefix(index).map { $0.value }
        let sum = values.reduce(0, +)
        return .degrees(sum * 360 - 90)
    }
    private func endAngle(for index: Int) -> Angle {
        let values = data.prefix(index + 1).map { $0.value }
        let sum = values.reduce(0, +)
        return .degrees(sum * 360 - 90)
    }
}
struct PieSlice: Shape {
    let startAngle: Angle
    let endAngle: Angle
    let color: Color
    func path(in rect: CGRect) -> Path {
        var path = Path()
        let center = CGPoint(x: rect.midX, y: rect.midY)
        let radius = min(rect.width, rect.height) / 2
        path.move(to: center)
        path.addArc(
            center: center,
            radius: radius,
            startAngle: startAngle,
            endAngle: endAngle,
            clockwise: false
        )
        path.closeSubpath()
        return path
    }
}
// MARK: - Preview
#Preview {
    LightningWalletView()
        .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Views/Onboarding/OnboardingView.swift">
import SwiftUI
struct OnboardingView: View {
    @State private var currentPage = 0
    @State private var animateElements = false
    @State private var showImportSheet = false
    @State private var privateKey = ""
    @Binding var hasCompletedOnboarding: Bool
    @EnvironmentObject var appState: AppState
    @Namespace private var namespace
    let pages = OnboardingPage.allPages
    var body: some View {
        ZStack {
            // Dynamic gradient background
            OnboardingGradientBackground(currentPage: currentPage)
            // Subtle ambient background
            Color.black.opacity(0.3)
            VStack(spacing: 0) {
                // Skip button
                HStack {
                    Spacer()
                    if currentPage < pages.count {
                        Button("Skip") {
                            withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
                                currentPage = pages.count
                            }
                        }
                        .font(.ds.bodyMedium)
                        .foregroundColor(.white.opacity(0.8))
                        .padding()
                        .transition(.opacity)
                    }
                }
                .frame(height: 60)
                // Page content
                TabView(selection: $currentPage) {
                    ForEach(pages.indices, id: \.self) { index in
                        OnboardingPageView(
                            page: pages[index],
                            namespace: namespace,
                            isActive: currentPage == index
                        )
                        .tag(index)
                    }
                    // Authentication page
                    OnboardingAuthView(
                        showImportSheet: $showImportSheet,
                        privateKey: $privateKey,
                        isActive: currentPage == pages.count,
                        onComplete: completeOnboarding
                    )
                    .tag(pages.count)
                    .environmentObject(appState)
                }
                .tabViewStyle(PageTabViewStyle(indexDisplayMode: .never))
                .animation(.interactiveSpring(response: 0.5, dampingFraction: 0.8), value: currentPage)
                // Bottom controls
                VStack(spacing: 32) {
                    // Page indicators
                    HStack(spacing: 8) {
                        ForEach(0...pages.count, id: \.self) { index in
                            OnboardingPageIndicator(
                                isActive: currentPage == index,
                                index: index,
                                currentPage: currentPage
                            )
                            .onTapGesture {
                                withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                                    currentPage = index
                                }
                            }
                        }
                    }
                    .padding(.horizontal)
                    // Action button (hide on auth page)
                    if currentPage < pages.count {
                        OnboardingActionButton(
                            title: currentPage == pages.count - 1 ? "Get Started" : "Next",
                            isLastPage: currentPage == pages.count - 1,
                            action: {
                                withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
                                    currentPage += 1
                                    HapticManager.shared.impact(.light)
                                }
                            }
                        )
                        .padding(.horizontal, DesignSystem.Spacing.huge)
                    }
                }
                .padding(.bottom, 50)
            }
        }
        .ignoresSafeArea()
        .preferredColorScheme(.dark)
        .onAppear {
            withAnimation(.easeOut(duration: 1.0)) {
                animateElements = true
            }
        }
        .onChange(of: currentPage) { _ in
            HapticManager.shared.impact(.light)
        }
    }
    private func completeOnboarding() {
        HapticManager.shared.notification(.success)
        withAnimation(.spring(response: 0.6, dampingFraction: 0.8)) {
            hasCompletedOnboarding = true
        }
    }
}
// MARK: - Onboarding Page Model
struct OnboardingPage {
    let title: String
    let subtitle: String
    let icon: String
    let iconColor: Color
    let features: [Feature]
    struct Feature {
        let icon: String
        let text: String
    }
    static let allPages = [
        OnboardingPage(
            title: "Welcome to\nHighlighter",
            subtitle: "Your personal knowledge companion for the decentralized web",
            icon: "highlighter",
            iconColor: .orange,
            features: [
                Feature(icon: "quote.bubble.fill", text: "Capture insights from anywhere"),
                Feature(icon: "sparkles", text: "AI-powered smart highlights"),
                Feature(icon: "person.2.fill", text: "Share with your community")
            ]
        ),
        OnboardingPage(
            title: "Highlight\nWhat Matters",
            subtitle: "Save and organize the best content from articles, notes, and conversations",
            icon: "text.quote",
            iconColor: .purple,
            features: [
                Feature(icon: "wand.and.stars", text: "One-tap highlighting"),
                Feature(icon: "folder.fill", text: "Smart collections"),
                Feature(icon: "magnifyingglass", text: "Powerful search")
            ]
        ),
        OnboardingPage(
            title: "Build Your\nKnowledge Graph",
            subtitle: "Connect ideas, discover patterns, and grow your understanding",
            icon: "brain",
            iconColor: .blue,
            features: [
                Feature(icon: "link", text: "Connect related highlights"),
                Feature(icon: "chart.xyaxis.line", text: "Visualize your learning"),
                Feature(icon: "lightbulb.fill", text: "Surface insights")
            ]
        ),
        OnboardingPage(
            title: "Join the\nConversation",
            subtitle: "Share highlights, discuss ideas, and learn from others",
            icon: "bubble.left.and.bubble.right.fill",
            iconColor: .green,
            features: [
                Feature(icon: "heart.fill", text: "Support great content"),
                Feature(icon: "bolt.fill", text: "Zap creators directly"),
                Feature(icon: "globe", text: "Decentralized & open")
            ]
        )
    ]
}
// MARK: - Page View
struct OnboardingPageView: View {
    let page: OnboardingPage
    let namespace: Namespace.ID
    let isActive: Bool
    @State private var animateIcon = false
    @State private var animateContent = false
    var body: some View {
        VStack(spacing: 48) {
            Spacer()
            // Simplified icon
            ZStack {
                // Subtle background
                Circle()
                    .fill(
                        LinearGradient(
                            colors: [
                                page.iconColor.opacity(0.2),
                                page.iconColor.opacity(0.05)
                            ],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: 100, height: 100)
                // Main icon
                Image(systemName: page.icon)
                    .font(.system(size: 48, weight: .regular))
                    .foregroundColor(.white)
            }
            .scaleEffect(isActive ? 1.0 : 0.8)
            .opacity(isActive ? 1.0 : 0.5)
            .animation(.spring(response: 0.6, dampingFraction: 0.7), value: isActive)
            // Content
            VStack(spacing: 24) {
                // Title
                Text(page.title)
                    .font(.system(size: 42, weight: .bold, design: .rounded))
                    .foregroundColor(.white)
                    .multilineTextAlignment(.center)
                    .fixedSize(horizontal: false, vertical: true)
                    .opacity(animateContent ? 1 : 0)
                    .offset(y: animateContent ? 0 : 20)
                // Subtitle
                Text(page.subtitle)
                    .font(.ds.body)
                    .foregroundColor(.white.opacity(0.8))
                    .multilineTextAlignment(.center)
                    .padding(.horizontal, DesignSystem.Spacing.huge)
                    .fixedSize(horizontal: false, vertical: true)
                    .opacity(animateContent ? 1 : 0)
                    .offset(y: animateContent ? 0 : 20)
                    .animation(.easeOut(duration: 0.6).delay(0.1), value: animateContent)
                // Features
                VStack(alignment: .leading, spacing: 16) {
                    ForEach(Array(page.features.enumerated()), id: \.offset) { index, feature in
                        HStack(spacing: 16) {
                            Image(systemName: feature.icon)
                                .font(.system(size: 20))
                                .foregroundColor(page.iconColor)
                                .frame(width: 32, height: 32)
                                .background(
                                    Circle()
                                        .fill(page.iconColor.opacity(0.2))
                                )
                            Text(feature.text)
                                .font(.ds.callout)
                                .foregroundColor(.white.opacity(0.9))
                            Spacer()
                        }
                        .opacity(animateContent ? 1 : 0)
                        .offset(x: animateContent ? 0 : -20)
                        .animation(
                            .spring(response: 0.5, dampingFraction: 0.7)
                            .delay(Double(index) * 0.1 + 0.2),
                            value: animateContent
                        )
                    }
                }
                .padding(.horizontal, DesignSystem.Spacing.huge * 1.5)
            }
            Spacer()
        }
        .onAppear {
            if isActive {
                animateIcon = true
                withAnimation {
                    animateContent = true
                }
            }
        }
        .onChange(of: isActive) { active in
            if active {
                animateIcon = true
                withAnimation {
                    animateContent = true
                }
            } else {
                animateIcon = false
                animateContent = false
            }
        }
    }
}
// MARK: - Components
struct OnboardingGradientBackground: View {
    let currentPage: Int
    private var gradientColors: [Color] {
        switch currentPage {
        case 0: return [Color.orange.opacity(0.3), Color.pink.opacity(0.2)]
        case 1: return [Color.purple.opacity(0.3), Color.blue.opacity(0.2)]
        case 2: return [Color.blue.opacity(0.3), Color.cyan.opacity(0.2)]
        case 3: return [Color.green.opacity(0.3), Color.teal.opacity(0.2)]
        case 4: return [Color.purple.opacity(0.3), Color.orange.opacity(0.2)]
        default: return [Color.orange.opacity(0.3), Color.pink.opacity(0.2)]
        }
    }
    var body: some View {
        LinearGradient(
            colors: gradientColors + [Color.black],
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
        .animation(.easeInOut(duration: 0.8), value: currentPage)
        .ignoresSafeArea()
    }
}
struct OnboardingPageIndicator: View {
    let isActive: Bool
    let index: Int
    let currentPage: Int
    private var shouldAnimate: Bool {
        abs(currentPage - index) <= 1
    }
    var body: some View {
        Capsule()
            .fill(isActive ? Color.white : Color.white.opacity(0.3))
            .frame(width: isActive ? 32 : 8, height: 8)
            .scaleEffect(shouldAnimate ? 1.0 : 0.8)
            .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isActive)
    }
}
struct OnboardingActionButton: View {
    let title: String
    let isLastPage: Bool
    let action: () -> Void
    @State private var isPressed = false
    @State private var shimmerAnimation = false
    var body: some View {
        Button(action: action) {
            ZStack {
                // Background gradient
                RoundedRectangle(cornerRadius: 16, style: .continuous)
                    .fill(
                        LinearGradient(
                            colors: [
                                isLastPage ? Color.orange : Color.white.opacity(0.2),
                                isLastPage ? Color.orange.opacity(0.8) : Color.white.opacity(0.1)
                            ],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                // Simple border for last page
                if isLastPage {
                    RoundedRectangle(cornerRadius: 16, style: .continuous)
                        .stroke(Color.white.opacity(0.2), lineWidth: 1)
                }
                // Button text
                Text(title)
                    .font(.ds.bodyMedium)
                    .foregroundColor(isLastPage ? .white : .white.opacity(0.9))
            }
            .frame(height: 56)
        }
        .scaleEffect(isPressed ? 0.95 : 1.0)
        .onLongPressGesture(
            minimumDuration: .infinity,
            maximumDistance: .infinity,
            pressing: { pressing in
                withAnimation(.easeInOut(duration: 0.1)) {
                    isPressed = pressing
                }
            },
            perform: {}
        )
        .simultaneousGesture(
            TapGesture().onEnded { _ in
                action()
            }
        )
        .shadow(
            color: isLastPage ? Color.orange.opacity(0.3) : Color.white.opacity(0.1),
            radius: 20,
            y: 10
        )
        .onAppear {
            if isLastPage {
                shimmerAnimation = true
            }
        }
    }
}
// Floating particles removed for cleaner UI
// MARK: - Authentication Page
struct OnboardingAuthView: View {
    @Binding var showImportSheet: Bool
    @Binding var privateKey: String
    let isActive: Bool
    let onComplete: () -> Void
    @EnvironmentObject var appState: AppState
    @State private var animateContent = false
    @State private var isCreatingAccount = false
    var body: some View {
        VStack(spacing: 48) {
            Spacer()
            // Icon and title
            VStack(spacing: 24) {
                ZStack {
                    // Subtle background
                    Circle()
                        .fill(
                            LinearGradient(
                                colors: [
                                    Color.purple.opacity(0.2),
                                    Color.orange.opacity(0.1)
                                ],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 100, height: 100)
                    // Key icon
                    Image(systemName: "key.fill")
                        .font(.system(size: 48, weight: .regular))
                        .foregroundColor(.white)
                }
                .scaleEffect(isActive ? 1.0 : 0.8)
                .opacity(isActive ? 1.0 : 0.5)
                .animation(.spring(response: 0.6, dampingFraction: 0.7), value: isActive)
                VStack(spacing: 16) {
                    Text("Ready to\nGet Started")
                        .font(.system(size: 42, weight: .bold, design: .rounded))
                        .foregroundColor(.white)
                        .multilineTextAlignment(.center)
                        .opacity(animateContent ? 1 : 0)
                        .offset(y: animateContent ? 0 : 20)
                    Text("Create your account or sign in to continue")
                        .font(.ds.body)
                        .foregroundColor(.white.opacity(0.8))
                        .multilineTextAlignment(.center)
                        .padding(.horizontal, DesignSystem.Spacing.huge)
                        .opacity(animateContent ? 1 : 0)
                        .offset(y: animateContent ? 0 : 20)
                        .animation(.easeOut(duration: 0.6).delay(0.1), value: animateContent)
                }
            }
            Spacer()
            // Auth buttons
            VStack(spacing: 16) {
                Button(action: createAccount) {
                    HStack {
                        Image(systemName: "sparkles")
                            .font(.system(size: 20, weight: .medium))
                        Text("Create Account")
                            .font(.ds.bodyMedium)
                    }
                    .foregroundColor(.white)
                    .frame(maxWidth: .infinity)
                    .frame(height: 56)
                    .background(
                        RoundedRectangle(cornerRadius: 16, style: .continuous)
                            .fill(
                                LinearGradient(
                                    colors: [Color.orange, Color.orange.opacity(0.8)],
                                    startPoint: .leading,
                                    endPoint: .trailing
                                )
                            )
                    )
                    .overlay(
                        isCreatingAccount ? 
                        ProgressView()
                            .tint(.white)
                            .scaleEffect(0.8)
                        : nil
                    )
                }
                .disabled(isCreatingAccount)
                .shadow(color: Color.orange.opacity(0.3), radius: 20, y: 10)
                Button(action: { showImportSheet = true }) {
                    Text("I have an account")
                        .font(.ds.bodyMedium)
                        .foregroundColor(.white.opacity(0.9))
                        .frame(maxWidth: .infinity)
                        .frame(height: 56)
                        .background(
                            RoundedRectangle(cornerRadius: 16, style: .continuous)
                                .fill(Color.white.opacity(0.15))
                                .overlay(
                                    RoundedRectangle(cornerRadius: 16, style: .continuous)
                                        .stroke(Color.white.opacity(0.3), lineWidth: 1)
                                )
                        )
                }
            }
            .padding(.horizontal, DesignSystem.Spacing.huge)
            .opacity(animateContent ? 1 : 0)
            .offset(y: animateContent ? 0 : 20)
            .animation(.spring(response: 0.5, dampingFraction: 0.7).delay(0.2), value: animateContent)
            Spacer()
                .frame(height: 50)
        }
        .sheet(isPresented: $showImportSheet) {
            OnboardingImportSheet(privateKey: $privateKey, onImport: importAccount)
        }
        .onAppear {
            if isActive {
                withAnimation {
                    animateContent = true
                }
            }
        }
        .onChange(of: isActive) { active in
            if active {
                withAnimation {
                    animateContent = true
                }
            } else {
                animateContent = false
            }
        }
    }
    private func createAccount() {
        isCreatingAccount = true
        HapticManager.shared.impact(.medium)
        Task {
            do {
                try await appState.createAccount()
                await MainActor.run {
                    HapticManager.shared.notification(.success)
                    onComplete()
                }
            } catch {
                await MainActor.run {
                    isCreatingAccount = false
                    HapticManager.shared.notification(.error)
                }
            }
        }
    }
    private func importAccount() {
        guard !privateKey.isEmpty else { return }
        HapticManager.shared.impact(.medium)
        Task {
            do {
                try await appState.importAccount(nsec: privateKey)
                await MainActor.run {
                    showImportSheet = false
                    privateKey = ""
                    HapticManager.shared.notification(.success)
                    onComplete()
                }
            } catch {
                await MainActor.run {
                    HapticManager.shared.notification(.error)
                }
            }
        }
    }
}
// MARK: - Import Sheet
struct OnboardingImportSheet: View {
    @Binding var privateKey: String
    let onImport: () -> Void
    @Environment(\.dismiss) var dismiss
    @FocusState private var isTextFieldFocused: Bool
    var body: some View {
        NavigationStack {
            ZStack {
                // Background gradient
                LinearGradient(
                    colors: [Color.purple.opacity(0.8), Color.black],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                .ignoresSafeArea()
                VStack(spacing: 24) {
                    // Header
                    VStack(spacing: 16) {
                        Image(systemName: "key.horizontal.fill")
                            .font(.system(size: 48, weight: .medium))
                            .foregroundColor(.white)
                            .padding()
                            .background(
                                Circle()
                                    .fill(Color.white.opacity(0.15))
                            )
                        Text("Import Your Account")
                            .font(.system(size: 28, weight: .bold, design: .rounded))
                            .foregroundColor(.white)
                        Text("Enter your private key to sign in")
                            .font(.ds.body)
                            .foregroundColor(.white.opacity(0.8))
                    }
                    .padding(.top, 32)
                    // Input section
                    VStack(alignment: .leading, spacing: 12) {
                        Text("Private Key")
                            .font(.ds.footnoteMedium)
                            .foregroundColor(.white.opacity(0.6))
                        SecureField("nsec1...", text: $privateKey)
                            .font(.system(.body, design: .monospaced))
                            .padding()
                            .background(
                                RoundedRectangle(cornerRadius: 12, style: .continuous)
                                    .fill(Color.white.opacity(0.1))
                                    .overlay(
                                        RoundedRectangle(cornerRadius: 12, style: .continuous)
                                            .stroke(Color.white.opacity(0.2), lineWidth: 1)
                                    )
                            )
                            .foregroundColor(.white)
                            .tint(.orange)
                            .focused($isTextFieldFocused)
                            .textContentType(.password)
                            .autocapitalization(.none)
                            .disableAutocorrection(true)
                    }
                    .padding(.horizontal, DesignSystem.Spacing.xl)
                    // Security note
                    HStack(spacing: 8) {
                        Image(systemName: "lock.shield.fill")
                            .font(.ds.caption)
                            .foregroundColor(.orange)
                        Text("Your key is stored locally and never leaves your device")
                            .font(.ds.caption)
                            .foregroundColor(.white.opacity(0.6))
                    }
                    .padding(.horizontal, DesignSystem.Spacing.xl)
                    Spacer()
                    // Action buttons
                    VStack(spacing: 12) {
                        Button(action: onImport) {
                            Text("Import Account")
                                .font(.ds.bodyMedium)
                                .foregroundColor(.white)
                                .frame(maxWidth: .infinity)
                                .frame(height: 56)
                                .background(
                                    RoundedRectangle(cornerRadius: 16, style: .continuous)
                                        .fill(
                                            LinearGradient(
                                                colors: [Color.orange, Color.orange.opacity(0.8)],
                                                startPoint: .leading,
                                                endPoint: .trailing
                                            )
                                        )
                                )
                        }
                        .disabled(privateKey.isEmpty)
                        .opacity(privateKey.isEmpty ? 0.6 : 1)
                        .shadow(color: Color.orange.opacity(0.3), radius: 20, y: 10)
                        Button("Cancel") {
                            dismiss()
                        }
                        .font(.ds.bodyMedium)
                        .foregroundColor(.white.opacity(0.8))
                        .frame(height: 44)
                    }
                    .padding(.horizontal, DesignSystem.Spacing.xl)
                    .padding(.bottom, 32)
                }
            }
            .preferredColorScheme(.dark)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button {
                        dismiss()
                    } label: {
                        Image(systemName: "xmark.circle.fill")
                            .font(.system(size: 24))
                            .foregroundColor(.white.opacity(0.3))
                            .background(
                                Circle()
                                    .fill(Color.white.opacity(0.1))
                            )
                    }
                }
            }
        }
        .onAppear {
            isTextFieldFocused = true
        }
    }
}
#Preview {
    OnboardingView(hasCompletedOnboarding: .constant(false))
        .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Views/Profile/EditProfileView.swift">
import SwiftUI
import PhotosUI
import NDKSwift
struct EditProfileView: View {
    @Binding var profile: EnhancedProfileView.EditableProfile
    let onSave: () -> Void
    @Environment(\.dismiss) var dismiss
    @State private var selectedPhotoItem: PhotosPickerItem?
    @State private var selectedBannerItem: PhotosPickerItem?
    @State private var isLoadingPhoto = false
    @State private var isLoadingBanner = false
    @State private var showingDeleteConfirmation = false
    @State private var keyboardHeight: CGFloat = 0
    // Form validation
    @State private var isValidNip05 = true
    @State private var isValidWebsite = true
    @State private var isValidLud16 = true
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(spacing: .ds.large) {
                    // Profile Picture Section
                    profilePictureSection
                    // Banner Section
                    bannerSection
                    // Form Fields
                    VStack(spacing: .ds.medium) {
                        // Display Name
                        FormField(
                            title: "Display Name",
                            text: $profile.displayName,
                            placeholder: "Your name",
                            icon: "person.fill",
                            maxLength: 50
                        )
                        // About/Bio
                        FormField(
                            title: "About",
                            text: $profile.about,
                            placeholder: "Tell us about yourself",
                            icon: "text.alignleft",
                            isMultiline: true,
                            maxLength: 500
                        )
                        // Website
                        FormField(
                            title: "Website",
                            text: $profile.website,
                            placeholder: "https://yourwebsite.com",
                            icon: "globe",
                            keyboardType: .URL,
                            isValid: $isValidWebsite
                        )
                        .onChange(of: profile.website) { value in
                            validateWebsite(value)
                        }
                        // NIP-05 Verification
                        FormField(
                            title: "NIP-05 Identifier",
                            text: $profile.nip05,
                            placeholder: "you@yourdomain.com",
                            icon: "checkmark.seal",
                            keyboardType: .emailAddress,
                            isValid: $isValidNip05
                        )
                        .onChange(of: profile.nip05) { value in
                            validateNip05(value)
                        }
                        // Lightning Address
                        FormField(
                            title: "Lightning Address",
                            text: $profile.lud16,
                            placeholder: "you@wallet.com",
                            icon: "bolt.fill",
                            iconColor: .yellow,
                            keyboardType: .emailAddress,
                            isValid: $isValidLud16
                        )
                        .onChange(of: profile.lud16) { value in
                            validateLud16(value)
                        }
                    }
                    .padding(.horizontal, .ds.screenPadding)
                    // Advanced Options
                    DisclosureGroup {
                        VStack(spacing: .ds.medium) {
                            Button(action: { showingDeleteConfirmation = true }) {
                                Label("Clear Profile Picture", systemImage: "trash")
                                    .font(.ds.body)
                                    .foregroundColor(.red)
                                    .frame(maxWidth: .infinity)
                                    .padding()
                                    .background(
                                        RoundedRectangle(cornerRadius: 12, style: .continuous)
                                            .fill(Color.red.opacity(0.1))
                                    )
                            }
                            Text("Profile changes are published to all connected relays")
                                .font(.ds.caption)
                                .foregroundColor(.ds.textSecondary)
                                .multilineTextAlignment(.center)
                        }
                    } label: {
                        Label("Advanced Options", systemImage: "gearshape")
                            .font(.ds.bodyMedium)
                            .foregroundColor(.ds.text)
                    }
                    .padding(.horizontal, .ds.screenPadding)
                    .padding(.vertical, .ds.small)
                    .background(DesignSystem.Colors.surfaceSecondary)
                    .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
                    .padding(.horizontal, .ds.screenPadding)
                }
                .padding(.vertical, .ds.large)
                .padding(.bottom, keyboardHeight)
            }
            .background(DesignSystem.Colors.background)
            .navigationTitle("Edit Profile")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Save") {
                        saveProfile()
                    }
                    .font(.ds.bodyMedium)
                    .disabled(!isFormValid)
                }
            }
        }
        .onReceive(NotificationCenter.default.publisher(for: UIResponder.keyboardWillShowNotification)) { notification in
            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                keyboardHeight = (notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? CGRect)?.height ?? 0
            }
        }
        .onReceive(NotificationCenter.default.publisher(for: UIResponder.keyboardWillHideNotification)) { _ in
            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                keyboardHeight = 0
            }
        }
        .confirmationDialog("Delete Profile Picture", isPresented: $showingDeleteConfirmation) {
            Button("Delete", role: .destructive) {
                profile.picture = ""
            }
            Button("Cancel", role: .cancel) {}
        } message: {
            Text("Are you sure you want to remove your profile picture?")
        }
    }
    // MARK: - Profile Picture Section
    private var profilePictureSection: some View {
        VStack(spacing: .ds.medium) {
            Text("Profile Picture")
                .font(.ds.footnoteMedium)
                .foregroundColor(.ds.textSecondary)
            PhotosPicker(
                selection: $selectedPhotoItem,
                matching: .images,
                photoLibrary: .shared()
            ) {
                ZStack {
                    if isLoadingPhoto {
                        ProgressView()
                            .progressViewStyle(CircularProgressViewStyle())
                            .frame(width: 120, height: 120)
                            .background(DesignSystem.Colors.surfaceSecondary)
                            .clipShape(Circle())
                    } else if !profile.picture.isEmpty, let url = URL(string: profile.picture) {
                        AsyncImage(url: url) { image in
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                .frame(width: 120, height: 120)
                                .clipShape(Circle())
                        } placeholder: {
                            profilePlaceholder
                        }
                    } else {
                        profilePlaceholder
                    }
                    // Edit overlay
                    Circle()
                        .fill(Color.black.opacity(0.4))
                        .frame(width: 120, height: 120)
                        .overlay(
                            VStack(spacing: 4) {
                                Image(systemName: "camera.fill")
                                    .font(.system(size: 24))
                                Text("Change")
                                    .font(.ds.caption)
                            }
                            .foregroundColor(.white)
                        )
                        .opacity(0.8)
                }
            }
            .onChange(of: selectedPhotoItem) { item in
                Task {
                    await loadPhoto(from: item)
                }
            }
        }
    }
    private var profilePlaceholder: some View {
        Circle()
            .fill(
                LinearGradient(
                    colors: [.orange.opacity(0.3), .pink.opacity(0.3)],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
            )
            .frame(width: 120, height: 120)
            .overlay(
                Image(systemName: "person.fill")
                    .font(.system(size: 40))
                    .foregroundColor(.ds.textSecondary)
            )
    }
    // MARK: - Banner Section
    private var bannerSection: some View {
        VStack(spacing: .ds.medium) {
            Text("Banner")
                .font(.ds.footnoteMedium)
                .foregroundColor(.ds.textSecondary)
            PhotosPicker(
                selection: $selectedBannerItem,
                matching: .images,
                photoLibrary: .shared()
            ) {
                ZStack {
                    if isLoadingBanner {
                        ProgressView()
                            .progressViewStyle(CircularProgressViewStyle())
                            .frame(height: 150)
                            .frame(maxWidth: .infinity)
                            .background(DesignSystem.Colors.surfaceSecondary)
                            .clipShape(RoundedRectangle(cornerRadius: 16, style: .continuous))
                    } else if !profile.banner.isEmpty, let url = URL(string: profile.banner) {
                        AsyncImage(url: url) { image in
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                .frame(height: 150)
                                .frame(maxWidth: .infinity)
                                .clipped()
                                .clipShape(RoundedRectangle(cornerRadius: 16, style: .continuous))
                        } placeholder: {
                            bannerPlaceholder
                        }
                    } else {
                        bannerPlaceholder
                    }
                    // Edit overlay
                    RoundedRectangle(cornerRadius: 16, style: .continuous)
                        .fill(Color.black.opacity(0.4))
                        .frame(height: 150)
                        .overlay(
                            VStack(spacing: 4) {
                                Image(systemName: "photo.fill")
                                    .font(.system(size: 24))
                                Text("Change Banner")
                                    .font(.ds.caption)
                            }
                            .foregroundColor(.white)
                        )
                        .opacity(0.8)
                }
            }
            .padding(.horizontal, .ds.screenPadding)
            .onChange(of: selectedBannerItem) { item in
                Task {
                    await loadBanner(from: item)
                }
            }
        }
    }
    private var bannerPlaceholder: some View {
        RoundedRectangle(cornerRadius: 16, style: .continuous)
            .fill(
                LinearGradient(
                    colors: [.purple.opacity(0.3), .blue.opacity(0.3)],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
            )
            .frame(height: 150)
            .overlay(
                Image(systemName: "photo")
                    .font(.system(size: 40))
                    .foregroundColor(.ds.textSecondary)
            )
    }
    // MARK: - Form Validation
    private var isFormValid: Bool {
        isValidNip05 && isValidWebsite && isValidLud16
    }
    private func validateWebsite(_ url: String) {
        guard !url.isEmpty else {
            isValidWebsite = true
            return
        }
        let pattern = #"^https?://[^\s/$.?#].[^\s]*$"#
        isValidWebsite = url.range(of: pattern, options: .regularExpression) != nil
    }
    private func validateNip05(_ identifier: String) {
        guard !identifier.isEmpty else {
            isValidNip05 = true
            return
        }
        let pattern = #"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"#
        isValidNip05 = identifier.range(of: pattern, options: .regularExpression) != nil
    }
    private func validateLud16(_ address: String) {
        guard !address.isEmpty else {
            isValidLud16 = true
            return
        }
        // Same as email validation for Lightning addresses
        let pattern = #"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"#
        isValidLud16 = address.range(of: pattern, options: .regularExpression) != nil
    }
    // MARK: - Photo Loading
    private func loadPhoto(from item: PhotosPickerItem?) async {
        guard let item = item else { return }
        isLoadingPhoto = true
        do {
            if let data = try await item.loadTransferable(type: Data.self) {
                // Image upload functionality would go here
                // Currently not implemented - requires image hosting service
                await MainActor.run {
                    isLoadingPhoto = false
                }
            }
        } catch {
            await MainActor.run {
                isLoadingPhoto = false
            }
        }
    }
    private func loadBanner(from item: PhotosPickerItem?) async {
        guard let item = item else { return }
        isLoadingBanner = true
        do {
            if let data = try await item.loadTransferable(type: Data.self) {
                // Image upload functionality would go here
                // Currently not implemented - requires image hosting service
                await MainActor.run {
                    isLoadingBanner = false
                }
            }
        } catch {
            await MainActor.run {
                isLoadingBanner = false
            }
        }
    }
    // MARK: - Save Profile
    private func saveProfile() {
        HapticManager.shared.notification(.success)
        onSave()
        dismiss()
    }
}
// MARK: - Form Field Component
struct FormField: View {
    let title: String
    @Binding var text: String
    let placeholder: String
    let icon: String
    var iconColor: Color = .ds.primary
    var keyboardType: UIKeyboardType = .default
    var isMultiline: Bool = false
    var maxLength: Int? = nil
    @Binding var isValid: Bool
    init(
        title: String,
        text: Binding<String>,
        placeholder: String,
        icon: String,
        iconColor: Color = .ds.primary,
        keyboardType: UIKeyboardType = .default,
        isMultiline: Bool = false,
        maxLength: Int? = nil,
        isValid: Binding<Bool> = .constant(true)
    ) {
        self.title = title
        self._text = text
        self.placeholder = placeholder
        self.icon = icon
        self.iconColor = iconColor
        self.keyboardType = keyboardType
        self.isMultiline = isMultiline
        self.maxLength = maxLength
        self._isValid = isValid
    }
    var body: some View {
        VStack(alignment: .leading, spacing: .ds.small) {
            // Header
            HStack {
                Label(title, systemImage: icon)
                    .font(.ds.footnoteMedium)
                    .foregroundColor(.ds.textSecondary)
                    .symbolRenderingMode(.hierarchical)
                Spacer()
                if let maxLength = maxLength {
                    Text("\(text.count)/\(maxLength)")
                        .font(.ds.caption)
                        .foregroundColor(text.count > maxLength ? .red : .ds.textTertiary)
                }
            }
            // Input field
            Group {
                if isMultiline {
                    TextEditor(text: $text)
                        .font(.ds.body)
                        .foregroundColor(.ds.text)
                        .scrollContentBackground(.hidden)
                        .background(Color.clear)
                        .frame(minHeight: 100)
                        .padding(.horizontal, 12)
                        .padding(.vertical, 8)
                } else {
                    TextField(placeholder, text: $text)
                        .font(.ds.body)
                        .foregroundColor(.ds.text)
                        .keyboardType(keyboardType)
                        .textInputAutocapitalization(.never)
                        .autocorrectionDisabled()
                        .padding(.horizontal, 16)
                        .padding(.vertical, 12)
                }
            }
            .background(
                RoundedRectangle(cornerRadius: 12, style: .continuous)
                    .fill(DesignSystem.Colors.surfaceSecondary)
                    .overlay(
                        RoundedRectangle(cornerRadius: 12, style: .continuous)
                            .stroke(
                                isValid ? Color.clear : Color.red.opacity(0.5),
                                lineWidth: 1
                            )
                    )
            )
            .onChange(of: text) { newValue in
                if let maxLength = maxLength, newValue.count > maxLength {
                    text = String(newValue.prefix(maxLength))
                }
            }
            // Error message
            if !isValid {
                Text("Please enter a valid \(title.lowercased())")
                    .font(.ds.caption)
                    .foregroundColor(.red)
            }
        }
    }
}
</file>

<file path="Sources/Highlighter/Views/Profile/EnhancedProfileView.swift">
import SwiftUI
import NDKSwift
import PhotosUI
struct EnhancedProfileView: View {
    @EnvironmentObject var appState: AppState
    @State private var selectedTab = ProfileTab.highlights
    @State private var userHighlights: [HighlightEvent] = []
    @State private var userCurations: [ArticleCuration] = []
    @State private var isLoading = true
    @State private var showSettings = false
    @State private var showEditProfile = false
    @State private var showFollowers = false
    @State private var showFollowing = false
    @State private var headerOffset: CGFloat = 0
    @State private var profileHeaderHeight: CGFloat = 300
    @State private var currentPubkey: String = ""
    // Stats animation
    @State private var animateStats = false
    @State private var statsValues = StatsValues()
    // Profile editing
    @State private var editedProfile = EditableProfile()
    enum ProfileTab: String, CaseIterable {
        case highlights = "Highlights"
        case curations = "Curations"
        case activity = "Activity"
        var icon: String {
            switch self {
            case .highlights: return "highlighter"
            case .curations: return "books.vertical"
            case .activity: return "bolt.heart"
            }
        }
    }
    struct StatsValues {
        var highlights: Int = 0
        var curations: Int = 0
        var followers: Int = 0
        var following: Int = 0
        var zapsReceived: Int = 0
    }
    struct EditableProfile {
        var displayName: String = ""
        var about: String = ""
        var picture: String = ""
        var banner: String = ""
        var website: String = ""
        var nip05: String = ""
        var lud16: String = ""
    }
    var body: some View {
        NavigationStack {
            ZStack {
                // Background
                DesignSystem.Colors.background
                    .ignoresSafeArea()
                ScrollViewReader { proxy in
                    ScrollView {
                        VStack(spacing: 0) {
                            // Parallax header
                            profileHeader
                                .offset(y: headerOffset > 0 ? -headerOffset : 0)
                                .scaleEffect(headerOffset > 0 ? 1 + headerOffset / 500 : 1)
                            // Content
                            VStack(spacing: .ds.large) {
                                // Enhanced stats with animations
                                animatedStatsView
                                // Modern tab selector
                                modernTabSelector
                                // Tab content
                                tabContent
                                    .transition(.asymmetric(
                                        insertion: .push(from: .trailing).combined(with: .opacity),
                                        removal: .push(from: .leading).combined(with: .opacity)
                                    ))
                            }
                            .padding(.top, .ds.medium)
                            .background(
                                DesignSystem.Colors.background
                                    .clipShape(
                                        UnevenRoundedRectangle(
                                            topLeadingRadius: 32,
                                            topTrailingRadius: 32
                                        )
                                    )
                                    .ignoresSafeArea(edges: .bottom)
                                    .shadow(color: .black.opacity(0.1), radius: 20, y: -10)
                            )
                        }
                        .background(GeometryReader { geo in
                            Color.clear.preference(
                                key: ScrollOffsetPreferenceKey.self,
                                value: geo.frame(in: .named("scroll")).minY
                            )
                        })
                    }
                    .coordinateSpace(name: "scroll")
                    .onPreferenceChange(ScrollOffsetPreferenceKey.self) { value in
                        headerOffset = value
                    }
                }
            }
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    if headerOffset < -100 {
                        Text(appState.currentUserProfile?.displayName ?? "Profile")
                            .font(.ds.headline)
                            .transition(.opacity)
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    HStack(spacing: 12) {
                        Button(action: { showEditProfile = true }) {
                            Image(systemName: "pencil.circle")
                                .font(.system(size: 20))
                                .foregroundColor(.ds.text)
                                .symbolRenderingMode(.hierarchical)
                        }
                        .magneticHover()
                        Button(action: { showSettings = true }) {
                            Image(systemName: "gearshape")
                                .font(.system(size: 20))
                                .foregroundColor(.ds.text)
                                .symbolRenderingMode(.hierarchical)
                        }
                        .magneticHover()
                    }
                }
            }
            .refreshable {
                await loadUserContent()
            }
        }
        .task {
            if let signer = appState.activeSigner {
                do {
                    currentPubkey = try await signer.pubkey
                } catch {
                }
            }
            await loadUserContent()
        }
        .sheet(isPresented: $showEditProfile) {
            EditProfileView(profile: $editedProfile, onSave: saveProfile)
        }
        .sheet(isPresented: $showSettings) {
            SettingsView()
        }
        .sheet(isPresented: $showFollowers) {
            FollowersListView(pubkey: currentPubkey)
        }
        .sheet(isPresented: $showFollowing) {
            FollowingListView(pubkey: currentPubkey)
        }
    }
    // MARK: - Profile Header
    private var profileHeader: some View {
        ZStack(alignment: .bottom) {
            // Banner image with gradient overlay
            if let banner = appState.currentUserProfile?.banner,
               let url = URL(string: banner) {
                AsyncImage(url: url) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .frame(height: profileHeaderHeight)
                        .clipped()
                        .overlay(
                            LinearGradient(
                                colors: [
                                    Color.black.opacity(0),
                                    Color.black.opacity(0.6)
                                ],
                                startPoint: .top,
                                endPoint: .bottom
                            )
                        )
                } placeholder: {
                    bannerPlaceholder
                }
            } else {
                bannerPlaceholder
            }
            // Profile info overlay
            VStack(spacing: .ds.medium) {
                // Avatar with edit button
                ZStack(alignment: .bottomTrailing) {
                    if let picture = appState.currentUserProfile?.picture,
                       let url = URL(string: picture) {
                        AsyncImage(url: url) { image in
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                .frame(width: 100, height: 100)
                                .clipShape(Circle())
                                .overlay(
                                    Circle()
                                        .stroke(Color.white, lineWidth: 4)
                                )
                                .shadow(radius: 10)
                        } placeholder: {
                            avatarPlaceholder
                        }
                    } else {
                        avatarPlaceholder
                    }
                    // Verified badge if NIP-05
                    if appState.currentUserProfile?.nip05 != nil {
                        Image(systemName: "checkmark.seal.fill")
                            .font(.system(size: 24))
                            .foregroundStyle(.white, Color.blue)
                            .background(Circle().fill(Color.white).frame(width: 28, height: 28))
                            .offset(x: 5, y: 5)
                    }
                }
                // Name and bio
                VStack(spacing: .ds.small) {
                    Text(appState.currentUserProfile?.displayName ?? "Anonymous")
                        .font(.system(size: 28, weight: .bold))
                        .foregroundColor(.white)
                    if let nip05 = appState.currentUserProfile?.nip05 {
                        Label(nip05, systemImage: "checkmark.seal")
                            .font(.ds.callout)
                            .foregroundColor(.white.opacity(0.9))
                    }
                    if let about = appState.currentUserProfile?.about {
                        Text(about)
                            .font(.ds.body)
                            .foregroundColor(.white.opacity(0.8))
                            .multilineTextAlignment(.center)
                            .lineLimit(3)
                            .padding(.horizontal, .ds.large)
                    }
                }
            }
            .padding(.bottom, .ds.large)
        }
        .frame(height: profileHeaderHeight)
    }
    private var bannerPlaceholder: some View {
        ZStack {
            LinearGradient(
                colors: [
                    Color.purple.opacity(0.8),
                    Color.blue.opacity(0.8)
                ],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            // Animated pattern
            GeometryReader { geo in
                ForEach(0..<5) { i in
                    Circle()
                        .fill(Color.white.opacity(0.1))
                        .frame(width: 150, height: 150)
                        .offset(
                            x: CGFloat.random(in: 0...geo.size.width),
                            y: CGFloat.random(in: 0...geo.size.height)
                        )
                        .blur(radius: 30)
                        .animation(
                            .easeInOut(duration: Double.random(in: 10...20))
                            .repeatForever(autoreverses: true),
                            value: animateStats
                        )
                }
            }
        }
        .frame(height: profileHeaderHeight)
    }
    private var avatarPlaceholder: some View {
        Circle()
            .fill(
                LinearGradient(
                    colors: [.orange, .pink],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
            )
            .frame(width: 100, height: 100)
            .overlay(
                Image(systemName: "person.fill")
                    .font(.system(size: 40))
                    .foregroundColor(.white)
            )
            .overlay(
                Circle()
                    .stroke(Color.white, lineWidth: 4)
            )
            .shadow(radius: 10)
    }
    // MARK: - Stats View
    private var animatedStatsView: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: .ds.medium) {
                AnimatedStatCard(
                    value: statsValues.highlights,
                    label: "Highlights",
                    icon: "highlighter",
                    color: .orange,
                    animate: animateStats
                )
                AnimatedStatCard(
                    value: statsValues.curations,
                    label: "Curations",
                    icon: "books.vertical.fill",
                    color: .purple,
                    animate: animateStats
                )
                AnimatedStatCard(
                    value: statsValues.followers,
                    label: "Followers",
                    icon: "person.2.fill",
                    color: .blue,
                    animate: animateStats,
                    action: { showFollowers = true }
                )
                AnimatedStatCard(
                    value: statsValues.following,
                    label: "Following",
                    icon: "person.2.fill",
                    color: .green,
                    animate: animateStats,
                    action: { showFollowing = true }
                )
                AnimatedStatCard(
                    value: statsValues.zapsReceived,
                    label: "Zaps",
                    icon: "bolt.fill",
                    color: .yellow,
                    animate: animateStats
                )
            }
            .padding(.horizontal, .ds.screenPadding)
        }
        .onAppear {
            withAnimation(.spring(response: 0.6, dampingFraction: 0.7)) {
                animateStats = true
            }
        }
    }
    // MARK: - Tab Selector
    private var modernTabSelector: some View {
        HStack(spacing: 0) {
            ForEach(ProfileTab.allCases, id: \.self) { tab in
                ProfileTabButton(
                    tab: tab,
                    isSelected: selectedTab == tab,
                    action: {
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                            selectedTab = tab
                            HapticManager.shared.impact(.light)
                        }
                    }
                )
            }
        }
        .padding(4)
        .background(
            Capsule()
                .fill(DesignSystem.Colors.surfaceSecondary)
                .shadow(color: .black.opacity(0.05), radius: 10, y: 5)
        )
        .padding(.horizontal, .ds.screenPadding)
    }
    // MARK: - Tab Content
    @ViewBuilder
    private var tabContent: some View {
        switch selectedTab {
        case .highlights:
            HighlightsTabView(highlights: userHighlights, isLoading: isLoading)
        case .curations:
            CurationsTabView(curations: userCurations, isLoading: isLoading)
        case .activity:
            ActivityTabView()
        }
    }
    // MARK: - Data Loading
    private func loadUserContent() async {
        guard let ndk = appState.ndk, let signer = appState.activeSigner else { return }
        isLoading = true
        do {
            let pubkey = try await signer.pubkey
            // Load all data in parallel
            async let highlights = loadHighlights(pubkey: pubkey, ndk: ndk)
            async let curations = loadCurations(pubkey: pubkey, ndk: ndk)
            async let social = loadSocialStats(pubkey: pubkey, ndk: ndk)
            let (highlightsResult, curationsResult, socialResult) = await (highlights, curations, social)
            await MainActor.run {
                userHighlights = highlightsResult
                userCurations = curationsResult
                // Animate stats updates
                withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
                    statsValues.highlights = highlightsResult.count
                    statsValues.curations = curationsResult.count
                    statsValues.followers = socialResult.followers
                    statsValues.following = socialResult.following
                }
                isLoading = false
            }
        } catch {
            await MainActor.run {
                isLoading = false
            }
        }
    }
    private func loadHighlights(pubkey: String, ndk: NDK) async -> [HighlightEvent] {
        let filter = NDKFilter(
            authors: [pubkey],
            kinds: [9802],
            limit: 100
        )
        let dataSource = await ndk.outbox.observe(
            filter: filter,
            maxAge: 300,
            cachePolicy: .cacheWithNetwork
        )
        var events: [HighlightEvent] = []
        for await event in dataSource.events {
            if let highlight = try? HighlightEvent(from: event) {
                events.append(highlight)
                if events.count >= 100 { break }
            }
        }
        return events.sorted { $0.createdAt > $1.createdAt }
    }
    private func loadCurations(pubkey: String, ndk: NDK) async -> [ArticleCuration] {
        let filter = NDKFilter(
            authors: [pubkey],
            kinds: [30004],
            limit: 50
        )
        let dataSource = await ndk.outbox.observe(
            filter: filter,
            maxAge: 600,
            cachePolicy: .cacheWithNetwork
        )
        var events: [ArticleCuration] = []
        for await event in dataSource.events {
            if let curation = try? ArticleCuration(from: event) {
                events.append(curation)
                if events.count >= 50 { break }
            }
        }
        return events.sorted { $0.updatedAt > $1.updatedAt }
    }
    private func loadSocialStats(pubkey: String, ndk: NDK) async -> (followers: Int, following: Int) {
        // Load follower count
        let followerFilter = NDKFilter(
            kinds: [3],
            limit: 1000,
            tags: ["p": [pubkey]]
        )
        // Load following count
        let followingFilter = NDKFilter(
            authors: [pubkey],
            kinds: [3],
            limit: 1
        )
        // Fetch followers
        let followerDataSource = await ndk.outbox.observe(
            filter: followerFilter,
            maxAge: 300,
            cachePolicy: .cacheWithNetwork
        )
        var followerCount = 0
        for await _ in followerDataSource.events {
            followerCount += 1
            if followerCount >= 1000 { break }
        }
        // Fetch following
        let followingDataSource = await ndk.outbox.observe(
            filter: followingFilter,
            maxAge: 300,
            cachePolicy: .cacheWithNetwork
        )
        var followingCount = 0
        for await event in followingDataSource.events {
            followingCount = event.tags.filter { $0.first == "p" }.count
            break // We only need the first event
        }
        return (followers: followerCount, following: followingCount)
    }
    private func saveProfile() {
        Task {
            guard let ndk = appState.ndk, let signer = appState.activeSigner else { return }
            do {
                // Create profile metadata
                var metadata: [String: String] = [:]
                if !editedProfile.displayName.isEmpty {
                    metadata["display_name"] = editedProfile.displayName
                    metadata["name"] = editedProfile.displayName
                }
                if !editedProfile.about.isEmpty {
                    metadata["about"] = editedProfile.about
                }
                if !editedProfile.picture.isEmpty {
                    metadata["picture"] = editedProfile.picture
                }
                if !editedProfile.banner.isEmpty {
                    metadata["banner"] = editedProfile.banner
                }
                if !editedProfile.website.isEmpty {
                    metadata["website"] = editedProfile.website
                }
                if !editedProfile.nip05.isEmpty {
                    metadata["nip05"] = editedProfile.nip05
                }
                if !editedProfile.lud16.isEmpty {
                    metadata["lud16"] = editedProfile.lud16
                }
                // Create and publish metadata event (kind 0)
                let metadataJSON = try JSONSerialization.data(withJSONObject: metadata, options: [])
                guard let metadataString = String(data: metadataJSON, encoding: .utf8) else { return }
                // Build and publish event
                let event = try await NDKEventBuilder(ndk: ndk)
                    .kind(0) // Metadata event
                    .content(metadataString)
                    .tags([])
                    .build(signer: signer)
                _ = try await ndk.publish(event)
                // Update local profile
                let pubkey = try await signer.pubkey
                await MainActor.run {
                    appState.profileManager.invalidateCacheForUser(pubkey)
                    Task {
                        await appState.profileManager.loadCurrentUserProfile(for: signer)
                    }
                    HapticManager.shared.notification(.success)
                }
            } catch {
                await MainActor.run {
                    appState.errorMessage = "Failed to save profile: \(error.localizedDescription)"
                    HapticManager.shared.notification(.error)
                }
            }
        }
    }
}
// MARK: - Supporting Views
struct AnimatedStatCard: View {
    let value: Int
    let label: String
    let icon: String
    let color: Color
    let animate: Bool
    var action: (() -> Void)? = nil
    @State private var displayValue: Int = 0
    var body: some View {
        Button(action: { action?() }) {
            VStack(spacing: .ds.small) {
                Image(systemName: icon)
                    .font(.system(size: 24))
                    .foregroundColor(color)
                    .scaleEffect(animate ? 1.0 : 0.5)
                    .rotationEffect(.degrees(animate ? 0 : -180))
                Text("\(displayValue)")
                    .font(.system(size: 28, weight: .bold, design: .rounded))
                    .foregroundColor(.ds.text)
                    .contentTransition(.numericText())
                Text(label)
                    .font(.ds.caption)
                    .foregroundColor(.ds.textSecondary)
            }
            .frame(width: 100, height: 100)
            .background(
                RoundedRectangle(cornerRadius: 20, style: .continuous)
                    .fill(color.opacity(0.1))
                    .overlay(
                        RoundedRectangle(cornerRadius: 20, style: .continuous)
                            .stroke(color.opacity(0.2), lineWidth: 1)
                    )
            )
        }
        .buttonStyle(ScaleButtonStyle())
        .disabled(action == nil)
        .onAppear {
            withAnimation(.spring(response: 0.6, dampingFraction: 0.7).delay(0.2)) {
                displayValue = value
            }
        }
        .onChange(of: value) { oldValue, newValue in
            withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
                displayValue = newValue
            }
        }
    }
}
struct ProfileTabButton: View {
    let tab: EnhancedProfileView.ProfileTab
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            VStack(spacing: 4) {
                Image(systemName: tab.icon)
                    .font(.system(size: 20))
                    .symbolRenderingMode(.hierarchical)
                Text(tab.rawValue)
                    .font(.ds.caption)
            }
            .foregroundColor(isSelected ? .ds.primary : .ds.textSecondary)
            .frame(maxWidth: .infinity)
            .padding(.vertical, .ds.small)
            .background(
                Capsule()
                    .fill(isSelected ? Color.ds.primary.opacity(0.1) : Color.clear)
                    .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isSelected)
            )
        }
    }
}
// MARK: - Tab Views
struct HighlightsTabView: View {
    let highlights: [HighlightEvent]
    let isLoading: Bool
    var body: some View {
        LazyVStack(spacing: .ds.medium) {
            if isLoading {
                ForEach(0..<3, id: \.self) { _ in
                    HighlightCardSkeleton()
                }
            } else if highlights.isEmpty {
                HighlightsEmptyStateView()
                .padding(.top, 40)
            } else {
                ForEach(highlights, id: \.id) { highlight in
                    ModernHighlightCard(highlight: highlight)
                        .premiumEntrance()
                }
            }
        }
        .padding(.horizontal, .ds.screenPadding)
    }
}
struct CurationsTabView: View {
    let curations: [ArticleCuration]
    let isLoading: Bool
    var body: some View {
        LazyVStack(spacing: .ds.medium) {
            if isLoading {
                ForEach(0..<3, id: \.self) { _ in
                    CurationCardSkeleton()
                }
            } else if curations.isEmpty {
                CurationsEmptyStateView()
                .padding(.top, 40)
            } else {
                ForEach(curations, id: \.id) { curation in
                    CurationCard(curation: curation)
                        .premiumEntrance()
                }
            }
        }
        .padding(.horizontal, .ds.screenPadding)
    }
}
struct ActivityTabView: View {
    @EnvironmentObject var appState: AppState
    @State private var recentZaps: [(event: NDKEvent, amount: Int)] = []
    @State private var recentReactions: [NDKEvent] = []
    @State private var isLoading = true
    var body: some View {
        ScrollView {
            VStack(spacing: .ds.large) {
                if isLoading {
                    // Loading state
                    ForEach(0..<3, id: \.self) { _ in
                        ActivityCardSkeleton()
                    }
                } else if recentZaps.isEmpty && recentReactions.isEmpty {
                    ActivityEmptyStateView()
                        .padding(.top, 40)
                } else {
                    // Recent Zaps Section
                    if !recentZaps.isEmpty {
                        VStack(alignment: .leading, spacing: .ds.medium) {
                            Label("Recent Zaps", systemImage: "bolt.fill")
                                .font(.ds.title3)
                                .fontWeight(.semibold)
                                .foregroundColor(.ds.text)
                            ForEach(recentZaps.prefix(10), id: \.event.id) { zap in
                                ZapActivityCard(event: zap.event, amount: zap.amount)
                                    .premiumEntrance()
                            }
                        }
                    }
                    // Recent Reactions Section
                    if !recentReactions.isEmpty {
                        VStack(alignment: .leading, spacing: .ds.medium) {
                            Label("Recent Reactions", systemImage: "heart.fill")
                                .font(.ds.title3)
                                .fontWeight(.semibold)
                                .foregroundColor(.ds.text)
                            ForEach(recentReactions.prefix(10), id: \.id) { reaction in
                                ReactionActivityCard(event: reaction)
                                    .premiumEntrance()
                            }
                        }
                    }
                }
            }
            .padding(.horizontal, .ds.screenPadding)
        }
        .task {
            await loadActivity()
        }
    }
    private func loadActivity() async {
        guard let ndk = appState.ndk, let signer = appState.activeSigner else { return }
        isLoading = true
        do {
            let pubkey = try await signer.pubkey
            // Load zaps (kind 9735)
            let zapFilter = NDKFilter(
                kinds: [9735],
                limit: 50,
                tags: ["p": [pubkey]]
            )
            // Load reactions (kind 7) 
            let reactionFilter = NDKFilter(
                kinds: [7],
                limit: 50,
                tags: ["p": [pubkey]]
            )
            // Fetch data in parallel
            async let zapData = fetchEvents(filter: zapFilter, ndk: ndk)
            async let reactionData = fetchEvents(filter: reactionFilter, ndk: ndk)
            let (zaps, reactions) = await (zapData, reactionData)
            await MainActor.run {
                // Parse zap amounts from events
                recentZaps = zaps.compactMap { event in
                    // Extract amount from zap receipt
                    if let amountTag = event.tags.first(where: { $0.first == "amount" }),
                       amountTag.count > 1,
                       let amount = Int(amountTag[1]) {
                        return (event: event, amount: amount / 1000) // Convert millisats to sats
                    }
                    return nil
                }.sorted { $0.event.createdAt > $1.event.createdAt }
                recentReactions = reactions.sorted { $0.createdAt > $1.createdAt }
                isLoading = false
            }
        } catch {
            await MainActor.run {
                isLoading = false
            }
        }
    }
    private func fetchEvents(filter: NDKFilter, ndk: NDK) async -> [NDKEvent] {
        let dataSource = await ndk.outbox.observe(
            filter: filter,
            maxAge: 300,
            cachePolicy: .cacheWithNetwork
        )
        var events: [NDKEvent] = []
        for await event in dataSource.events {
            events.append(event)
            if events.count >= filter.limit ?? 50 { break }
        }
        return events
    }
}
// MARK: - Skeleton Views
struct HighlightCardSkeleton: View {
    @State private var shimmerOffset: CGFloat = -200
    var body: some View {
        VStack(alignment: .leading, spacing: .ds.base) {
            // Header skeleton
            HStack {
                Circle()
                    .fill(Color.gray.opacity(0.3))
                    .frame(width: 40, height: 40)
                VStack(alignment: .leading, spacing: 4) {
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.gray.opacity(0.3))
                        .frame(width: 120, height: 14)
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.gray.opacity(0.3))
                        .frame(width: 80, height: 12)
                }
                Spacer()
            }
            // Content skeleton
            VStack(alignment: .leading, spacing: 8) {
                RoundedRectangle(cornerRadius: 4)
                    .fill(Color.gray.opacity(0.3))
                    .frame(height: 16)
                RoundedRectangle(cornerRadius: 4)
                    .fill(Color.gray.opacity(0.3))
                    .frame(height: 16)
                RoundedRectangle(cornerRadius: 4)
                    .fill(Color.gray.opacity(0.3))
                    .frame(width: 200, height: 16)
            }
            // Footer skeleton
            HStack {
                ForEach(0..<4, id: \.self) { _ in
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.gray.opacity(0.3))
                        .frame(width: 60, height: 28)
                }
            }
        }
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(.ds.medium)
        .overlay(
            GeometryReader { geometry in
                LinearGradient(
                    colors: [
                        Color.white.opacity(0),
                        Color.white.opacity(0.3),
                        Color.white.opacity(0)
                    ],
                    startPoint: .leading,
                    endPoint: .trailing
                )
                .frame(width: 100)
                .offset(x: shimmerOffset)
                .onAppear {
                    withAnimation(
                        .linear(duration: 1.5)
                        .repeatForever(autoreverses: false)
                    ) {
                        shimmerOffset = geometry.size.width + 100
                    }
                }
            }
            .mask(
                RoundedRectangle(cornerRadius: .ds.medium)
            )
        )
    }
}
struct CurationCardSkeleton: View {
    @State private var shimmerOffset: CGFloat = -200
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Image skeleton
            Rectangle()
                .fill(Color.gray.opacity(0.3))
                .frame(height: 150)
            VStack(alignment: .leading, spacing: .ds.small) {
                // Title skeleton
                RoundedRectangle(cornerRadius: 4)
                    .fill(Color.gray.opacity(0.3))
                    .frame(height: 20)
                // Description skeleton
                VStack(alignment: .leading, spacing: 6) {
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.gray.opacity(0.3))
                        .frame(height: 14)
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.gray.opacity(0.3))
                        .frame(width: 180, height: 14)
                }
                // Stats skeleton
                HStack {
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.gray.opacity(0.3))
                        .frame(width: 80, height: 12)
                    Spacer()
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.gray.opacity(0.3))
                        .frame(width: 60, height: 12)
                }
                .padding(.top, .ds.small)
            }
            .padding()
        }
        .background(Color.gray.opacity(0.1))
        .cornerRadius(.ds.medium)
        .overlay(
            GeometryReader { geometry in
                LinearGradient(
                    colors: [
                        Color.white.opacity(0),
                        Color.white.opacity(0.3),
                        Color.white.opacity(0)
                    ],
                    startPoint: .leading,
                    endPoint: .trailing
                )
                .frame(width: 100)
                .offset(x: shimmerOffset)
                .onAppear {
                    withAnimation(
                        .linear(duration: 1.5)
                        .repeatForever(autoreverses: false)
                    ) {
                        shimmerOffset = geometry.size.width + 100
                    }
                }
            }
            .mask(
                RoundedRectangle(cornerRadius: .ds.medium)
            )
        )
    }
}
// MARK: - Helper Views
// EmptyStateView is defined in CurationManagementView.swift
// ModernHighlightCard is defined in UnifiedCard.swift
struct ScaleButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)
            .animation(.spring(response: 0.2, dampingFraction: 0.8), value: configuration.isPressed)
    }
}
// MARK: - Activity Cards
struct ZapActivityCard: View {
    let event: NDKEvent
    let amount: Int
    @State private var lightningAnimation = false
    var body: some View {
        HStack(spacing: .ds.medium) {
            // Lightning icon
            ZStack {
                Circle()
                    .fill(Color.yellow.opacity(0.2))
                    .frame(width: 44, height: 44)
                    .blur(radius: lightningAnimation ? 8 : 4)
                Image(systemName: "bolt.fill")
                    .font(.system(size: 20))
                    .foregroundColor(.yellow)
                    .scaleEffect(lightningAnimation ? 1.1 : 1)
            }
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text("⚡️ \(amount) sats")
                        .font(.ds.bodyMedium)
                        .foregroundColor(.ds.text)
                    Spacer()
                    Text(RelativeTimeFormatter.relativeTime(from: event.createdAt))
                        .font(.ds.caption)
                        .foregroundColor(.ds.textTertiary)
                }
                HStack(spacing: 4) {
                    Text("from")
                        .font(.ds.caption)
                        .foregroundColor(.ds.textSecondary)
                    Text(PubkeyFormatter.formatCompact(event.pubkey))
                        .font(.ds.caption)
                        .foregroundColor(.ds.primary)
                }
                if !event.content.isEmpty {
                    Text(event.content)
                        .font(.ds.caption)
                        .foregroundColor(.ds.textSecondary)
                        .lineLimit(2)
                }
            }
            .frame(maxWidth: .infinity, alignment: .leading)
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                .fill(Color.yellow.opacity(0.05))
                .overlay(
                    RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                        .stroke(Color.yellow.opacity(0.2), lineWidth: 1)
                )
        )
        .onAppear {
            withAnimation(.easeInOut(duration: 0.8).repeatForever(autoreverses: true)) {
                lightningAnimation = true
            }
        }
    }
}
struct ReactionActivityCard: View {
    let event: NDKEvent
    @State private var heartScale: CGFloat = 1
    var reactionContent: String {
        event.content.isEmpty ? "❤️" : event.content
    }
    var body: some View {
        HStack(spacing: .ds.medium) {
            // Reaction icon
            Text(reactionContent)
                .font(.system(size: 32))
                .scaleEffect(heartScale)
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text("Reaction on your content")
                        .font(.ds.bodyMedium)
                        .foregroundColor(.ds.text)
                    Spacer()
                    Text(RelativeTimeFormatter.relativeTime(from: event.createdAt))
                        .font(.ds.caption)
                        .foregroundColor(.ds.textTertiary)
                }
                HStack(spacing: 4) {
                    Text("from")
                        .font(.ds.caption)
                        .foregroundColor(.ds.textSecondary)
                    Text(PubkeyFormatter.formatCompact(event.pubkey))
                        .font(.ds.caption)
                        .foregroundColor(.ds.primary)
                }
            }
            .frame(maxWidth: .infinity, alignment: .leading)
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                .fill(Color.pink.opacity(0.05))
                .overlay(
                    RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                        .stroke(Color.pink.opacity(0.2), lineWidth: 1)
                )
        )
        .onAppear {
            withAnimation(.spring(response: 0.5, dampingFraction: 0.6)) {
                heartScale = 1.2
            }
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                withAnimation(.spring(response: 0.5, dampingFraction: 0.6)) {
                    heartScale = 1
                }
            }
        }
    }
}
struct ActivityCardSkeleton: View {
    @State private var shimmerOffset: CGFloat = -200
    var body: some View {
        HStack(spacing: .ds.medium) {
            // Icon skeleton
            Circle()
                .fill(Color.gray.opacity(0.3))
                .frame(width: 44, height: 44)
            VStack(alignment: .leading, spacing: 8) {
                // Title skeleton
                RoundedRectangle(cornerRadius: 4)
                    .fill(Color.gray.opacity(0.3))
                    .frame(width: 180, height: 16)
                // Subtitle skeleton
                RoundedRectangle(cornerRadius: 4)
                    .fill(Color.gray.opacity(0.3))
                    .frame(width: 120, height: 12)
            }
            Spacer()
        }
        .padding()
        .background(Color.gray.opacity(0.1))
        .cornerRadius(.ds.medium)
        .overlay(
            GeometryReader { geometry in
                LinearGradient(
                    colors: [
                        Color.white.opacity(0),
                        Color.white.opacity(0.3),
                        Color.white.opacity(0)
                    ],
                    startPoint: .leading,
                    endPoint: .trailing
                )
                .frame(width: 100)
                .offset(x: shimmerOffset)
                .onAppear {
                    withAnimation(
                        .linear(duration: 1.5)
                        .repeatForever(autoreverses: false)
                    ) {
                        shimmerOffset = geometry.size.width + 100
                    }
                }
            }
            .mask(
                RoundedRectangle(cornerRadius: .ds.medium)
            )
        )
    }
}
// MARK: - Empty State Views
struct HighlightsEmptyStateView: View {
    var body: some View {
        VStack(spacing: .ds.large) {
            Image(systemName: "highlighter")
                .font(.system(size: 60))
                .foregroundColor(.orange.opacity(0.5))
                .symbolRenderingMode(.hierarchical)
            VStack(spacing: .ds.small) {
                Text("No Highlights Yet")
                    .font(.ds.title3)
                    .foregroundColor(.ds.text)
                Text("Start highlighting content to build your knowledge base")
                    .font(.ds.body)
                    .foregroundColor(.ds.textSecondary)
                    .multilineTextAlignment(.center)
            }
            Button(action: {
                // Navigate to create highlight
            }) {
                Text("Create First Highlight")
                    .font(.ds.bodyMedium)
                    .foregroundColor(.white)
                    .padding(.horizontal, 24)
                    .padding(.vertical, 12)
                    .background(Color.orange)
                    .clipShape(Capsule())
            }
        }
        .frame(maxWidth: .infinity)
        .padding()
    }
}
struct CurationsEmptyStateView: View {
    var body: some View {
        VStack(spacing: .ds.large) {
            Image(systemName: "books.vertical")
                .font(.system(size: 60))
                .foregroundColor(.purple.opacity(0.5))
                .symbolRenderingMode(.hierarchical)
            VStack(spacing: .ds.small) {
                Text("No Curations Yet")
                    .font(.ds.title3)
                    .foregroundColor(.ds.text)
                Text("Create collections of your favorite articles")
                    .font(.ds.body)
                    .foregroundColor(.ds.textSecondary)
                    .multilineTextAlignment(.center)
            }
            Button(action: {
                // Navigate to create curation
            }) {
                Text("Create First Curation")
                    .font(.ds.bodyMedium)
                    .foregroundColor(.white)
                    .padding(.horizontal, 24)
                    .padding(.vertical, 12)
                    .background(Color.purple)
                    .clipShape(Capsule())
            }
        }
        .frame(maxWidth: .infinity)
        .padding()
    }
}
struct ActivityEmptyStateView: View {
    var body: some View {
        VStack(spacing: .ds.large) {
            Image(systemName: "bolt.heart")
                .font(.system(size: 60))
                .foregroundColor(.yellow.opacity(0.5))
                .symbolRenderingMode(.hierarchical)
            VStack(spacing: .ds.small) {
                Text("Activity Coming Soon")
                    .font(.ds.title3)
                    .foregroundColor(.ds.text)
                Text("See your zaps, reactions, and engagement metrics")
                    .font(.ds.body)
                    .foregroundColor(.ds.textSecondary)
                    .multilineTextAlignment(.center)
            }
        }
        .frame(maxWidth: .infinity)
        .padding()
    }
}
</file>

<file path="Sources/Highlighter/Views/Profile/FollowersListView.swift">
import SwiftUI
import NDKSwift
struct FollowersListView: View {
    let pubkey: String
    @Environment(\.dismiss) var dismiss
    @State private var followers: [UserListItem] = []
    @State private var isLoading = true
    @State private var searchText = ""
    struct UserListItem: Identifiable {
        let id: String
        let pubkey: String
        let profile: NDKUserProfile?
    }
    var filteredFollowers: [UserListItem] {
        if searchText.isEmpty {
            return followers
        }
        return followers.filter { follower in
            let name = follower.profile?.displayName ?? follower.profile?.name ?? ""
            let about = follower.profile?.about ?? ""
            return name.localizedCaseInsensitiveContains(searchText) ||
                   about.localizedCaseInsensitiveContains(searchText)
        }
    }
    var body: some View {
        NavigationStack {
            Group {
                if isLoading {
                    LoadingView()
                } else if followers.isEmpty {
                    FollowersEmptyStateView(
                        icon: "person.2",
                        title: "No Followers Yet",
                        subtitle: "Share great content to build your following"
                    )
                } else {
                    ScrollView {
                        LazyVStack(spacing: 0) {
                            ForEach(filteredFollowers) { follower in
                                UserRow(
                                    pubkey: follower.pubkey,
                                    profile: follower.profile
                                )
                                .premiumEntrance()
                                if follower.id != filteredFollowers.last?.id {
                                    Divider()
                                        .background(DesignSystem.Colors.divider)
                                        .padding(.leading, 72)
                                }
                            }
                        }
                        .padding(.vertical, .ds.small)
                    }
                    .searchable(text: $searchText, prompt: "Search followers")
                }
            }
            .background(DesignSystem.Colors.background)
            .navigationTitle("Followers")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
        .task {
            await loadFollowers()
        }
    }
    private func loadFollowers() async {
        // Implementation would load actual followers
        isLoading = false
    }
}
// MARK: - User Row Component
struct UserRow: View {
    let pubkey: String
    let profile: NDKUserProfile?
    var showFollowButton: Bool = false
    @State private var isFollowing = false
    var body: some View {
        HStack(spacing: .ds.medium) {
            // Avatar
            if let picture = profile?.picture, let url = URL(string: picture) {
                AsyncImage(url: url) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .frame(width: 48, height: 48)
                        .clipShape(Circle())
                } placeholder: {
                    avatarPlaceholder
                }
            } else {
                avatarPlaceholder
            }
            // User info
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(profile?.displayName ?? profile?.name ?? "Anonymous")
                        .font(.ds.bodyMedium)
                        .foregroundColor(.ds.text)
                    if profile?.nip05 != nil {
                        Image(systemName: "checkmark.seal.fill")
                            .font(.system(size: 12))
                            .foregroundColor(.blue)
                    }
                }
                if let about = profile?.about {
                    Text(about)
                        .font(.ds.caption)
                        .foregroundColor(.ds.textSecondary)
                        .lineLimit(1)
                }
            }
            Spacer()
            // Follow button
            if showFollowButton {
                Button(action: toggleFollow) {
                    Text(isFollowing ? "Following" : "Follow")
                        .font(.ds.captionMedium)
                        .foregroundColor(isFollowing ? .ds.text : .white)
                        .padding(.horizontal, 16)
                        .padding(.vertical, 6)
                        .background(
                            Capsule()
                                .fill(isFollowing ? Color.gray.opacity(0.2) : Color.ds.primary)
                        )
                }
                .buttonStyle(ScaleButtonStyle())
            }
        }
        .padding(.horizontal, .ds.screenPadding)
        .padding(.vertical, .ds.small)
        .contentShape(Rectangle())
        .onTapGesture {
            // Navigate to user profile
        }
    }
    private var avatarPlaceholder: some View {
        Circle()
            .fill(
                LinearGradient(
                    colors: [.purple.opacity(0.3), .blue.opacity(0.3)],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
            )
            .frame(width: 48, height: 48)
            .overlay(
                Text(String((profile?.displayName ?? profile?.name ?? "A").prefix(1)))
                    .font(.ds.bodyMedium)
                    .foregroundColor(.white)
            )
    }
    private func toggleFollow() {
        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
            isFollowing.toggle()
            HapticManager.shared.impact(.light)
        }
    }
}
// MARK: - Loading View
struct LoadingView: View {
    var body: some View {
        VStack(spacing: .ds.large) {
            ProgressView()
                .progressViewStyle(CircularProgressViewStyle(tint: .ds.primary))
                .scaleEffect(1.2)
            Text("Loading...")
                .font(.ds.body)
                .foregroundColor(.ds.textSecondary)
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
    }
}
// MARK: - Empty State View
struct FollowersEmptyStateView: View {
    let icon: String
    let title: String
    let subtitle: String
    var body: some View {
        VStack(spacing: .ds.large) {
            Image(systemName: icon)
                .font(.system(size: 60))
                .foregroundColor(.ds.primary.opacity(0.5))
                .symbolRenderingMode(.hierarchical)
            VStack(spacing: .ds.small) {
                Text(title)
                    .font(.ds.title3)
                    .foregroundColor(.ds.text)
                Text(subtitle)
                    .font(.ds.body)
                    .foregroundColor(.ds.textSecondary)
                    .multilineTextAlignment(.center)
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .padding()
    }
}
</file>

<file path="Sources/Highlighter/Views/Profile/FollowingListView.swift">
import SwiftUI
import NDKSwift
struct FollowingListView: View {
    let pubkey: String
    @EnvironmentObject var appState: AppState
    @State private var following: [(pubkey: String, profile: NDKUserProfile?)] = []
    @State private var isLoading = true
    @Environment(\.dismiss) var dismiss
    var body: some View {
        NavigationStack {
            Group {
                if isLoading {
                    LoadingView()
                } else if following.isEmpty {
                    FollowersEmptyStateView(
                        icon: "person.2",
                        title: "Not Following Anyone",
                        subtitle: "This user hasn't followed anyone yet"
                    )
                } else {
                    ScrollView {
                        LazyVStack(spacing: 0) {
                            ForEach(Array(following.enumerated()), id: \.element.pubkey) { index, item in
                                UserRow(
                                    pubkey: item.pubkey,
                                    profile: item.profile,
                                    showFollowButton: true
                                )
                                .premiumEntrance()
                                if index < following.count - 1 {
                                    Divider()
                                        .background(DesignSystem.Colors.divider)
                                        .padding(.leading, 72)
                                }
                            }
                        }
                        .padding(.vertical, .ds.small)
                    }
                }
            }
            .background(DesignSystem.Colors.background)
            .navigationTitle("Following")
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
        .task {
            await loadFollowing()
        }
    }
    private func loadFollowing() async {
        guard let ndk = appState.ndk else { return }
        let filter = NDKFilter(
            authors: [pubkey],
            kinds: [3],
            limit: 1
        )
        let dataSource = await ndk.outbox.observe(
            filter: filter,
            maxAge: 300,
            cachePolicy: .cacheWithNetwork
        )
        var followingList: [(pubkey: String, profile: NDKUserProfile?)] = []
        for await event in dataSource.events {
            // Extract following pubkeys from p tags
            let followingPubkeys = event.tags
                .filter { $0.first == "p" }
                .compactMap { $0.count > 1 ? $0[1] : nil }
            // Load profiles for each pubkey
            for followPubkey in followingPubkeys {
                // Get cached profile if available
                let profile = appState.profileManager.getCachedProfile(for: followPubkey)
                followingList.append((pubkey: followPubkey, profile: profile))
            }
            break // We only need the first event
        }
        await MainActor.run {
            following = followingList
            isLoading = false
        }
    }
}
// Preview
#Preview {
    FollowingListView(pubkey: "testpubkey")
        .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Views/Search/AdvancedSearchView.swift">
import SwiftUI
import NDKSwift
struct AdvancedSearchView: View {
    @EnvironmentObject var appState: AppState
    @State private var searchText = ""
    @State private var selectedCategory = SearchCategory.all
    @State private var searchResults: SearchResults = SearchResults()
    @State private var isSearching = false
    @State private var showFilters = false
    @State private var recentSearches: [String] = []
    @State private var trendingTopics: [TrendingTopic] = []
    @State private var animateResults = false
    @State private var searchFieldFocused = false
    @State private var pulseAnimation = false
    @State private var showAISuggestions = false
    @State private var aiSuggestions: [String] = []
    @FocusState private var isSearchFieldFocused: Bool
    enum SearchCategory: String, CaseIterable {
        case all = "All"
        case highlights = "Highlights"
        case articles = "Articles"
        case users = "Users"
        case curations = "Curations"
        var icon: String {
            switch self {
            case .all: return "magnifyingglass"
            case .highlights: return "highlighter"
            case .articles: return "doc.text"
            case .users: return "person.2"
            case .curations: return "books.vertical"
            }
        }
        var color: Color {
            switch self {
            case .all: return .blue
            case .highlights: return .orange
            case .articles: return .green
            case .users: return .purple
            case .curations: return .pink
            }
        }
    }
    struct SearchResults {
        var highlights: [HighlightEvent] = []
        var articles: [Article] = []
        var users: [(pubkey: String, profile: NDKUserProfile)] = []
        var curations: [ArticleCuration] = []
        var isEmpty: Bool {
            highlights.isEmpty && articles.isEmpty && users.isEmpty && curations.isEmpty
        }
        var totalCount: Int {
            highlights.count + articles.count + users.count + curations.count
        }
    }
    struct TrendingTopic: Identifiable {
        let id = UUID()
        let topic: String
        let count: Int
        let trend: Double // -1 to 1, representing decline to growth
        let icon: String
    }
    var body: some View {
        NavigationStack {
            ZStack {
                // Animated gradient background
                LinearGradient(
                    colors: [
                        DesignSystem.Colors.background,
                        selectedCategory.color.opacity(0.05)
                    ],
                    startPoint: .top,
                    endPoint: .bottom
                )
                .ignoresSafeArea()
                .animation(.easeInOut(duration: 0.8), value: selectedCategory)
                ScrollView {
                    VStack(spacing: 0) {
                        // Advanced search header
                        advancedSearchHeader
                            .padding(.horizontal, DesignSystem.Spacing.large)
                            .padding(.top, DesignSystem.Spacing.medium)
                        // Category selector with animations
                        animatedCategorySelector
                            .padding(.top, DesignSystem.Spacing.large)
                        // Content based on search state
                        if searchText.isEmpty && !isSearching {
                            // Show trending and suggestions
                            VStack(spacing: DesignSystem.Spacing.xl) {
                                if showAISuggestions && !aiSuggestions.isEmpty {
                                    aiSuggestionsSection
                                }
                                trendingSection
                                recentSearchesSection
                            }
                            .padding(.top, DesignSystem.Spacing.xl)
                        } else if isSearching {
                            // Advanced loading state
                            advancedLoadingState
                                .padding(.top, DesignSystem.Spacing.huge)
                        } else {
                            // Search results with animations
                            searchResultsSection
                                .padding(.top, DesignSystem.Spacing.xl)
                        }
                    }
                    .padding(.bottom, DesignSystem.Spacing.huge * 2)
                }
            }
            .navigationBarHidden(true)
            .onAppear {
                loadTrendingTopics()
                loadRecentSearches()
                startPulseAnimation()
            }
            .onChange(of: searchText) { _, newValue in
                if newValue.count > 2 {
                    performSearch()
                }
                if newValue.count > 0 && showAISuggestions {
                    generateAISuggestions()
                }
            }
        }
    }
    // MARK: - Search Header
    private var advancedSearchHeader: some View {
        VStack(spacing: DesignSystem.Spacing.medium) {
            HStack {
                Text("Discover")
                    .font(.system(size: 36, weight: .bold, design: .rounded))
                    .foregroundColor(DesignSystem.Colors.text)
                Spacer()
                // AI Toggle
                Button(action: {
                    withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                        showAISuggestions.toggle()
                        HapticManager.shared.impact(.light)
                        if showAISuggestions {
                            generateAISuggestions()
                        }
                    }
                }) {
                    HStack(spacing: 4) {
                        Image(systemName: "brain")
                            .font(.system(size: 16))
                        Text("AI")
                            .font(.system(size: 14, weight: .medium))
                    }
                    .foregroundColor(showAISuggestions ? .white : DesignSystem.Colors.primary)
                    .padding(.horizontal, 12)
                    .padding(.vertical, 6)
                    .background(
                        Capsule()
                            .fill(showAISuggestions ? DesignSystem.Colors.primary : DesignSystem.Colors.primary.opacity(0.1))
                    )
                    .overlay(
                        Capsule()
                            .stroke(DesignSystem.Colors.primary, lineWidth: showAISuggestions ? 0 : 1)
                    )
                }
                .scaleEffect(pulseAnimation && showAISuggestions ? 1.05 : 1.0)
                // Filter button
                Button(action: {
                    withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                        showFilters.toggle()
                        HapticManager.shared.impact(.light)
                    }
                }) {
                    Image(systemName: "slider.horizontal.3")
                        .font(.system(size: 20))
                        .foregroundColor(DesignSystem.Colors.primary)
                        .rotationEffect(.degrees(showFilters ? 90 : 0))
                        .scaleEffect(showFilters ? 1.1 : 1.0)
                }
            }
            // Sophisticated search field
            HStack(spacing: DesignSystem.Spacing.medium) {
                Image(systemName: "magnifyingglass")
                    .font(.system(size: 18))
                    .foregroundColor(isSearchFieldFocused ? DesignSystem.Colors.primary : DesignSystem.Colors.textSecondary)
                    .rotationEffect(.degrees(isSearchFieldFocused ? 360 : 0))
                    .animation(.spring(response: 0.5, dampingFraction: 0.8), value: isSearchFieldFocused)
                TextField("Search highlights, articles, users...", text: $searchText)
                    .font(.system(size: 17))
                    .foregroundColor(DesignSystem.Colors.text)
                    .focused($isSearchFieldFocused)
                    .onSubmit {
                        performSearch()
                        saveRecentSearch()
                    }
                if !searchText.isEmpty {
                    Button(action: {
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                            searchText = ""
                            searchResults = SearchResults()
                            HapticManager.shared.impact(.light)
                        }
                    }) {
                        Image(systemName: "xmark.circle.fill")
                            .font(.system(size: 18))
                            .foregroundColor(DesignSystem.Colors.textSecondary)
                            .transition(.scale.combined(with: .opacity))
                    }
                }
            }
            .padding(DesignSystem.Spacing.medium)
            .background(
                RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.large, style: .continuous)
                    .fill(DesignSystem.Colors.surfaceSecondary)
                    .overlay(
                        RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.large, style: .continuous)
                            .stroke(
                                isSearchFieldFocused ? DesignSystem.Colors.primary : Color.clear,
                                lineWidth: 2
                            )
                    )
                    .shadow(
                        color: isSearchFieldFocused ? DesignSystem.Colors.primary.opacity(0.3) : DesignSystem.Shadow.small.color,
                        radius: isSearchFieldFocused ? 20 : DesignSystem.Shadow.small.radius,
                        y: DesignSystem.Shadow.small.y
                    )
            )
            .scaleEffect(isSearchFieldFocused ? 1.02 : 1.0)
            .animation(.spring(response: 0.4, dampingFraction: 0.8), value: isSearchFieldFocused)
        }
    }
    // MARK: - Category Selector
    private var animatedCategorySelector: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: DesignSystem.Spacing.small) {
                ForEach(SearchCategory.allCases, id: \.self) { category in
                    SearchCategoryChip(
                        category: category,
                        isSelected: selectedCategory == category,
                        action: {
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                selectedCategory = category
                                HapticManager.shared.impact(.light)
                                if !searchText.isEmpty {
                                    performSearch()
                                }
                            }
                        }
                    )
                }
            }
            .padding(.horizontal, DesignSystem.Spacing.large)
        }
    }
    // MARK: - AI Suggestions
    private var aiSuggestionsSection: some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.medium) {
            HStack {
                Image(systemName: "brain")
                    .font(.system(size: 20))
                    .foregroundColor(DesignSystem.Colors.primary)
                    .symbolEffect(.pulse)
                Text("AI Suggestions")
                    .font(.system(size: 20, weight: .semibold))
                    .foregroundColor(DesignSystem.Colors.text)
                Spacer()
            }
            .padding(.horizontal, DesignSystem.Spacing.large)
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: DesignSystem.Spacing.medium) {
                    ForEach(aiSuggestions, id: \.self) { suggestion in
                        AISuggestionCard(
                            suggestion: suggestion,
                            action: {
                                searchText = suggestion
                                performSearch()
                            }
                        )
                        .transition(.asymmetric(
                            insertion: .scale(scale: 0.8).combined(with: .opacity),
                            removal: .scale(scale: 1.2).combined(with: .opacity)
                        ))
                    }
                }
                .padding(.horizontal, DesignSystem.Spacing.large)
            }
        }
        .transition(.move(edge: .top).combined(with: .opacity))
    }
    // MARK: - Trending Section
    private var trendingSection: some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.medium) {
            Text("Trending Now")
                .font(.system(size: 24, weight: .bold))
                .foregroundColor(DesignSystem.Colors.text)
                .padding(.horizontal, DesignSystem.Spacing.large)
            LazyVGrid(columns: [
                GridItem(.flexible()),
                GridItem(.flexible())
            ], spacing: DesignSystem.Spacing.medium) {
                ForEach(trendingTopics) { topic in
                    TrendingCard(topic: topic) {
                        searchText = topic.topic
                        performSearch()
                    }
                    .searchPremiumEntrance()
                }
            }
            .padding(.horizontal, DesignSystem.Spacing.large)
        }
    }
    // MARK: - Recent Searches
    private var recentSearchesSection: some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.medium) {
            HStack {
                Text("Recent Searches")
                    .font(.system(size: 20, weight: .semibold))
                    .foregroundColor(DesignSystem.Colors.text)
                Spacer()
                Button("Clear") {
                    withAnimation {
                        recentSearches.removeAll()
                        UserDefaults.standard.removeObject(forKey: "recentSearches")
                    }
                }
                .font(.system(size: 14))
                .foregroundColor(DesignSystem.Colors.primary)
            }
            .padding(.horizontal, DesignSystem.Spacing.large)
            VStack(spacing: DesignSystem.Spacing.small) {
                ForEach(recentSearches, id: \.self) { search in
                    RecentSearchRow(search: search) {
                        searchText = search
                        performSearch()
                    }
                }
            }
        }
        .opacity(recentSearches.isEmpty ? 0 : 1)
    }
    // MARK: - Search Results
    private var searchResultsSection: some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.xl) {
            if !searchResults.isEmpty {
                // Results header with count
                HStack {
                    Text("\(searchResults.totalCount) Results")
                        .font(.system(size: 20, weight: .semibold))
                        .foregroundColor(DesignSystem.Colors.text)
                    Spacer()
                    // Sort options
                    Menu {
                        Button("Most Recent", action: {})
                        Button("Most Popular", action: {})
                        Button("Most Relevant", action: {})
                    } label: {
                        HStack(spacing: 4) {
                            Text("Sort")
                                .font(.system(size: 14))
                            Image(systemName: "chevron.down")
                                .font(.system(size: 12))
                        }
                        .foregroundColor(DesignSystem.Colors.primary)
                    }
                }
                .padding(.horizontal, DesignSystem.Spacing.large)
                // Results by category
                if selectedCategory == .all || selectedCategory == .highlights {
                    if !searchResults.highlights.isEmpty {
                        ResultSection(
                            title: "Highlights",
                            icon: "highlighter",
                            color: .orange,
                            count: searchResults.highlights.count
                        ) {
                            ForEach(searchResults.highlights, id: \.id) { highlight in
                                SearchResultHighlightCard(highlight: highlight)
                                    .searchPremiumEntrance()
                            }
                        }
                    }
                }
                if selectedCategory == .all || selectedCategory == .articles {
                    if !searchResults.articles.isEmpty {
                        ResultSection(
                            title: "Articles",
                            icon: "doc.text",
                            color: .green,
                            count: searchResults.articles.count
                        ) {
                            ForEach(searchResults.articles, id: \.id) { article in
                                SearchResultArticleCard(article: article)
                                    .searchPremiumEntrance()
                            }
                        }
                    }
                }
                if selectedCategory == .all || selectedCategory == .users {
                    if !searchResults.users.isEmpty {
                        ResultSection(
                            title: "Users",
                            icon: "person.2",
                            color: .purple,
                            count: searchResults.users.count
                        ) {
                            ForEach(searchResults.users, id: \.pubkey) { userInfo in
                                SearchResultUserCard(pubkey: userInfo.pubkey, user: userInfo.profile)
                                    .searchPremiumEntrance()
                            }
                        }
                    }
                }
            } else {
                // Empty state
                emptySearchState
            }
        }
    }
    // MARK: - Loading State
    private var advancedLoadingState: some View {
        VStack(spacing: DesignSystem.Spacing.xl) {
            // Animated search icon
            ZStack {
                ForEach(0..<3) { index in
                    Circle()
                        .stroke(DesignSystem.Colors.primary.opacity(0.3 - Double(index) * 0.1), lineWidth: 2)
                        .frame(width: 80 + CGFloat(index * 20), height: 80 + CGFloat(index * 20))
                        .scaleEffect(animateResults ? 1.2 : 0.8)
                        .opacity(animateResults ? 0 : 1)
                        .animation(
                            .easeInOut(duration: 1.5)
                            .repeatForever(autoreverses: false)
                            .delay(Double(index) * 0.2),
                            value: animateResults
                        )
                }
                Image(systemName: "magnifyingglass")
                    .font(.system(size: 40))
                    .foregroundColor(DesignSystem.Colors.primary)
                    .rotationEffect(.degrees(animateResults ? 360 : 0))
                    .animation(
                        .linear(duration: 2)
                        .repeatForever(autoreverses: false),
                        value: animateResults
                    )
            }
            Text("Searching...")
                .font(.system(size: 18, weight: .medium))
                .foregroundColor(DesignSystem.Colors.textSecondary)
                .opacity(animateResults ? 1 : 0.5)
                .animation(
                    .easeInOut(duration: 0.8)
                    .repeatForever(autoreverses: true),
                    value: animateResults
                )
        }
        .onAppear {
            animateResults = true
        }
    }
    // MARK: - Empty State
    private var emptySearchState: some View {
        VStack(spacing: DesignSystem.Spacing.large) {
            Image(systemName: "magnifyingglass.circle")
                .font(.system(size: 80))
                .foregroundColor(DesignSystem.Colors.textTertiary)
                .symbolRenderingMode(.hierarchical)
            VStack(spacing: DesignSystem.Spacing.small) {
                Text("No results found")
                    .font(.system(size: 24, weight: .semibold))
                    .foregroundColor(DesignSystem.Colors.text)
                Text("Try adjusting your search or filters")
                    .font(.system(size: 16))
                    .foregroundColor(DesignSystem.Colors.textSecondary)
            }
        }
        .frame(maxWidth: .infinity)
        .padding(.top, DesignSystem.Spacing.huge)
    }
    // MARK: - Helper Methods
    private func performSearch() {
        isSearching = true
        animateResults = false
        Task {
            guard let ndk = appState.ndk, !searchText.isEmpty else {
                await MainActor.run {
                    isSearching = false
                    searchResults = SearchResults()
                }
                return
            }
            do {
                var results = SearchResults()
                // Search based on selected category
                switch selectedCategory {
                case .all:
                    // Search all types in parallel
                    async let highlightResults = searchHighlights(ndk: ndk)
                    async let userResults = searchUsers(ndk: ndk)
                    async let curationResults = searchCurations(ndk: ndk)
                    results.highlights = await highlightResults
                    results.users = await userResults
                    results.curations = await curationResults
                case .highlights:
                    results.highlights = await searchHighlights(ndk: ndk)
                case .articles:
                    // Search for articles (kind: 30023)
                    let articleFilter = NDKFilter(
                        kinds: [30023]
                    )
                    let dataSource = await ndk.outbox.observe(filter: articleFilter)
                    var articles: [Article] = []
                    for await event in dataSource.events {
                        if let article = try? Article(from: event) {
                            // Filter by search text
                            if searchText.isEmpty ||
                               article.title.localizedCaseInsensitiveContains(searchText) ||
                               (article.summary ?? "").localizedCaseInsensitiveContains(searchText) ||
                               article.author.localizedCaseInsensitiveContains(searchText) ||
                               article.content.localizedCaseInsensitiveContains(searchText) {
                                articles.append(article)
                            }
                        }
                    }
                    results.articles = articles
                case .users:
                    results.users = await searchUsers(ndk: ndk)
                case .curations:
                    results.curations = await searchCurations(ndk: ndk)
                }
                await MainActor.run {
                    searchResults = results
                    isSearching = false
                    withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                        animateResults = true
                    }
                }
            } catch {
                await MainActor.run {
                    isSearching = false
                    // Handle error appropriately
                }
            }
        }
    }
    private func searchHighlights(ndk: NDK) async -> [HighlightEvent] {
        let filter = NDKFilter(
            kinds: [9802]
        )
        let dataSource = await ndk.outbox.observe(filter: filter)
        var highlights: [HighlightEvent] = []
        for await event in dataSource.events {
            if let highlight = try? HighlightEvent(from: event) {
                // Filter by search text
                if searchText.isEmpty || 
                   highlight.content.localizedCaseInsensitiveContains(searchText) ||
                   (highlight.source ?? "").localizedCaseInsensitiveContains(searchText) ||
                   highlight.author.localizedCaseInsensitiveContains(searchText) {
                    highlights.append(highlight)
                }
            }
        }
        return highlights
    }
    private func searchUsers(ndk: NDK) async -> [(pubkey: String, profile: NDKUserProfile)] {
        // Search user metadata
        let filter = NDKFilter(
            kinds: [0]
        )
        let dataSource = await ndk.outbox.observe(filter: filter)
        var users: [(pubkey: String, profile: NDKUserProfile)] = []
        for await event in dataSource.events {
            if let profile = try? JSONDecoder().decode(NDKUserProfile.self, from: Data(event.content.utf8)) {
                // Filter by search text
                if searchText.isEmpty ||
                   (profile.name ?? "").localizedCaseInsensitiveContains(searchText) ||
                   (profile.displayName ?? "").localizedCaseInsensitiveContains(searchText) ||
                   (profile.about ?? "").localizedCaseInsensitiveContains(searchText) {
                    users.append((event.pubkey, profile))
                }
            }
        }
        return users
    }
    private func searchCurations(ndk: NDK) async -> [ArticleCuration] {
        let filter = NDKFilter(
            kinds: [30004]
        )
        let dataSource = await ndk.outbox.observe(filter: filter)
        var curations: [ArticleCuration] = []
        for await event in dataSource.events {
            if let curation = try? ArticleCuration(from: event) {
                // Filter by search text
                if searchText.isEmpty ||
                   curation.name.localizedCaseInsensitiveContains(searchText) ||
                   curation.title.localizedCaseInsensitiveContains(searchText) ||
                   (curation.description ?? "").localizedCaseInsensitiveContains(searchText) {
                    curations.append(curation)
                }
            }
        }
        return curations
    }
    private func loadTrendingTopics() {
        Task {
            guard let ndk = appState.ndk else { return }
            do {
                // Fetch recent highlights to analyze trending topics
                let since = Date().addingTimeInterval(-24 * 60 * 60) // Last 24 hours
                let filter = NDKFilter(
                    kinds: [9802],
                    since: Int64(since.timeIntervalSince1970)
                )
                let dataSource = await ndk.outbox.observe(filter: filter)
                var events: [NDKEvent] = []
                for await event in dataSource.events {
                    events.append(event)
                }
                // Extract and count hashtags/topics from highlights
                var topicCounts: [String: Int] = [:]
                for event in events {
                    // Extract hashtags from tags
                    let hashtags = event.tags
                        .filter { $0.first == "t" }
                        .compactMap { $0.count > 1 ? $0[1] : nil }
                    for hashtag in hashtags {
                        topicCounts[hashtag, default: 0] += 1
                    }
                    // Also extract common keywords from content
                    let keywords = extractKeywords(from: event.content)
                    for keyword in keywords {
                        topicCounts[keyword, default: 0] += 1
                    }
                }
                // Convert to TrendingTopic objects and sort by count
                let topics = topicCounts
                    .sorted { $0.value > $1.value }
                    .prefix(6)
                    .map { topic, count in
                        TrendingTopic(
                            topic: topic.capitalized,
                            count: count,
                            trend: Double.random(in: -0.5...1.0), // Calculate real trend in production
                            icon: iconForTopic(topic)
                        )
                    }
                await MainActor.run {
                    trendingTopics = Array(topics)
                }
            } catch {
                // Keep empty trending topics on error
            }
        }
    }
    private func extractKeywords(from content: String) -> [String] {
        // Simple keyword extraction - in production, use NLP
        let commonWords = Set(["the", "a", "an", "and", "or", "but", "in", "on", "at", "to", "for", "of", "with", "by", "from", "as", "is", "was", "are", "were", "been", "be", "have", "has", "had", "do", "does", "did", "will", "would", "could", "should", "may", "might", "must", "can", "this", "that", "these", "those", "i", "you", "he", "she", "it", "we", "they", "them", "their", "what", "which", "who", "when", "where", "why", "how", "not", "no", "yes"])
        let words = content.lowercased()
            .components(separatedBy: .whitespacesAndNewlines)
            .joined(separator: " ")
            .components(separatedBy: .punctuationCharacters)
            .filter { $0.count > 3 && !commonWords.contains($0) }
        // Count word frequency
        var wordCounts: [String: Int] = [:]
        for word in words {
            wordCounts[word, default: 0] += 1
        }
        // Return top keywords
        return wordCounts
            .sorted { $0.value > $1.value }
            .prefix(3)
            .map { $0.key }
    }
    private func iconForTopic(_ topic: String) -> String {
        let lowercased = topic.lowercased()
        switch lowercased {
        case let t where t.contains("bitcoin") || t.contains("btc"):
            return "bitcoinsign.circle"
        case let t where t.contains("lightning") || t.contains("ln"):
            return "bolt"
        case let t where t.contains("nostr"):
            return "network"
        case let t where t.contains("ai") || t.contains("ml") || t.contains("artificial"):
            return "brain"
        case let t where t.contains("privacy") || t.contains("security"):
            return "lock.shield"
        case let t where t.contains("web3") || t.contains("crypto"):
            return "globe"
        default:
            return "tag"
        }
    }
    private func loadRecentSearches() {
        recentSearches = UserDefaults.standard.stringArray(forKey: "recentSearches") ?? []
    }
    private func saveRecentSearch() {
        guard !searchText.isEmpty else { return }
        if !recentSearches.contains(searchText) {
            recentSearches.insert(searchText, at: 0)
            if recentSearches.count > 5 {
                recentSearches.removeLast()
            }
            UserDefaults.standard.set(recentSearches, forKey: "recentSearches")
        }
    }
    private func generateAISuggestions() {
        // Generate contextual suggestions based on trending topics and recent searches
        var suggestions: [String] = []
        // Add suggestions based on trending topics
        for topic in trendingTopics.prefix(3) {
            suggestions.append("Latest \(topic.topic) highlights")
        }
        // Add suggestions based on partial search text
        if !searchText.isEmpty {
            suggestions.append("\(searchText) articles and discussions")
            if searchText.count > 3 {
                suggestions.append("Authors writing about \(searchText)")
            }
        }
        // Add general suggestions if needed
        if suggestions.count < 4 {
            let generalSuggestions = [
                "Popular highlights today",
                "Trending article collections",
                "New voices to follow"
            ]
            suggestions.append(contentsOf: generalSuggestions.prefix(4 - suggestions.count))
        }
        aiSuggestions = Array(suggestions.prefix(4))
    }
    private func startPulseAnimation() {
        withAnimation(
            .easeInOut(duration: 2)
            .repeatForever(autoreverses: true)
        ) {
            pulseAnimation = true
        }
    }
}
// MARK: - Supporting Views
struct SearchCategoryChip: View {
    let category: AdvancedSearchView.SearchCategory
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            HStack(spacing: 6) {
                Image(systemName: category.icon)
                    .font(.system(size: 16))
                Text(category.rawValue)
                    .font(.system(size: 15, weight: .medium))
            }
            .foregroundColor(isSelected ? .white : category.color)
            .padding(.horizontal, 16)
            .padding(.vertical, 10)
            .background(
                Capsule()
                    .fill(isSelected ? category.color : category.color.opacity(0.1))
                    .overlay(
                        Capsule()
                            .stroke(category.color, lineWidth: isSelected ? 0 : 1)
                    )
            )
            .scaleEffect(isSelected ? 1.05 : 1.0)
            .shadow(
                color: isSelected ? category.color.opacity(0.4) : Color.clear,
                radius: 8,
                y: 4
            )
        }
        .magneticHover()
    }
}
struct TrendingCard: View {
    let topic: AdvancedSearchView.TrendingTopic
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            VStack(alignment: .leading, spacing: 8) {
                HStack {
                    Image(systemName: topic.icon)
                        .font(.system(size: 24))
                        .foregroundColor(DesignSystem.Colors.primary)
                    Spacer()
                    // Trend indicator
                    HStack(spacing: 2) {
                        Image(systemName: topic.trend > 0 ? "arrow.up.right" : "arrow.down.right")
                            .font(.system(size: 12, weight: .bold))
                        Text("\(Int(abs(topic.trend * 100)))%")
                            .font(.system(size: 12, weight: .semibold))
                    }
                    .foregroundColor(topic.trend > 0 ? .green : .red)
                }
                Text(topic.topic)
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundColor(DesignSystem.Colors.text)
                Text("\(topic.count) highlights")
                    .font(.system(size: 14))
                    .foregroundColor(DesignSystem.Colors.textSecondary)
            }
            .padding(16)
            .frame(maxWidth: .infinity, alignment: .leading)
            .background(
                RoundedRectangle(cornerRadius: 16, style: .continuous)
                    .fill(DesignSystem.Colors.surface)
                    .shadow(color: DesignSystem.Shadow.small.color, radius: DesignSystem.Shadow.small.radius)
            )
        }
        .magneticHover()
    }
}
struct AISuggestionCard: View {
    let suggestion: String
    let action: () -> Void
    @State private var isPressed = false
    var body: some View {
        Button(action: action) {
            HStack(spacing: 8) {
                Image(systemName: "sparkle")
                    .font(.system(size: 14))
                    .foregroundColor(DesignSystem.Colors.primary)
                Text(suggestion)
                    .font(.system(size: 14, weight: .medium))
                    .foregroundColor(DesignSystem.Colors.text)
                    .lineLimit(1)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 10)
            .background(
                Capsule()
                    .fill(
                        LinearGradient(
                            colors: [
                                DesignSystem.Colors.primary.opacity(0.1),
                                DesignSystem.Colors.secondary.opacity(0.1)
                            ],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .overlay(
                        Capsule()
                            .stroke(
                                LinearGradient(
                                    colors: [DesignSystem.Colors.primary, DesignSystem.Colors.secondary],
                                    startPoint: .leading,
                                    endPoint: .trailing
                                ),
                                lineWidth: 1
                            )
                    )
            )
            .scaleEffect(isPressed ? 0.95 : 1.0)
            .shadow(
                color: DesignSystem.Colors.primary.opacity(0.2),
                radius: 8,
                y: 4
            )
        }
        .buttonStyle(PlainButtonStyle())
        .onLongPressGesture(minimumDuration: 0.1, maximumDistance: .infinity, pressing: { pressing in
            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                isPressed = pressing
            }
            if pressing {
                HapticManager.shared.impact(.light)
            }
        }, perform: {})
    }
}
struct RecentSearchRow: View {
    let search: String
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            HStack {
                Image(systemName: "clock.arrow.circlepath")
                    .font(.system(size: 16))
                    .foregroundColor(DesignSystem.Colors.textSecondary)
                Text(search)
                    .font(.system(size: 16))
                    .foregroundColor(DesignSystem.Colors.text)
                Spacer()
                Image(systemName: "arrow.up.left")
                    .font(.system(size: 14))
                    .foregroundColor(DesignSystem.Colors.textTertiary)
            }
            .padding(.horizontal, DesignSystem.Spacing.large)
            .padding(.vertical, DesignSystem.Spacing.medium)
            .contentShape(Rectangle())
        }
        .buttonStyle(PlainButtonStyle())
    }
}
struct ResultSection<Content: View>: View {
    let title: String
    let icon: String
    let color: Color
    let count: Int
    @ViewBuilder let content: () -> Content
    var body: some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.medium) {
            HStack {
                Image(systemName: icon)
                    .font(.system(size: 20))
                    .foregroundColor(color)
                Text(title)
                    .font(.system(size: 20, weight: .semibold))
                    .foregroundColor(DesignSystem.Colors.text)
                Text("(\(count))")
                    .font(.system(size: 16))
                    .foregroundColor(DesignSystem.Colors.textSecondary)
                Spacer()
            }
            .padding(.horizontal, DesignSystem.Spacing.large)
            content()
                .padding(.horizontal, DesignSystem.Spacing.large)
        }
    }
}
struct SearchResultHighlightCard: View {
    let highlight: HighlightEvent
    @State private var isPressed = false
    var body: some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.small) {
            // Quote with highlight effect
            Text(highlight.content)
                .font(.system(size: 16, weight: .medium))
                .foregroundColor(DesignSystem.Colors.text)
                .lineLimit(3)
                .padding(.horizontal, 4)
                .background(
                    RoundedRectangle(cornerRadius: 4)
                        .fill(DesignSystem.Colors.highlightSubtle.opacity(0.3))
                        .padding(.horizontal, -4)
                )
            HStack {
                EnhancedAsyncProfileImage(pubkey: highlight.author, size: 20)
                Text(PubkeyFormatter.formatCompact(highlight.author))
                    .font(.system(size: 14))
                    .foregroundColor(DesignSystem.Colors.textSecondary)
                Text("·")
                    .foregroundColor(DesignSystem.Colors.textTertiary)
                Text(RelativeTimeFormatter.shortRelativeTime(from: highlight.createdAt))
                    .font(.system(size: 14))
                    .foregroundColor(DesignSystem.Colors.textTertiary)
                Spacer()
            }
        }
        .padding(DesignSystem.Spacing.medium)
        .background(
            RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.medium, style: .continuous)
                .fill(DesignSystem.Colors.surface)
                .shadow(color: DesignSystem.Shadow.small.color, radius: DesignSystem.Shadow.small.radius)
        )
        .scaleEffect(isPressed ? 0.98 : 1.0)
        .onLongPressGesture(minimumDuration: 0.1, maximumDistance: .infinity, pressing: { pressing in
            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                isPressed = pressing
            }
        }, perform: {})
    }
}
struct SearchResultArticleCard: View {
    let article: Article
    var body: some View {
        HStack(spacing: DesignSystem.Spacing.medium) {
            // Thumbnail
            RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.small)
                .fill(
                    LinearGradient(
                        colors: [DesignSystem.Colors.primary.opacity(0.3), DesignSystem.Colors.secondary.opacity(0.3)],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: 60, height: 60)
                .overlay(
                    Image(systemName: "doc.text")
                        .font(.system(size: 24))
                        .foregroundColor(.white)
                )
            VStack(alignment: .leading, spacing: 4) {
                Text(article.title)
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundColor(DesignSystem.Colors.text)
                    .lineLimit(1)
                if let summary = article.summary {
                    Text(summary)
                        .font(.system(size: 14))
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                        .lineLimit(2)
                }
                HStack(spacing: 8) {
                    Image(systemName: "clock")
                        .font(.system(size: 12))
                    Text("\(article.estimatedReadingTime) min")
                        .font(.system(size: 12))
                    Image(systemName: "highlighter")
                        .font(.system(size: 12))
                    Text("\(Int.random(in: 5...25))")
                        .font(.system(size: 12))
                }
                .foregroundColor(DesignSystem.Colors.textTertiary)
            }
            Spacer()
        }
        .padding(DesignSystem.Spacing.medium)
        .background(
            RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.medium, style: .continuous)
                .fill(DesignSystem.Colors.surface)
                .shadow(color: DesignSystem.Shadow.small.color, radius: DesignSystem.Shadow.small.radius)
        )
    }
}
struct SearchResultUserCard: View {
    let pubkey: String
    let user: NDKUserProfile
    var body: some View {
        HStack(spacing: DesignSystem.Spacing.medium) {
            EnhancedAsyncProfileImage(pubkey: pubkey, size: 50)
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(user.displayName ?? "Anonymous")
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundColor(DesignSystem.Colors.text)
                    if user.nip05 != nil {
                        Image(systemName: "checkmark.seal.fill")
                            .font(.system(size: 14))
                            .foregroundColor(DesignSystem.Colors.primary)
                    }
                }
                if let about = user.about {
                    Text(about)
                        .font(.system(size: 14))
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                        .lineLimit(2)
                }
            }
            Spacer()
            Button(action: {}) {
                Text("Follow")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundColor(.white)
                    .padding(.horizontal, 16)
                    .padding(.vertical, 8)
                    .background(DesignSystem.Colors.primary)
                    .clipShape(Capsule())
            }
        }
        .padding(DesignSystem.Spacing.medium)
        .background(
            RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.medium, style: .continuous)
                .fill(DesignSystem.Colors.surface)
                .shadow(color: DesignSystem.Shadow.small.color, radius: DesignSystem.Shadow.small.radius)
        )
    }
}
// MARK: - View Modifiers
extension View {
    func searchPremiumEntrance() -> some View {
        self.modifier(SearchPremiumEntranceModifier())
    }
}
struct SearchPremiumEntranceModifier: ViewModifier {
    @State private var appeared = false
    func body(content: Content) -> some View {
        content
            .opacity(appeared ? 1 : 0)
            .offset(y: appeared ? 0 : 20)
            .onAppear {
                withAnimation(.spring(response: 0.6, dampingFraction: 0.8)) {
                    appeared = true
                }
            }
    }
}
#Preview {
    AdvancedSearchView()
        .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Views/Settings/SettingsView.swift">
import SwiftUI
import NDKSwift
struct SettingsView: View {
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) var dismiss
    @AppStorage("appTheme") private var appTheme = AppTheme.system
    @AppStorage("highlightColor") private var highlightColor = HighlightColor.orange
    @AppStorage("enableHaptics") private var enableHaptics = true
    @AppStorage("autoPlayVideos") private var autoPlayVideos = true
    @AppStorage("compactMode") private var compactMode = false
    @AppStorage("showRelativeTime") private var showRelativeTime = true
    @AppStorage("defaultZapAmount") private var defaultZapAmount = 21
    @State private var showRelayManager = false
    @State private var showPrivacyPolicy = false
    @State private var showAbout = false
    @State private var showDeleteAccount = false
    @State private var showExportData = false
    @State private var animateGradient = false
    enum AppTheme: String, CaseIterable {
        case system = "System"
        case light = "Light"
        case dark = "Dark"
        var icon: String {
            switch self {
            case .system: return "gear"
            case .light: return "sun.max"
            case .dark: return "moon"
            }
        }
    }
    enum HighlightColor: String, CaseIterable {
        case orange = "Orange"
        case purple = "Purple"
        case blue = "Blue"
        case green = "Green"
        case pink = "Pink"
        var color: Color {
            switch self {
            case .orange: return .orange
            case .purple: return .purple
            case .blue: return .blue
            case .green: return .green
            case .pink: return .pink
            }
        }
    }
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(spacing: .ds.large) {
                    // App Icon Header with enhanced animation
                    appIconHeader
                    // Appearance Section
                    SettingsSection(title: "Appearance", icon: "paintbrush") {
                        // Theme Selector
                        VStack(alignment: .leading, spacing: .ds.medium) {
                            Text("Theme")
                                .font(.ds.footnoteMedium)
                                .foregroundColor(.ds.textSecondary)
                            HStack(spacing: .ds.small) {
                                ForEach(AppTheme.allCases, id: \.self) { theme in
                                    ThemeButton(
                                        theme: theme,
                                        isSelected: appTheme == theme,
                                        action: {
                                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                                appTheme = theme
                                                HapticManager.shared.impact(.light)
                                            }
                                        }
                                    )
                                }
                            }
                        }
                        Divider()
                            .background(DesignSystem.Colors.divider)
                        // Highlight Color
                        VStack(alignment: .leading, spacing: .ds.medium) {
                            Text("Highlight Color")
                                .font(.ds.footnoteMedium)
                                .foregroundColor(.ds.textSecondary)
                            ScrollView(.horizontal, showsIndicators: false) {
                                HStack(spacing: .ds.small) {
                                    ForEach(HighlightColor.allCases, id: \.self) { color in
                                        ColorButton(
                                            color: color,
                                            isSelected: highlightColor == color,
                                            action: {
                                                withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                                    highlightColor = color
                                                    HapticManager.shared.impact(.light)
                                                }
                                            }
                                        )
                                    }
                                }
                            }
                        }
                        Divider()
                            .background(DesignSystem.Colors.divider)
                        // Compact Mode Toggle
                        SettingsToggle(
                            title: "Compact Mode",
                            subtitle: "Show more content with smaller UI elements",
                            icon: "rectangle.compress.vertical",
                            isOn: $compactMode
                        )
                    }
                    // General Section
                    SettingsSection(title: "General", icon: "gear") {
                        SettingsToggle(
                            title: "Haptic Feedback",
                            subtitle: "Vibration feedback for interactions",
                            icon: "hand.tap",
                            isOn: $enableHaptics
                        )
                        Divider()
                            .background(DesignSystem.Colors.divider)
                        SettingsToggle(
                            title: "Auto-Play Videos",
                            subtitle: "Automatically play videos in feed",
                            icon: "play.circle",
                            isOn: $autoPlayVideos
                        )
                        Divider()
                            .background(DesignSystem.Colors.divider)
                        SettingsToggle(
                            title: "Relative Time",
                            subtitle: "Show times as '2 hours ago' instead of timestamps",
                            icon: "clock",
                            isOn: $showRelativeTime
                        )
                    }
                    // Lightning Section
                    SettingsSection(title: "Lightning", icon: "bolt.fill", iconColor: .yellow) {
                        VStack(alignment: .leading, spacing: .ds.small) {
                            HStack {
                                Image(systemName: "bolt.circle.fill")
                                    .font(.system(size: 20))
                                    .foregroundColor(.yellow)
                                Text("Default Zap Amount")
                                    .font(.ds.bodyMedium)
                                    .foregroundColor(.ds.text)
                                Spacer()
                                Text("\(defaultZapAmount) sats")
                                    .font(.ds.body)
                                    .foregroundColor(.ds.textSecondary)
                            }
                            // Zap amount slider
                            VStack(spacing: .ds.small) {
                                Slider(value: Binding(
                                    get: { Double(defaultZapAmount) },
                                    set: { defaultZapAmount = Int($0) }
                                ), in: 1...1000, step: 1)
                                .tint(.yellow)
                                // Quick select buttons
                                HStack {
                                    ForEach([21, 100, 500, 1000], id: \.self) { amount in
                                        Button(action: {
                                            withAnimation(.spring(response: 0.2, dampingFraction: 0.8)) {
                                                defaultZapAmount = amount
                                                HapticManager.shared.impact(.light)
                                            }
                                        }) {
                                            Text("\(amount)")
                                                .font(.ds.caption)
                                                .foregroundColor(defaultZapAmount == amount ? .white : .ds.textSecondary)
                                                .padding(.horizontal, 12)
                                                .padding(.vertical, 6)
                                                .background(
                                                    Capsule()
                                                        .fill(defaultZapAmount == amount ? Color.yellow : Color.gray.opacity(0.2))
                                                )
                                        }
                                    }
                                }
                            }
                        }
                        Divider()
                            .background(DesignSystem.Colors.divider)
                        SettingsRow(
                            title: "Lightning Wallet",
                            subtitle: "Configure your wallet connection",
                            icon: "bolt.circle.fill",
                            iconColor: .yellow,
                            action: {
                                // Navigate to lightning wallet settings
                            }
                        )
                    }
                    // Network Section
                    SettingsSection(title: "Network", icon: "network") {
                        SettingsRow(
                            title: "Relay Manager",
                            subtitle: "Manage relay connections",
                            icon: "server.rack",
                            action: { showRelayManager = true }
                        )
                        Divider()
                            .background(DesignSystem.Colors.divider)
                        SettingsRow(
                            title: "Outbox Settings",
                            subtitle: "Configure intelligent relay routing",
                            icon: "tray.and.arrow.up",
                            action: {
                                // Navigate to outbox settings
                            }
                        )
                    }
                    // Data & Privacy Section
                    SettingsSection(title: "Data & Privacy", icon: "lock.shield") {
                        SettingsRow(
                            title: "Export Data",
                            subtitle: "Download all your highlights and content",
                            icon: "square.and.arrow.down",
                            action: { showExportData = true }
                        )
                        Divider()
                            .background(DesignSystem.Colors.divider)
                        SettingsRow(
                            title: "Clear Cache",
                            subtitle: "Free up storage space",
                            icon: "trash",
                            action: clearCache
                        )
                        Divider()
                            .background(DesignSystem.Colors.divider)
                        SettingsRow(
                            title: "Privacy Policy",
                            subtitle: "Learn how we protect your data",
                            icon: "hand.raised",
                            action: { showPrivacyPolicy = true }
                        )
                    }
                    // About Section
                    SettingsSection(title: "About", icon: "info.circle") {
                        SettingsRow(
                            title: "Version",
                            subtitle: "1.0.0 (Build 42)",
                            icon: "app.badge"
                        )
                        Divider()
                            .background(DesignSystem.Colors.divider)
                        SettingsRow(
                            title: "About Highlighter",
                            subtitle: "Learn more about this app",
                            icon: "questionmark.circle",
                            action: { showAbout = true }
                        )
                        Divider()
                            .background(DesignSystem.Colors.divider)
                        SettingsRow(
                            title: "Rate on App Store",
                            subtitle: "Share your feedback",
                            icon: "star",
                            action: {
                                // Open App Store review
                            }
                        )
                    }
                    // Danger Zone
                    VStack(spacing: .ds.medium) {
                        Button(action: { showDeleteAccount = true }) {
                            HStack {
                                Image(systemName: "exclamationmark.triangle")
                                    .font(.system(size: 18))
                                Text("Delete Account")
                                    .font(.ds.bodyMedium)
                            }
                            .foregroundColor(.red)
                            .frame(maxWidth: .infinity)
                            .padding()
                            .background(
                                RoundedRectangle(cornerRadius: 12, style: .continuous)
                                    .fill(Color.red.opacity(0.1))
                                    .overlay(
                                        RoundedRectangle(cornerRadius: 12, style: .continuous)
                                            .stroke(Color.red.opacity(0.3), lineWidth: 1)
                                    )
                            )
                        }
                        Text("This action cannot be undone")
                            .font(.ds.caption)
                            .foregroundColor(.ds.textSecondary)
                    }
                    .padding(.top, .ds.large)
                }
                .padding(.vertical, .ds.large)
            }
            .background(DesignSystem.Colors.background)
            .navigationTitle("Settings")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .font(.ds.bodyMedium)
                }
            }
        }
        .sheet(isPresented: $showRelayManager) {
            RelayManagerView()
        }
        .sheet(isPresented: $showAbout) {
            AboutView()
        }
        .alert("Delete Account", isPresented: $showDeleteAccount) {
            Button("Cancel", role: .cancel) {}
            Button("Delete", role: .destructive) {
                deleteAccount()
            }
        } message: {
            Text("Are you sure you want to delete your account? This will remove all your data from this device. Your content on Nostr relays will remain.")
        }
        .onAppear {
            withAnimation(.easeInOut(duration: 3).repeatForever(autoreverses: true)) {
                animateGradient = true
            }
        }
    }
    // MARK: - App Icon Header
    private var appIconHeader: some View {
        VStack(spacing: .ds.medium) {
            ZStack {
                // Animated gradient background
                Circle()
                    .fill(
                        LinearGradient(
                            colors: [
                                highlightColor.color.opacity(0.3),
                                highlightColor.color.opacity(0.1)
                            ],
                            startPoint: animateGradient ? .topLeading : .bottomTrailing,
                            endPoint: animateGradient ? .bottomTrailing : .topLeading
                        )
                    )
                    .frame(width: 100, height: 100)
                    .blur(radius: 20)
                Image(systemName: "highlighter")
                    .font(.system(size: 40))
                    .foregroundColor(highlightColor.color)
                    .frame(width: 80, height: 80)
                    .background(
                        RoundedRectangle(cornerRadius: 20, style: .continuous)
                            .fill(highlightColor.color.opacity(0.1))
                    )
                    .overlay(
                        RoundedRectangle(cornerRadius: 20, style: .continuous)
                            .stroke(highlightColor.color.opacity(0.3), lineWidth: 1)
                    )
            }
            Text("Highlighter")
                .font(.system(size: 24, weight: .bold, design: .rounded))
                .foregroundColor(.ds.text)
            Text("Knowledge at your fingertips")
                .font(.ds.body)
                .foregroundColor(.ds.textSecondary)
        }
        .padding(.vertical, .ds.large)
    }
    // MARK: - Actions
    private func clearCache() {
        Task {
            // Clear cache implementation
            await MainActor.run {
                HapticManager.shared.notification(.success)
            }
        }
    }
    private func deleteAccount() {
        Task {
            await appState.logout()
            // Additional cleanup
        }
    }
}
// MARK: - Supporting Views
struct SettingsSection<Content: View>: View {
    let title: String
    let icon: String
    var iconColor: Color = .ds.primary
    @ViewBuilder let content: () -> Content
    var body: some View {
        VStack(alignment: .leading, spacing: .ds.medium) {
            // Section header
            Label(title, systemImage: icon)
                .font(.ds.footnoteMedium)
                .foregroundColor(.ds.textSecondary)
                .symbolRenderingMode(.hierarchical)
                .padding(.horizontal, .ds.screenPadding)
            // Section content
            VStack(spacing: .ds.medium) {
                content()
            }
            .padding()
            .background(
                RoundedRectangle(cornerRadius: 16, style: .continuous)
                    .fill(DesignSystem.Colors.surface)
            )
            .padding(.horizontal, .ds.screenPadding)
        }
    }
}
struct SettingsRow: View {
    let title: String
    let subtitle: String?
    let icon: String
    var iconColor: Color = .ds.primary
    var action: (() -> Void)? = nil
    var body: some View {
        Button(action: { action?() }) {
            HStack(spacing: .ds.medium) {
                Image(systemName: icon)
                    .font(.system(size: 20))
                    .foregroundColor(iconColor)
                    .frame(width: 32, height: 32)
                    .background(
                        Circle()
                            .fill(iconColor.opacity(0.1))
                    )
                VStack(alignment: .leading, spacing: 2) {
                    Text(title)
                        .font(.ds.bodyMedium)
                        .foregroundColor(.ds.text)
                    if let subtitle = subtitle {
                        Text(subtitle)
                            .font(.ds.caption)
                            .foregroundColor(.ds.textSecondary)
                    }
                }
                Spacer()
                if action != nil {
                    Image(systemName: "chevron.right")
                        .font(.system(size: 14))
                        .foregroundColor(.ds.textTertiary)
                }
            }
            .contentShape(Rectangle())
        }
        .buttonStyle(PlainButtonStyle())
        .disabled(action == nil)
    }
}
struct SettingsToggle: View {
    let title: String
    let subtitle: String?
    let icon: String
    @Binding var isOn: Bool
    var body: some View {
        HStack(spacing: .ds.medium) {
            Image(systemName: icon)
                .font(.system(size: 20))
                .foregroundColor(.ds.primary)
                .frame(width: 32, height: 32)
                .background(
                    Circle()
                        .fill(Color.ds.primary.opacity(0.1))
                )
            VStack(alignment: .leading, spacing: 2) {
                Text(title)
                    .font(.ds.bodyMedium)
                    .foregroundColor(.ds.text)
                if let subtitle = subtitle {
                    Text(subtitle)
                        .font(.ds.caption)
                        .foregroundColor(.ds.textSecondary)
                }
            }
            Spacer()
            Toggle("", isOn: $isOn)
                .labelsHidden()
                .tint(.ds.primary)
        }
    }
}
struct ThemeButton: View {
    let theme: SettingsView.AppTheme
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            VStack(spacing: .ds.small) {
                Image(systemName: theme.icon)
                    .font(.system(size: 24))
                    .foregroundColor(isSelected ? .white : .ds.text)
                    .frame(width: 60, height: 60)
                    .background(
                        RoundedRectangle(cornerRadius: 16, style: .continuous)
                            .fill(isSelected ? Color.ds.primary : Color.gray.opacity(0.1))
                    )
                Text(theme.rawValue)
                    .font(.ds.caption)
                    .foregroundColor(isSelected ? .ds.primary : .ds.textSecondary)
            }
        }
        .scaleEffect(isSelected ? 1.05 : 1.0)
        .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isSelected)
    }
}
struct ColorButton: View {
    let color: SettingsView.HighlightColor
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            VStack(spacing: .ds.small) {
                Circle()
                    .fill(color.color)
                    .frame(width: 44, height: 44)
                    .overlay(
                        Circle()
                            .stroke(Color.white, lineWidth: 3)
                            .opacity(isSelected ? 1 : 0)
                    )
                    .overlay(
                        Image(systemName: "checkmark")
                            .font(.system(size: 16, weight: .bold))
                            .foregroundColor(.white)
                            .opacity(isSelected ? 1 : 0)
                    )
                Text(color.rawValue)
                    .font(.ds.caption)
                    .foregroundColor(isSelected ? .ds.text : .ds.textSecondary)
            }
        }
        .scaleEffect(isSelected ? 1.1 : 1.0)
        .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isSelected)
    }
}
// MARK: - Placeholder Views
struct RelayManagerView: View {
    @Environment(\.dismiss) var dismiss
    var body: some View {
        NavigationStack {
            VStack {
                Text("Relay Manager")
                    .font(.ds.title2)
                    .padding()
                Text("Manage your Nostr relay connections")
                    .font(.ds.body)
                    .foregroundColor(.ds.textSecondary)
                Spacer()
            }
            .navigationTitle("Relay Manager")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
    }
}
struct AboutView: View {
    @Environment(\.dismiss) var dismiss
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(spacing: .ds.large) {
                    Image(systemName: "highlighter")
                        .font(.system(size: 60))
                        .foregroundColor(.orange)
                        .padding(.top, 40)
                    Text("Highlighter")
                        .font(.system(size: 32, weight: .bold, design: .rounded))
                    Text("Version 1.0.0")
                        .font(.ds.body)
                        .foregroundColor(.ds.textSecondary)
                    Text("Your personal knowledge companion for the decentralized web. Capture, organize, and share insights from anywhere.")
                        .font(.ds.body)
                        .foregroundColor(.ds.textSecondary)
                        .multilineTextAlignment(.center)
                        .padding(.horizontal, 40)
                    VStack(spacing: .ds.medium) {
                        Link(destination: URL(string: "https://github.com/highlighter/app")!) {
                            Label("GitHub", systemImage: "link")
                                .font(.ds.bodyMedium)
                        }
                        Link(destination: URL(string: "https://highlighter.com")!) {
                            Label("Website", systemImage: "globe")
                                .font(.ds.bodyMedium)
                        }
                    }
                    .padding(.top, .ds.large)
                    Spacer()
                }
                .padding(.vertical, .ds.large)
            }
            .navigationTitle("About")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                }
            }
        }
    }
}
</file>

<file path=".gitignore">
# Xcode
#
# gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore & Swift.gitignore

## User settings
xcuserdata/

## compatibility with Xcode 8 and earlier (ignoring not required starting Xcode 9)
*.xcscmblueprint
*.xccheckout

## compatibility with Xcode 3 and earlier (ignoring not required starting Xcode 4)
build/
DerivedData/
*.moved-aside
*.pbxuser
!default.pbxuser
*.mode1v3
!default.mode1v3
*.mode2v3
!default.mode2v3
*.perspectivev3
!default.perspectivev3

## Obj-C/Swift specific
*.hmap

## App packaging
*.ipa
*.dSYM.zip
*.dSYM

## Playgrounds
timeline.xctimeline
playground.xcworkspace

# Swift Package Manager
#
# Add this line if you want to avoid checking in source code from Swift Package Manager dependencies.
# Packages/
# Package.pins
# Package.resolved
# *.xcodeproj
#
# Xcode automatically generates this directory with a .xcworkspacedata file and xcuserdata
# hence it is not needed unless you have added a package configuration file to your project
# .swiftpm

.build/

# CocoaPods
#
# We recommend against adding the Pods directory to your .gitignore. However
# you should judge for yourself, the pros and cons are mentioned at:
# https://guides.cocoapods.org/using/using-cocoapods.html#should-i-check-the-pods-directory-into-source-control
#
# Pods/
#
# Add this line if you want to avoid checking in source code from the Xcode workspace
# *.xcworkspace

# Carthage
#
# Add this line if you want to avoid checking in source code from Carthage dependencies.
# Carthage/Checkouts

Carthage/Build/

# Accio dependency management
Dependencies/
.accio/

# fastlane
#
# It is recommended to not store the screenshots in the git repo.
# Instead, use fastlane to re-generate the screenshots whenever they are needed.
# For more information about the recommended setup visit:
# https://docs.fastlane.tools/best-practices/source-control/#source-control

fastlane/report.xml
fastlane/Preview.html
fastlane/screenshots/**/*.png
fastlane/test_output

# Code Injection
#
# After new code Injection tools there's a generated folder /iOSInjectionProject
# https://github.com/johnno1962/injectionforxcode

iOSInjectionProject/

# macOS
.DS_Store

# Project specific
*.xcodeproj.backup
</file>

<file path="build.sh">
#!/bin/bash
set -euo pipefail
# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color
# Get script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd "$SCRIPT_DIR"
echo -e "${YELLOW}🔄 Regenerating Xcode project...${NC}"
# Check if xcodegen is installed
if ! command -v xcodegen &> /dev/null; then
    echo -e "${RED}❌ xcodegen is not installed. Installing via Homebrew...${NC}"
    brew install xcodegen
fi
# Generate Xcode project
xcodegen generate
echo -e "${GREEN}✅ Xcode project regenerated${NC}"
# Build the project
echo -e "${YELLOW}🏗️  Building Highlighter...${NC}"
# Set default values
DESTINATION="${DESTINATION:-platform=iOS Simulator,name=iPhone 15 Pro}"
CONFIGURATION="${CONFIGURATION:-Debug}"
SCHEME="${SCHEME:-Highlighter}"
# Build with xcbeautify for cleaner output
set -o pipefail && xcodebuild \
    -project Highlighter.xcodeproj \
    -scheme "$SCHEME" \
    -destination "$DESTINATION" \
    -configuration "$CONFIGURATION" \
    build \
    | xcbeautify
echo -e "${GREEN}✅ Build completed successfully${NC}"
</file>

<file path="deploy.sh">
#!/bin/bash
cd "$(dirname "$0")/.."
./deploy-testflight.sh Highlighter
</file>

<file path="ExportOptions-TestFlight.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>destination</key>
    <string>export</string>
    <key>method</key>
    <string>app-store</string>
    <key>signingStyle</key>
    <string>automatic</string>
    <key>stripSwiftSymbols</key>
    <true/>
    <key>teamID</key>
    <string>456SHKPP26</string>
    <key>uploadBitcode</key>
    <false/>
    <key>uploadSymbols</key>
    <true/>
    <key>compileBitcode</key>
    <false/>
    <key>provisioningProfiles</key>
    <dict/>
</dict>
</plist>
</file>

<file path="ExportOptions.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>method</key>
    <string>app-store-connect</string>
    <key>teamID</key>
    <string>456SHKPP26</string>
    <key>signingStyle</key>
    <string>automatic</string>
    <key>uploadBitcode</key>
    <false/>
    <key>compileBitcode</key>
    <false/>
    <key>uploadSymbols</key>
    <true/>
    <key>generateAppStoreInformation</key>
    <false/>
    <key>stripSwiftSymbols</key>
    <true/>
</dict>
</plist>
</file>

<file path="HL_EXEC.md">
# Highlighter iOS App - Execution Log

## Status: Foundation Complete ✅

### Completed Tasks

1. **Created Extended Product Specification** ✅
   - Expanded the original spec with implementation details
   - Added technical architecture section
   - Defined project structure
   - Created detailed implementation plan with phases
   - Added success metrics and future roadmap

2. **Project Structure Setup** ✅
   - Created complete Xcode project directory structure
   - Set up project.yml for xcodegen
   - Configured Info.plist with required permissions
   - Generated Xcode project successfully

3. **Core Models Implementation** ✅
   - Implemented HighlightEvent model (NIP-84) with full tag parsing
   - Created ArticleCuration model (NIP-51 kind:30004) with metadata support
   - Designed FollowPack model (NIP-51 kind:39089) with import functionality
   - Set up AppState with @StateObject pattern for app-wide state management

4. **Basic UI Shell** ✅
   - Created main app entry point (HighlighterApp.swift)
   - Implemented tab navigation with 5 tabs (Home, Discover, Create, Library, Profile)
   - Built authentication flow with create/import account options
   - Implemented pixel-perfect theme system with custom colors and styles

5. **UI Components Created** ✅
   - **HomeView**: Hybrid scrolling feed with personalized recap, trending quotes, community zaps, and bookstr discussions
   - **SearchView**: Discovery interface with search functionality
   - **CreateHighlightView**: Form for creating new highlights with source and notes
   - **LibraryView**: Personal collection management
   - **ProfileView**: User profile with stats and content tabs
   - **SharedStyles**: Complete theme system with colors, typography, haptics, and animations

### Project Structure
```
Highlighter/
├── Highlighter.xcodeproj (generated)
├── Sources/Highlighter/
│   ├── App/
│   │   ├── HighlighterApp.swift
│   │   └── Info.plist
│   ├── Models/
│   │   ├── HighlightEvent.swift
│   │   ├── ArticleCuration.swift
│   │   ├── FollowPack.swift
│   │   └── AppState.swift
│   ├── Views/
│   │   ├── ContentView.swift
│   │   ├── Home/HomeView.swift
│   │   ├── Discovery/SearchView.swift
│   │   ├── Highlights/CreateHighlightView.swift
│   │   ├── Library/LibraryView.swift
│   │   ├── Profile/ProfileView.swift
│   │   └── Components/SharedStyles.swift
│   └── Resources/Assets.xcassets/
├── project.yml
├── HL-SPEC.md
└── HL_EXEC.md
```

### Technical Achievements

- **Pixel-Perfect UI**: Implemented comprehensive theme system with custom colors, typography, and animations
- **Haptic Feedback**: Integrated throughout for user delight
- **NIP Compliance**: Full support for NIP-84 (highlights), NIP-51 (curations and follow packs)
- **Modern Swift**: Using @StateObject, SwiftUI 17+ features, and async/await patterns
- **Direct NDK Usage**: No unnecessary wrappers, following best practices

### Next Steps for Phase 2

1. **Nostr Integration**
   - Implement actual NDK connections
   - Create highlight publishing flow
   - Set up real-time subscriptions
   - Implement relay management

2. **Feature Enhancement**
   - Connect UI to live data
   - Implement swarm overlay visualization
   - Add Lightning wallet integration
   - Create content import functionality

3. **Polish & Testing**
   - Add loading states and error handling
   - Implement offline caching
   - Create onboarding flow with follow packs
   - Add unit tests

### Build Instructions

```bash
# Generate Xcode project
cd Examples/Apps/Highlighter
xcodegen generate

# Build with xcodebuild
xcodebuild -project Highlighter.xcodeproj -scheme Highlighter -destination 'platform=iOS Simulator,name=iPhone 15 Pro' build

# Run on simulator
xcodebuild -project Highlighter.xcodeproj -scheme Highlighter -destination 'platform=iOS Simulator,name=iPhone 15 Pro' run
```

### Recent Fixes to Follow NDKSwift Patterns

After initial implementation, corrected the following to properly follow NDKSwift patterns:

1. **Fixed AppState** ✅
   - Replaced custom auth with `NDKAuthManager.shared`
   - Replaced `NDKSubscription` (doesn't exist) with `NDKDataSource`
   - Using proper `ndk.observe()` API with streaming pattern
   - Using `NDKProfileManager` for profile fetching
   - Proper session management with biometric support

2. **Fixed Streaming Pattern** ✅
   - HomeView now follows "never wait, always stream" philosophy
   - Shows placeholders immediately, no loading spinners
   - Streams data progressively as it arrives
   - Uses proper cache policies for immediate display

3. **Key Corrections Made**:
   - Using `NDKAuthManager.shared` instead of custom key management
   - Using `NDKDataSource<NDKEvent>` for streaming subscriptions
   - Using `for await event in dataSource.events` pattern
   - Using `NDKProfileManager.observe()` for profiles
   - Proper `maxAge` and `cachePolicy` settings
   - No loading states, progressive UI updates

### Current Status

Foundation complete with correct NDKSwift patterns. The app now properly:
- Uses NDKAuthManager for authentication
- Streams data without waiting
- Shows UI immediately with progressive enhancement
- Uses proper NDKDataSource APIs
- Follows the expert prompt guidelines
</file>

<file path="HL-SPEC.md">
# Highlighter iOS App - Extended Product Specification & Implementation Plan

## Product Specification (Expanded)

### 1. Overview and Value Proposition

Highlighter is a premium iOS application for intellectual discovery and knowledge sharing, built on the Nostr protocol with NIP-84 (kind:9802) for highlights and NIP-51 for advanced curation and social features. It empowers users to become smarter in their downtime by curating a dynamic mix of insightful content, from highlights and quotes to community discussions, personalized recommendations, article curations, and shared follow packs. The app draws from decentralized sources, ensuring censorship resistance and user ownership, while integrating Bitcoin Lightning zaps for value flows. Every interaction is designed with pixel-perfect precision to wow users, delivering an extremely polished UI that feels luxurious and intuitive from the first tap.

**Target Audience**: Intellectuals, lifelong learners, researchers, writers, and professionals aged 18-45 who value depth over distraction. Think: Reddit's r/books users, Kindle enthusiasts, or Notion power-users seeking a social layer.

**Unique Selling Points**:
- **Decentralized and censorship-resistant via Nostr**: No central authority controls content; users own their data and identities.
- **Hybrid home screen**: A modern blend of vertical and horizontal scrolling for a functional mix of content types, rendered with flawless animations and responsive layouts to captivate and delight.
- **Swarm intelligence**: Public highlights overlay on original content, showing what the community finds valuable (e.g., "swarm highlights" visualizing popular passages) in a visually stunning, interactive display.
- **Value-enabled**: Seamless zaps (micro-payments in sats) for appreciating highlights, with automatic splits to authors, curators, and highlighters, accompanied by elegant haptic feedback and ripple effects.
- **Cross-media support**: Highlights from text, audio (timestamps), video (frame references), and more, all presented with high-fidelity thumbnails and smooth playback.
- **Article Curations**: Effortless creation and sharing of themed collections (NIP-51 kind:30004) with titles, descriptions, and images, making organization feel magical and polished.
- **Follow Packs**: Shareable sets of profiles (NIP-51 kind:39089) with names, titles, and images, integrated into onboarding for instant community building in a seamless, wow-inducing flow.

**Mission Statement**: Highlighter is where smart people flock to learn, share, and grow. It turns passive consumption into active enlightenment, fostering a global swarm of knowledge where value flows to those who illuminate the best ideas, all within an app that pursues pixel perfection to wow users at every turn.

### 2. Ethos, Feel, and Aesthetics

**Ethos**:
- **Intellectual Empowerment**: Prioritize depth, curiosity, and community-driven curation over virality. Encourage users to "highlight the highlights" of human knowledge, inspired by concepts like purple text (Nostr's open information flow) and orange highlights (Bitcoin's value-enabled interactions).
- **Decentralization and Ownership**: Built on Nostr, users control their private keys, data, and feeds. No ads, no data mining—pure, user-sovereign experience.
- **Value for Value**: Integrate Lightning Network for zaps, promoting a merit-based economy where quality content and insights are rewarded directly.
- **Inclusivity with Excellence**: Open to all, but curated for quality. Foster respectful discourse, with tools to filter noise and amplify signal.
- **Sustainability**: Eco-friendly (low-energy Nostr relays), privacy-first, and focused on long-term user retention through genuine value.

**Feel**:
- **Modern and functional**—intuitive navigation with seamless transitions between vertical and horizontal elements. Scrolling is responsive and purposeful, with haptics for delight (e.g., subtle vibration on section switches). Users feel productive, not addicted, emerging with new insights, all wrapped in an extremely polished UI that chases pixel perfection to wow at every interaction.
- **Serene and focused**: No overwhelming notifications; users feel in control, emerging refreshed and enlightened, thanks to meticulously crafted animations and layouts.

**Aesthetics**:
- **Color Palette**: Primary: Deep purple (#6A1B9A) for Nostr-inspired elements (e.g., highlights, buttons). Accent: Warm orange (#FF9500) for value flows (zaps, rewards). Neutrals: Soft grays (#F5F5F5 background), black text for readability, with optional dark mode (midnight blue accents)—all rendered with razor-sharp clarity.
- **Typography**: Elegant sans-serif (e.g., Inter or SF Pro) for body text, with serif (e.g., Georgia) for highlighted quotes to evoke classic literature. Large, readable fonts with generous line spacing, optimized for pixel-perfect legibility across devices.
- **UI Style**: Minimalist, card-based design with rounded corners and subtle shadows. Highlights appear as glowing orange-bordered cards in the feed. Animations: Fluid swipes, fade-ins for context overlays, and a "ripple" effect when sharing or zapping. Enhanced for hybrid layouts—cards with variable heights/widths for mixed content, all executed with an extremely polished finish to wow users.
- **Icons and Imagery**: Clean line icons (e.g., a highlighter pen for creating, a lightbulb for discoveries). No stock photos; user-generated thumbnails from highlighted media (blurred for non-images), displayed with high-resolution precision.
- **Overall Vibe**: Sleek like Notion's dashboard meets Spotify's personalized feeds—clean, modular, and adaptable to user preferences (e.g., customizable section order), but elevated by chasing pixel perfection in every detail to create a truly wowing experience.

### 3. Core Features

#### 3.1 Highlight Creation (NIP-84)
- **Text Selection**: Intuitive text selection from any source (imported articles, books via EPUB/PDF, web URLs, or in-app browser)
- **Rich Context**: Add context (surrounding text via `context` tag), attribution (`p` tags for authors), and source (`r` for URLs, `e`/`a` for Nostr events)
- **Personal Notes**: Optional comment tag for quote highlights
- **Privacy Options**: Private (local-only) or public (broadcast to relays)
- **Media Support**: Timestamp audio/video highlights with thumbnails—all presented in a sleek, pixel-perfect editor interface

#### 3.2 Content Types
- **Highlights/Quotes**: NIP-84 events (kind:9802)—text snippets with context, attributions
- **Articles Liked/Zapped by Others**: Aggregated from follows' zaps/likes on sources
- **Old Articles We Liked**: Personalized history—user's past zaps, saves, or interactions resurfaced
- **Kind:1 Discussions**: Nostr notes (kind:1) tagged #bookstr, filtered for book-related threads

#### 3.3 Discovery Feed
- **Hybrid Layout**: Vertical main scroll with embedded horizontal carousels for variety, animated with buttery-smooth transitions
- **Transparent Algorithm**: User-controlled—prioritize follows, zaps, and tags; mix serendipity with personalization
- **Card Design**: Highlight text in bold orange, source/author below, engagement metrics
- **Smart Filters**: By topic, source type, or user, accessible via a polished, intuitive sidebar

#### 3.4 Swarm Highlights Overlay
- **Community Intelligence**: When viewing full content, overlay public highlights from the community
- **Visual Heatmaps**: Orange underlines with popularity heatmaps (darker for more zaps/highlights)
- **Interactive Elements**: Tap to see who highlighted, their notes, and zap them, with haptic feedback

#### 3.5 Social Interactions
- **Zapping**: Send sats directly to highlighters/authors with auto-splits via Lightning Prisms
- **Discussions**: Create threaded discussions on highlights using Nostr replies
- **Following**: Follow users for their highlight feeds; create/share collections
- **Follow Packs**: Support NIP-51 kind 39089—named sets of profiles with name, title, and image

#### 3.6 Article Curations (NIP-51 kind:30004)
- **Easy Creation**: Drag-and-drop or one-tap addition from feeds
- **Rich Metadata**: Title, description, and cover image for each curation
- **Profile Integration**: Displayed prominently in profiles and discoverable in feeds
- **Sharing**: Beautiful preview cards when sharing curations

#### 3.7 Value Flows
- **Lightning Integration**: Non-custodial wallet via Nostr Wallet Connect
- **Smart Splits**: Auto-split zaps (e.g., 50% author, 30% highlighter, 20% curator)
- **Premium Features**: Optional in-app purchases for advanced tools

#### 3.8 Additional Tools
- **Text-to-Speech**: Read highlights aloud with optional sat-streaming
- **Import/Export**: Seamless from Kindle, web clippers, or PDFs
- **Offline Mode**: Cache feeds/highlights for reading without internet

### 4. Technical Architecture

#### 4.1 Project Structure
```
Examples/Apps/Highlighter/
├── Highlighter.xcodeproj/
├── Sources/
│   └── Highlighter/
│       ├── App/
│       │   ├── HighlighterApp.swift
│       │   └── Info.plist
│       ├── Models/
│       │   ├── HighlightEvent.swift
│       │   ├── ArticleCuration.swift
│       │   ├── FollowPack.swift
│       │   └── AppState.swift
│       ├── Views/
│       │   ├── ContentView.swift
│       │   ├── Home/
│       │   │   ├── HomeView.swift
│       │   │   ├── HybridFeedView.swift
│       │   │   └── SectionCarousel.swift
│       │   ├── Highlights/
│       │   │   ├── HighlightCreator.swift
│       │   │   ├── HighlightCard.swift
│       │   │   └── SwarmOverlay.swift
│       │   ├── Profile/
│       │   │   ├── ProfileView.swift
│       │   │   ├── ArticlesView.swift
│       │   │   └── CurationsView.swift
│       │   ├── Discovery/
│       │   │   ├── SearchView.swift
│       │   │   └── DiscoverView.swift
│       │   ├── Library/
│       │   │   └── LibraryView.swift
│       │   └── Components/
│       │       ├── ZapButton.swift
│       │       ├── HighlightEditor.swift
│       │       └── SharedStyles.swift
│       ├── Services/
│       │   ├── NostrService.swift
│       │   ├── HighlightService.swift
│       │   ├── LightningService.swift
│       │   └── ContentImporter.swift
│       └── Utils/
│           ├── Extensions.swift
│           └── Constants.swift
├── Resources/
│   └── Assets.xcassets/
└── project.yml
```

#### 4.2 Core Technologies
- **UI Framework**: SwiftUI for native iOS feel with pixel-perfect components
- **Nostr Integration**: NDKSwift for all Nostr operations
- **Lightning**: Breez SDK or similar for non-custodial wallet
- **Storage**: Core Data for offline caching
- **Media**: AVFoundation for audio/video timestamps

#### 4.3 Nostr Event Types
- **kind:9802**: Highlights (NIP-84)
- **kind:1**: Text notes for discussions (#bookstr)
- **kind:30004**: Article curations (NIP-51)
- **kind:39089**: Follow packs (NIP-51)
- **kind:9735**: Zap receipts
- **kind:10002**: Relay list

### 5. Implementation Plan

#### Phase 1: Foundation (Week 1-2)
1. **Project Setup**
   - Create Xcode project structure
   - Configure project.yml for xcodegen
   - Set up NDKSwift integration
   - Configure build system for iOS-only target

2. **Core Models**
   - Implement HighlightEvent model (NIP-84)
   - Create ArticleCuration model (NIP-51 kind:30004)
   - Design FollowPack model (NIP-51 kind:39089)
   - Set up AppState with @Observable

3. **Basic UI Shell**
   - Tab navigation structure
   - Basic view placeholders
   - Theme and styling system
   - Pixel-perfect component library

#### Phase 2: Nostr Integration (Week 3-4)
1. **Authentication**
   - Key generation/import
   - Secure storage with Keychain
   - Profile creation flow

2. **Event Handling**
   - Highlight creation and broadcasting
   - Event fetching and caching
   - Relay management

3. **Social Features**
   - Following system
   - Reply threading
   - Basic zapping

#### Phase 3: Core Features (Week 5-6)
1. **Highlight Creation**
   - Text selection interface
   - Context capture
   - Media timestamp support
   - Pixel-perfect editor UI

2. **Discovery Feed**
   - Hybrid vertical/horizontal layout
   - Card components with animations
   - Pull-to-refresh
   - Infinite scroll

3. **Swarm Overlays**
   - Highlight aggregation
   - Heatmap visualization
   - Interactive popups

#### Phase 4: Advanced Features (Week 7-8)
1. **Article Curations**
   - Creation interface
   - Management tools
   - Sharing mechanisms

2. **Follow Packs**
   - Import/export UI
   - Onboarding integration
   - Discovery features

3. **Lightning Integration**
   - Wallet setup
   - Zap flows
   - Split payments

#### Phase 5: Polish & Launch (Week 9-10)
1. **UI Refinement**
   - Animation tuning
   - Haptic feedback
   - Performance optimization

2. **Testing**
   - Unit tests for core logic
   - UI tests for critical flows
   - Beta testing program

3. **App Store Preparation**
   - Screenshots and preview
   - App Store description
   - Compliance review

### 6. Success Metrics

- **User Engagement**: Daily active users, time spent in app
- **Content Creation**: Highlights created per user per week
- **Social Activity**: Zaps sent, discussions started
- **Retention**: 7-day and 30-day retention rates
- **Value Flow**: Total sats transacted through the platform

### 7. Future Roadmap

**v1.1**: Audio/video highlight improvements, AI-powered discovery
**v1.2**: Web content import, browser extension
**v2.0**: iPad optimization, collaborative curations
**Long-term**: AR highlighting, voice interfaces, cross-platform sync

## Implementation Notes

### Key Design Principles
1. **Pixel Perfection**: Every UI element must be precisely aligned and animated
2. **User Delight**: Subtle animations and haptics that wow without overwhelming
3. **Performance First**: Smooth 60fps scrolling even with complex layouts
4. **Accessibility**: Full VoiceOver support and Dynamic Type compliance

### Technical Considerations
1. Use NDKSwift directly without unnecessary wrappers
2. Implement proper error handling for offline scenarios
3. Optimize relay queries to minimize bandwidth
4. Cache aggressively for instant UI responses

### Testing Strategy
1. Unit tests for all Nostr event creation/parsing
2. UI tests for critical user flows
3. Performance profiling for scroll performance
4. Beta testing with bookstr community

This specification will guide the development of Highlighter as a premium iOS application that showcases the best of Nostr's decentralized knowledge-sharing capabilities while delivering an extremely polished user experience that consistently wows users.
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Pablo Fernandez

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="project.yml">
name: Highlighter
options:
  bundleIdPrefix: com.highlighter
  deploymentTarget:
    iOS: 17.0
  groupSortPosition: top
  generateEmptyDirectories: true
packages:
  NDKSwift:
    url: https://github.com/pablof7z/NDKSwift
    branch: master
targets:
  Highlighter:
    type: application
    platform: iOS
    sources:
      - Sources
      - path: Resources
        buildPhase: resources
    dependencies:
      - package: NDKSwift
        product: NDKSwift
      - package: NDKSwift
        product: NDKSwiftUI
    settings:
      base:
        # Code Signing Settings - Update these with your values
        DEVELOPMENT_TEAM: "456SHKPP26"
        CODE_SIGN_STYLE: Automatic
        CODE_SIGN_IDENTITY: "Apple Development"
        PROVISIONING_PROFILE_SPECIFIER: ""
        # App Settings
        PRODUCT_BUNDLE_IDENTIFIER: com.highlighter.ios
        PRODUCT_NAME: Highlighter
        MARKETING_VERSION: 1.0.0
        CURRENT_PROJECT_VERSION: 1
        INFOPLIST_FILE: Sources/Highlighter/App/Info.plist
        ENABLE_PREVIEWS: YES
        GENERATE_INFOPLIST_FILE: NO
        ASSETCATALOG_COMPILER_APPICON_NAME: AppIcon
        ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME: AccentColor
        IPHONEOS_DEPLOYMENT_TARGET: 17.0
        SWIFT_VERSION: 5.9
        TARGETED_DEVICE_FAMILY: 1
      configs:
        Debug:
          SWIFT_OPTIMIZATION_LEVEL: "-Onone"
          SWIFT_ACTIVE_COMPILATION_CONDITIONS: DEBUG
          DEBUG_INFORMATION_FORMAT: dwarf
          ENABLE_TESTABILITY: YES
          GCC_DYNAMIC_NO_PIC: NO
          GCC_OPTIMIZATION_LEVEL: 0
          GCC_PREPROCESSOR_DEFINITIONS: DEBUG=1
          MTL_ENABLE_DEBUG_INFO: INCLUDE_SOURCE
          ONLY_ACTIVE_ARCH: YES
        Release:
          SWIFT_OPTIMIZATION_LEVEL: "-O"
          DEBUG_INFORMATION_FORMAT: dwarf-with-dsym
          ENABLE_NS_ASSERTIONS: NO
          ENABLE_TESTABILITY: NO
          GCC_OPTIMIZATION_LEVEL: s
          MTL_ENABLE_DEBUG_INFO: NO
          SWIFT_COMPILATION_MODE: wholemodule
          VALIDATE_PRODUCT: YES
schemes:
  Highlighter:
    build:
      targets:
        Highlighter: all
    run:
      config: Debug
    test:
      config: Debug
    profile:
      config: Release
    analyze:
      config: Debug
    archive:
      config: Release
</file>

<file path="README.md">
# Highlighter - Where Smart People Learn, Share & Grow

<div align="center">
  <img src="Resources/highlighter-icon.png" alt="Highlighter Logo" width="200"/>
  
  [![Platform](https://img.shields.io/badge/platform-iOS%2017%2B-lightgrey)](https://developer.apple.com/ios/)
  [![Swift](https://img.shields.io/badge/Swift-5.9-orange)](https://swift.org)
  [![NDKSwift](https://img.shields.io/badge/NDKSwift-0.2.0-blue)](https://github.com/pablof7z/NDKSwift)
  [![License](https://img.shields.io/badge/license-MIT-green)](LICENSE)
</div>

## Overview

Highlighter is a revolutionary iOS application that transforms passive content consumption into active enlightenment. Built on the [Nostr protocol](https://nostr.com), it creates a social layer for intellectual content where users can highlight, curate, and share valuable insights from any source - articles, books, PDFs, videos, and more.

## Vision

Foster a global swarm of knowledge where value flows to those who illuminate the best ideas. Highlighter combines the best aspects of Reddit's intellectual communities, Kindle's highlighting features, and Notion's organizational capabilities - all within a decentralized, censorship-resistant architecture.

## Features

### 📖 Highlight Creation (NIP-84)
- **Universal Highlighting**: Create highlights from any text source - web articles, books, PDFs, EPUBs
- **Multimedia Support**: Highlight audio timestamps and video frames
- **Rich Context**: Add personal notes and insights to your highlights
- **Privacy Options**: Keep highlights private or broadcast to the community
- **Full Attribution**: Automatic tracking of original authors and sources

### 🧠 Swarm Intelligence
- **Visual Overlays**: See what the community finds valuable with heatmap visualizations
- **Popular Passages**: Discover the most highlighted content across sources
- **Community Insights**: View who highlighted what and why
- **Collective Learning**: Transform individual reading into shared intelligence

### 🔍 Smart Discovery
- **Hybrid Feed**: Innovative vertical and horizontal scrolling for optimal content consumption
- **Curated Content**: Highlights, articles, and discussions from people you follow
- **Trending Topics**: Surface valuable content through community engagement
- **Transparent Algorithm**: User-controlled content discovery with no hidden manipulation

### ⚡ Value-Enabled Ecosystem
- **Bitcoin Lightning Integration**: Direct micropayments ("zaps") to content creators
- **Smart Payment Splits**: Automatic distribution (e.g., 50% author, 30% highlighter, 20% curator)
- **Merit-Based Economy**: Quality insights are directly rewarded
- **Non-Custodial Wallet**: Full control over your funds

### 📚 Content Curation (NIP-51)
- **Themed Collections**: Create curated reading lists on any topic
- **Rich Metadata**: Beautiful covers, descriptions, and organization
- **Community Sharing**: Discover curated lists from thought leaders
- **Follow Packs**: Instantly follow curated sets of interesting people

### 🎨 Premium User Experience
- **Pixel-Perfect Design**: Obsessively polished interface with fluid animations
- **Haptic Feedback**: Delightful tactile responses throughout
- **Modern Card UI**: Beautiful card-based design with glassmorphic effects
- **Progressive Loading**: Never wait - content streams in as it arrives
- **Dark Mode**: Elegant dark theme optimized for reading

### 🔧 Advanced Features
- **Import/Export**: Sync highlights from Kindle and other platforms
- **Text-to-Speech**: Listen to content with optional sat-streaming
- **Offline Mode**: Access cached content without internet
- **Cross-Media**: Support for text, audio, and video content
- **AI Analysis**: Smart insights and connections between highlights

## Requirements

- iOS 17.0+
- Xcode 15.0+
- Swift 5.9+

## Installation

### Building from Source

1. Clone the repository:
```bash
git clone https://github.com/pablof7z/Highlighter.git
cd Highlighter
```

2. Install XcodeGen if you haven't already:
```bash
brew install xcodegen
```

3. Generate the Xcode project:
```bash
./refresh-project.sh
```

4. Open the project in Xcode:
```bash
open Highlighter.xcodeproj
```

5. Build and run the project on your device or simulator

### TestFlight

Coming soon! We'll be releasing Highlighter on TestFlight for beta testing.

## Development

### Building

```bash
# Refresh project after file changes
./refresh-project.sh

# Build with clean output
./build.sh

# Build for specific device
DESTINATION="platform=iOS Simulator,name=iPhone 16 Pro" ./build.sh
```

### Deploying to TestFlight

```bash
./deploy.sh
```

## Architecture

Highlighter is built using cutting-edge iOS technologies:

- **SwiftUI** for declarative UI
- **NDKSwift** for Nostr protocol integration
- **Core Data** for offline caching
- **Lightning SDK** for Bitcoin payments
- **Combine** for reactive programming
- **AVFoundation** for multimedia handling

## Use Cases

- **Researchers**: Share key findings from academic papers
- **Book Clubs**: Highlight and discuss passages together
- **Students**: Create collaborative study materials
- **Professionals**: Curate industry insights and trends
- **Writers**: Collect inspiration and references
- **Lifelong Learners**: Build a personal knowledge base

## Contributing

We welcome contributions! Please see our [Contributing Guidelines](CONTRIBUTING.md) for details.

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## Roadmap

- [ ] Browser extension for web highlighting
- [ ] iPad and Mac Catalyst support
- [ ] AI-powered highlight suggestions
- [ ] Collaborative annotation features
- [ ] Integration with popular reading apps
- [ ] Export to Obsidian/Notion/Roam
- [ ] Audio/video highlighting tools

## NIPs Implemented

- **NIP-01**: Basic protocol flow
- **NIP-84**: Highlights
- **NIP-51**: Lists and collections
- **NIP-57**: Lightning zaps
- **NIP-22**: Comment threads
- **NIP-92**: Media attachments

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgments

- Built with [NDKSwift](https://github.com/pablof7z/NDKSwift)
- Uses the [Nostr Protocol](https://nostr.com)
- Lightning payments via [Breez SDK](https://breez.technology)
- Inspired by the best knowledge management tools

## Contact

- Nostr: `npub1l2vyh47mk2p0qlsku7hg0vn29faehy9hy34ygaclpn66ukqp3afqutajft`
- GitHub: [@pablof7z](https://github.com/pablof7z)

---

<div align="center">
  Made with 💡 for the future of collective intelligence
</div>
</file>

<file path="refresh-project.sh">
#!/bin/bash
set -euo pipefail
# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color
# Get script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd "$SCRIPT_DIR"
echo -e "${YELLOW}🔄 Refreshing Xcode project after file changes...${NC}"
# Clean derived data if requested
if [[ "${CLEAN:-false}" == "true" ]]; then
    echo -e "${YELLOW}🧹 Cleaning derived data...${NC}"
    rm -rf .build/DerivedData
fi
# Regenerate project
xcodegen generate --spec project.yml
echo -e "${GREEN}✅ Project refreshed! The .xcodeproj now includes all current files.${NC}"
echo -e "${GREEN}   Code signing is configured from project.yml${NC}"
</file>

<file path="Sources/Highlighter/Models/Comment.swift">
import Foundation
import NDKSwift
struct Comment: Identifiable, Equatable {
    let id: String
    let event: NDKEvent
    let author: String
    let content: String
    let createdAt: Date
    let highlightId: String
    let replyToId: String?
    var likes: Int
    var isLiked: Bool
    init(from event: NDKEvent) throws {
        self.id = event.id
        self.event = event
        self.content = event.content
        self.author = event.pubkey
        self.createdAt = Date(timeIntervalSince1970: TimeInterval(event.createdAt))
        // Extract highlight ID from tags
        guard let highlightTag = event.tags.first(where: { $0.first == "e" && $0.contains("root") }),
              let highlightId = highlightTag[safe: 1] else {
            throw CommentError.invalidHighlightReference
        }
        self.highlightId = highlightId
        // Extract reply ID if this is a reply
        self.replyToId = event.tags.first(where: { $0.first == "e" && $0.contains("reply") })?[safe: 1]
        // Initialize engagement metrics (would be loaded separately)
        self.likes = 0
        self.isLiked = false
    }
    var isReply: Bool {
        replyToId != nil
    }
    var formattedTime: String {
        RelativeTimeFormatter.relativeTime(from: createdAt)
    }
}
enum CommentError: Error {
    case notConfigured
    case notAuthor
    case invalidHighlightReference
}
</file>

<file path="Sources/Highlighter/Services/CommentService.swift">
import Foundation
import NDKSwift
@MainActor
class CommentService: ObservableObject {
    // MARK: - Published Properties
    @Published private(set) var comments: [String: [Comment]] = [:] // Keyed by highlight ID
    @Published private(set) var isLoadingComments: [String: Bool] = [:]
    @Published private(set) var replyingTo: Comment?
    // MARK: - Properties
    private var ndk: NDK?
    private var signer: NDKSigner?
    private var activeTasks: [String: Task<Void, Never>] = [:]
    // MARK: - Configuration
    func configure(with ndk: NDK, signer: NDKSigner?) {
        self.ndk = ndk
        self.signer = signer
    }
    // MARK: - Public Methods
    /// Load comments for a highlight
    func loadComments(for highlightId: String) async {
        guard let ndk = ndk else { return }
        // Mark as loading
        await MainActor.run {
            isLoadingComments[highlightId] = true
        }
        // Create filter for comments on this highlight
        let filter = NDKFilter(
            kinds: [1], // Regular text notes
            tags: ["e": [highlightId]]
        )
        // Subscribe to comments
        let dataSource = await ndk.outbox.observe(
            filter: filter,
            maxAge: 300, // 5 minute cache
            cachePolicy: .cacheWithNetwork
        )
        // Cancel any existing subscription
        activeTasks[highlightId]?.cancel()
        // Process comments as they arrive
        let task = Task {
            for await event in dataSource.events {
                if let comment = await self.processCommentEvent(event, highlightId: highlightId) {
                    await MainActor.run {
                        if self.comments[highlightId] == nil {
                            self.comments[highlightId] = []
                        }
                        // Add if not already present
                        if !self.comments[highlightId]!.contains(where: { $0.id == comment.id }) {
                            self.comments[highlightId]!.append(comment)
                            // Sort by timestamp
                            self.comments[highlightId]!.sort { $0.createdAt > $1.createdAt }
                        }
                        // Mark as loaded after first comment
                        self.isLoadingComments[highlightId] = false
                    }
                }
            }
            // Mark as loaded when stream ends
            await MainActor.run {
                self.isLoadingComments[highlightId] = false
            }
        }
        activeTasks[highlightId] = task
    }
    /// Post a comment on a highlight
    func postComment(
        on highlightId: String,
        content: String,
        replyingTo: Comment? = nil
    ) async throws {
        guard let ndk = ndk, let signer = signer else {
            throw CommentError.notConfigured
        }
        // Build tags
        var tags: [[String]] = [
            ["e", highlightId, "", "root"] // Reference to the highlight
        ]
        // Add reply tag if replying
        if let replyComment = replyingTo {
            tags.append(["e", replyComment.id, "", "reply"])
            tags.append(["p", replyComment.author]) // Mention the author
        }
        // Create the comment event
        let event = try await NDKEventBuilder(ndk: ndk)
            .kind(1) // Regular text note
            .content(content)
            .tags(tags)
            .build(signer: signer)
        // Publish the comment
        _ = try await ndk.publish(event)
        // The comment will be received through the subscription and added automatically
        // Clear reply target if this was a reply
        if replyingTo != nil {
            await MainActor.run {
                self.replyingTo = nil
            }
        }
        HapticManager.shared.notification(.success)
    }
    /// Like a comment
    func likeComment(_ comment: Comment) async throws {
        guard let ndk = ndk, let signer = signer else {
            throw CommentError.notConfigured
        }
        // Create reaction event (NIP-25)
        let event = try await NDKEventBuilder(ndk: ndk)
            .kind(7) // Reaction
            .content("+") // Like emoji
            .tags([
                ["e", comment.id],
                ["p", comment.author]
            ])
            .build(signer: signer)
        _ = try await ndk.publish(event)
        // Update local state
        await MainActor.run {
            if let highlightComments = self.comments[comment.highlightId],
               let index = highlightComments.firstIndex(where: { $0.id == comment.id }) {
                self.comments[comment.highlightId]![index].likes += 1
                self.comments[comment.highlightId]![index].isLiked = true
            }
        }
        HapticManager.shared.impact(.light)
    }
    /// Delete a comment (if author)
    func deleteComment(_ comment: Comment) async throws {
        guard let ndk = ndk, let signer = signer else {
            throw CommentError.notConfigured
        }
        // Verify the user is the author
        let userPubkey = try await signer.pubkey
        guard comment.author == userPubkey else {
            throw CommentError.notAuthor
        }
        // Create deletion event (NIP-09)
        let event = try await NDKEventBuilder(ndk: ndk)
            .kind(5) // Deletion
            .content("Deleted comment")
            .tags([["e", comment.id]])
            .build(signer: signer)
        _ = try await ndk.publish(event)
        // Remove from local state
        await MainActor.run {
            if var highlightComments = self.comments[comment.highlightId] {
                highlightComments.removeAll { $0.id == comment.id }
                self.comments[comment.highlightId] = highlightComments
            }
        }
        HapticManager.shared.notification(.success)
    }
    /// Get comment count for a highlight
    func getCommentCount(for highlightId: String) -> Int {
        comments[highlightId]?.count ?? 0
    }
    /// Set reply target
    func setReplyTarget(_ comment: Comment?) {
        replyingTo = comment
        if comment != nil {
            HapticManager.shared.impact(.light)
        }
    }
    /// Clear all subscriptions
    func clearSubscriptions() {
        activeTasks.values.forEach { $0.cancel() }
        activeTasks.removeAll()
    }
    // MARK: - Private Methods
    private func processCommentEvent(_ event: NDKEvent, highlightId: String) async -> Comment? {
        // Filter out deletions and other non-comment events
        guard event.kind == 1 else { return nil }
        // Try to create Comment from event
        if var comment = try? Comment(from: event) {
            // Update engagement metrics
            comment.likes = await countReactions(for: event.id)
            comment.isLiked = await checkIfLiked(event.id)
            return comment
        }
        return nil
    }
    private func countReactions(for eventId: String) async -> Int {
        guard let ndk = ndk else { return 0 }
        let filter = NDKFilter(
            kinds: [7], // Reactions
            tags: ["e": [eventId]]
        )
        // Use outbox to get reactions
        let dataSource = await ndk.outbox.observe(
            filter: filter,
            maxAge: 60 // 1 minute cache for reactions
        )
        var count = 0
        for await event in dataSource.events {
            if event.content == "+" || event.content == "❤️" {
                count += 1
            }
        }
        return count
    }
    private func checkIfLiked(_ eventId: String) async -> Bool {
        guard let ndk = ndk, let signer = signer else { return false }
        guard let userPubkey = try? await signer.pubkey else { return false }
        let filter = NDKFilter(
            authors: [userPubkey],
            kinds: [7], // Reactions
            tags: ["e": [eventId]]
        )
        // Use observe with maxAge for one-shot fetch
        let dataSource = await ndk.outbox.observe(
            filter: filter,
            maxAge: 60 // 1 minute cache
        )
        for await event in dataSource.events {
            if event.content == "+" || event.content == "❤️" {
                return true
            }
        }
        return false
    }
}
// MARK: - Supporting Types
extension CommentError: LocalizedError {
    var errorDescription: String? {
        switch self {
        case .notConfigured:
            return "Comment service not configured"
        case .notAuthor:
            return "You can only delete your own comments"
        case .invalidHighlightReference:
            return "Invalid highlight reference in comment"
        }
    }
}
</file>

<file path="Sources/Highlighter/Services/NostrWalletConnect.swift">
import Foundation
import NDKSwift
/// Nostr Wallet Connect (NWC) implementation for Lightning wallet integration
@MainActor
class NostrWalletConnect {
    private let ndk: NDK
    private let walletPubkey: String
    private let secret: String
    private let relay: String
    private var dataSource: NDKDataSource<[NDKEvent]>?
    struct WalletInfo {
        let alias: String
        let pubkey: String
        let network: String
        let blockHeight: Int
        let blockHash: String
        let methods: [String]
    }
    enum NWCError: LocalizedError {
        case invalidConnectionString
        case invalidResponse
        case walletError(String)
        case timeout
        var errorDescription: String? {
            switch self {
            case .invalidConnectionString:
                return "Invalid NWC connection string"
            case .invalidResponse:
                return "Invalid response from wallet"
            case .walletError(let message):
                return "Wallet error: \(message)"
            case .timeout:
                return "Request timed out"
            }
        }
    }
    init(from connectionString: String, ndk: NDK) throws {
        self.ndk = ndk
        // Parse NWC connection string
        // Format: nostr+walletconnect://pubkey?relay=relay-url&secret=secret
        guard let url = URL(string: connectionString),
              url.scheme == "nostr+walletconnect",
              let host = url.host,
              let components = URLComponents(url: url, resolvingAgainstBaseURL: false),
              let relayItem = components.queryItems?.first(where: { $0.name == "relay" }),
              let secretItem = components.queryItems?.first(where: { $0.name == "secret" }),
              let relayValue = relayItem.value,
              let secretValue = secretItem.value else {
            throw NWCError.invalidConnectionString
        }
        self.walletPubkey = host
        self.relay = relayValue
        self.secret = secretValue
    }
    /// Request wallet information
    func getInfo() async throws -> WalletInfo {
        let request = try await createRequest(method: "get_info", params: [:])
        let response = try await sendRequest(request)
        guard let result = response["result"] as? [String: Any] else {
            throw NWCError.invalidResponse
        }
        return WalletInfo(
            alias: result["alias"] as? String ?? "Unknown Wallet",
            pubkey: result["pubkey"] as? String ?? walletPubkey,
            network: result["network"] as? String ?? "mainnet",
            blockHeight: result["block_height"] as? Int ?? 0,
            blockHash: result["block_hash"] as? String ?? "",
            methods: result["methods"] as? [String] ?? []
        )
    }
    /// Get wallet balance
    func getBalance() async throws -> Int {
        let request = try await createRequest(method: "get_balance", params: [:])
        let response = try await sendRequest(request)
        guard let result = response["result"] as? [String: Any],
              let balanceMsat = result["balance"] as? Int else {
            throw NWCError.invalidResponse
        }
        // Convert millisats to sats
        return balanceMsat / 1000
    }
    /// Pay a Lightning invoice
    func payInvoice(_ invoice: String) async throws -> String {
        let params = ["invoice": invoice]
        let request = try await createRequest(method: "pay_invoice", params: params)
        let response = try await sendRequest(request)
        guard let result = response["result"] as? [String: Any],
              let preimage = result["preimage"] as? String else {
            if let error = response["error"] as? [String: Any],
               let message = error["message"] as? String {
                throw NWCError.walletError(message)
            }
            throw NWCError.invalidResponse
        }
        return preimage
    }
    /// Create an invoice
    func makeInvoice(amount: Int, description: String? = nil, expiry: Int? = nil) async throws -> String {
        var params: [String: Any] = ["amount": amount * 1000] // Convert sats to millisats
        if let description = description {
            params["description"] = description
        }
        if let expiry = expiry {
            params["expiry"] = expiry
        }
        let request = try await createRequest(method: "make_invoice", params: params)
        let response = try await sendRequest(request)
        guard let result = response["result"] as? [String: Any],
              let invoice = result["invoice"] as? String else {
            throw NWCError.invalidResponse
        }
        return invoice
    }
    // MARK: - Private Methods
    private func createRequest(method: String, params: [String: Any]) async throws -> NDKEvent {
        let requestId = UUID().uuidString
        let content: [String: Any] = [
            "method": method,
            "params": params,
            "id": requestId
        ]
        let contentData = try JSONSerialization.data(withJSONObject: content)
        let contentString = String(data: contentData, encoding: .utf8) ?? "{}"
        // Validate secret is hex
        guard Data(hex: secret) != nil else {
            throw NWCError.invalidConnectionString
        }
        // Get the current signer
        guard let signer = ndk.signer else {
            throw NWCError.invalidConnectionString
        }
        // Create NDKUser for the wallet
        let walletUser = NDKUser(pubkey: walletPubkey)
        // Encrypt the content using NIP-04
        let encryptedContent = try await signer.encrypt(recipient: walletUser, value: contentString, scheme: .nip04)
        // Create and sign event using NDKEventBuilder
        let event = try await NDKEventBuilder(ndk: ndk)
            .kind(23194) // NWC request kind
            .content(encryptedContent)
            .tag(["p", walletPubkey])
            .build()
        return event
    }
    private func sendRequest(_ request: NDKEvent) async throws -> [String: Any] {
        // Publish request to specific relay (event is already signed)
        _ = try await ndk.publish(request, to: [relay])
        // Set up response listener
        let filter = NDKFilter(
            authors: [walletPubkey],
            kinds: [23195], // NWC response kind
            tags: ["e": Set([request.id])]
        )
        // Create data source for receiving response
        let dataSource = await ndk.outbox.observe(
            filter: filter,
            maxAge: 0,
            cachePolicy: .networkOnly
        )
        // Use a continuation to handle the async response
        return try await withCheckedThrowingContinuation { continuation in
            var hasResponded = false
            Task {
                // Set up timeout
                Task {
                    try? await Task.sleep(nanoseconds: 30_000_000_000) // 30 seconds
                    if !hasResponded {
                        hasResponded = true
                        continuation.resume(throwing: NWCError.timeout)
                    }
                }
                // Listen for response
                for await event in dataSource.events {
                    guard !hasResponded else { break }
                    do {
                        // Get the signer
                        guard let signer = ndk.signer else {
                            continue
                        }
                        // Create NDKUser for the wallet (sender of the response)
                        let walletUser = NDKUser(pubkey: walletPubkey)
                        // Decrypt the content using NIP-04
                        let decryptedContent = try await signer.decrypt(sender: walletUser, value: event.content, scheme: .nip04)
                        // Parse response
                        guard let data = decryptedContent.data(using: .utf8),
                              let response = try JSONSerialization.jsonObject(with: data) as? [String: Any] else {
                            continue
                        }
                        hasResponded = true
                        continuation.resume(returning: response)
                        break
                    } catch {
                        // Continue listening if parsing/decryption fails
                        continue
                    }
                }
            }
        }
    }
}
// MARK: - NDKEventKind Extension
// MARK: - Data Extensions
extension Data {
    init?(hex: String) {
        let hex = hex.replacingOccurrences(of: " ", with: "")
            .replacingOccurrences(of: "\n", with: "")
        guard hex.count % 2 == 0 else { return nil }
        var data = Data()
        var index = hex.startIndex
        while index < hex.endIndex {
            let nextIndex = hex.index(index, offsetBy: 2)
            guard let byte = UInt8(hex[index..<nextIndex], radix: 16) else { return nil }
            data.append(byte)
            index = nextIndex
        }
        self = data
    }
}
</file>

<file path="Sources/Highlighter/Services/ReadingProgressService.swift">
import Foundation
import NDKSwift
import SwiftUI
/// Service for tracking and persisting reading progress across articles
@MainActor
class ReadingProgressService: ObservableObject {
    // MARK: - Models
    struct ArticleProgress: Codable {
        let articleId: String
        let progress: Double // 0.0 to 1.0
        let lastReadDate: Date
        let totalReadingTime: TimeInterval // in seconds
        let scrollPosition: CGFloat
    }
    struct ReadingSession {
        let articleId: String
        let startTime: Date
        var lastUpdateTime: Date
    }
    // MARK: - Published Properties
    @Published private(set) var progressByArticle: [String: ArticleProgress] = [:]
    @Published private(set) var activeSession: ReadingSession?
    // MARK: - Private Properties
    private let progressKey = "reading_progress_v1"
    private let progressUpdateThreshold: TimeInterval = 2.0 // Update every 2 seconds
    private var lastProgressUpdate: Date = Date()
    // MARK: - Initialization
    init() {
        loadProgress()
    }
    // MARK: - Public Methods
    /// Start a reading session for an article
    func startReadingSession(for articleId: String) {
        activeSession = ReadingSession(
            articleId: articleId,
            startTime: Date(),
            lastUpdateTime: Date()
        )
    }
    /// End the current reading session
    func endReadingSession() {
        guard let session = activeSession else { return }
        let readingTime = Date().timeIntervalSince(session.startTime)
        if let existing = progressByArticle[session.articleId] {
            progressByArticle[session.articleId] = ArticleProgress(
                articleId: session.articleId,
                progress: existing.progress,
                lastReadDate: Date(),
                totalReadingTime: existing.totalReadingTime + readingTime,
                scrollPosition: existing.scrollPosition
            )
        }
        activeSession = nil
        saveProgress()
    }
    /// Update reading progress for an article
    func updateProgress(for articleId: String, progress: Double, scrollPosition: CGFloat) {
        // Throttle updates to avoid excessive saves
        guard Date().timeIntervalSince(lastProgressUpdate) >= progressUpdateThreshold else { return }
        lastProgressUpdate = Date()
        // Update active session time if this is the current article
        if activeSession?.articleId == articleId {
            activeSession?.lastUpdateTime = Date()
        }
        let existingProgress = progressByArticle[articleId]
        let totalTime = existingProgress?.totalReadingTime ?? 0
        progressByArticle[articleId] = ArticleProgress(
            articleId: articleId,
            progress: progress,
            lastReadDate: Date(),
            totalReadingTime: totalTime,
            scrollPosition: scrollPosition
        )
        saveProgress()
    }
    /// Get progress for a specific article
    func getProgress(for articleId: String) -> ArticleProgress? {
        return progressByArticle[articleId]
    }
    /// Get all articles with reading progress
    func getArticlesInProgress() -> [ArticleProgress] {
        return progressByArticle.values
            .filter { $0.progress > 0 && $0.progress < 1 }
            .sorted { $0.lastReadDate > $1.lastReadDate }
    }
    /// Get recently read articles
    func getRecentlyReadArticles(limit: Int = 10) -> [ArticleProgress] {
        return progressByArticle.values
            .sorted { $0.lastReadDate > $1.lastReadDate }
            .prefix(limit)
            .map { $0 }
    }
    /// Calculate estimated reading time based on word count
    static func estimateReadingTime(wordCount: Int) -> TimeInterval {
        // Average reading speed: 200-250 words per minute
        let wordsPerMinute = 225.0
        return (Double(wordCount) / wordsPerMinute) * 60.0
    }
    /// Mark an article as completed
    func markAsCompleted(articleId: String) {
        if let existing = progressByArticle[articleId] {
            progressByArticle[articleId] = ArticleProgress(
                articleId: articleId,
                progress: 1.0,
                lastReadDate: Date(),
                totalReadingTime: existing.totalReadingTime,
                scrollPosition: 0
            )
            saveProgress()
        }
    }
    /// Clear progress for an article
    func clearProgress(for articleId: String) {
        progressByArticle.removeValue(forKey: articleId)
        saveProgress()
    }
    /// Clear all reading progress
    func clearAllProgress() {
        progressByArticle.removeAll()
        saveProgress()
    }
    // MARK: - Persistence
    private func saveProgress() {
        do {
            let encoder = JSONEncoder()
            let data = try encoder.encode(progressByArticle)
            UserDefaults.standard.set(data, forKey: progressKey)
        } catch {
            print("Failed to save reading progress: \(error)")
        }
    }
    private func loadProgress() {
        guard let data = UserDefaults.standard.data(forKey: progressKey) else { return }
        do {
            let decoder = JSONDecoder()
            progressByArticle = try decoder.decode([String: ArticleProgress].self, from: data)
        } catch {
            print("Failed to load reading progress: \(error)")
        }
    }
}
// MARK: - Progress Indicator View
struct ReadingProgressIndicator: View {
    let progress: Double
    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                // Background
                RoundedRectangle(cornerRadius: 2)
                    .fill(DesignSystem.Colors.surfaceSecondary)
                    .frame(height: 4)
                // Progress
                RoundedRectangle(cornerRadius: 2)
                    .fill(
                        LinearGradient(
                            colors: [DesignSystem.Colors.primary, DesignSystem.Colors.secondary],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .frame(width: geometry.size.width * progress, height: 4)
                    .animation(.spring(response: 0.3, dampingFraction: 0.8), value: progress)
            }
        }
        .frame(height: 4)
    }
}
// MARK: - Reading Stats View
struct ReadingStatsView: View {
    let progress: ReadingProgressService.ArticleProgress
    var body: some View {
        HStack(spacing: DesignSystem.Spacing.medium) {
            // Progress percentage
            Label {
                Text("\(Int(progress.progress * 100))%")
                    .font(.ds.caption)
                    .fontWeight(.medium)
            } icon: {
                Image(systemName: "book.fill")
                    .font(.system(size: 12))
            }
            .foregroundColor(DesignSystem.Colors.textSecondary)
            Divider()
                .frame(height: 12)
            // Reading time
            Label {
                Text(formatReadingTime(progress.totalReadingTime))
                    .font(.ds.caption)
                    .fontWeight(.medium)
            } icon: {
                Image(systemName: "clock")
                    .font(.system(size: 12))
            }
            .foregroundColor(DesignSystem.Colors.textSecondary)
        }
    }
    private func formatReadingTime(_ seconds: TimeInterval) -> String {
        let minutes = Int(seconds) / 60
        if minutes < 1 {
            return "< 1 min"
        } else if minutes < 60 {
            return "\(minutes) min"
        } else {
            let hours = minutes / 60
            let remainingMinutes = minutes % 60
            if remainingMinutes == 0 {
                return "\(hours) hr"
            } else {
                return "\(hours) hr \(remainingMinutes) min"
            }
        }
    }
}
</file>

<file path="Sources/Highlighter/Utilities/ArticleTimeEstimator.swift">
import Foundation
/// Estimates reading time for articles based on content length
struct ArticleTimeEstimator {
    /// Average words per minute for reading
    /// Standard reading speed is 200-250 wpm, we use 225 as average
    private static let wordsPerMinute: Double = 225
    /// Estimate reading time in minutes for given content
    /// - Parameter content: The article content text
    /// - Returns: Estimated reading time in minutes, or nil if content is empty
    static func estimateReadingTime(for content: String) -> Int? {
        let cleanedContent = content.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !cleanedContent.isEmpty else { return nil }
        // Count words by splitting on whitespace and punctuation
        let words = cleanedContent.components(separatedBy: .whitespacesAndNewlines)
            .filter { !$0.isEmpty }
            .count
        // Calculate reading time
        let minutes = Double(words) / wordsPerMinute
        // Round up to nearest minute, minimum 1 minute
        return max(1, Int(ceil(minutes)))
    }
    /// Format reading time for display
    /// - Parameter minutes: Reading time in minutes
    /// - Returns: Formatted string like "5 min" or "1 hr 15 min"
    static func formatReadingTime(_ minutes: Int) -> String {
        if minutes < 60 {
            return "\(minutes) min"
        } else {
            let hours = minutes / 60
            let remainingMinutes = minutes % 60
            if remainingMinutes == 0 {
                return "\(hours) hr"
            } else {
                return "\(hours) hr \(remainingMinutes) min"
            }
        }
    }
}
</file>

<file path="Sources/Highlighter/Views/Articles/ArticleCards.swift">
import SwiftUI
import NDKSwift
// MARK: - Article List Card using UnifiedCard
struct ModernArticleListCard: View {
    let article: Article
    @State private var author: NDKUserProfile?
    @EnvironmentObject var appState: AppState
    @State private var isBookmarked = false
    var body: some View {
        UnifiedCard(
            variant: .standard,
            isSelected: isBookmarked
        ) {
            VStack(alignment: .leading, spacing: DesignSystem.Spacing.medium) {
                // Image
                if let imageURL = article.image, let url = URL(string: imageURL) {
                    AsyncImage(url: url) { phase in
                        switch phase {
                        case .success(let image):
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                .frame(height: 180)
                                .clipped()
                        case .failure(_), .empty:
                            Rectangle()
                                .fill(Color.gray.opacity(0.1))
                                .frame(height: 180)
                                .overlay {
                                    Image(systemName: "photo")
                                        .foregroundColor(.gray)
                                }
                        @unknown default:
                            EmptyView()
                        }
                    }
                    .cornerRadius(12)
                }
                VStack(alignment: .leading, spacing: DesignSystem.Spacing.small) {
                    // Title
                    Text(article.title)
                        .font(DesignSystem.Typography.headline)
                        .foregroundColor(DesignSystem.Colors.text)
                        .lineLimit(2)
                    // Summary
                    if let summary = article.summary {
                        Text(summary)
                            .font(DesignSystem.Typography.body)
                            .foregroundColor(DesignSystem.Colors.textSecondary)
                            .lineLimit(3)
                    }
                    // Metadata
                    HStack {
                        // Author
                        HStack(spacing: DesignSystem.Spacing.mini) {
                            EnhancedAsyncProfileImage(pubkey: article.author, size: 24)
                            Text(author?.displayName ?? PubkeyFormatter.formatShort(article.author))
                                .font(DesignSystem.Typography.caption)
                                .foregroundColor(DesignSystem.Colors.textSecondary)
                        }
                        Spacer()
                        // Reading time
                        Label("\(article.estimatedReadingTime) min", systemImage: "clock")
                            .font(DesignSystem.Typography.caption)
                            .foregroundColor(DesignSystem.Colors.textSecondary)
                        // Date
                        if let publishedAt = article.publishedAt {
                            Text("•")
                                .foregroundColor(DesignSystem.Colors.textSecondary)
                            Text(publishedAt.formatted(.relative(presentation: .named)))
                                .font(DesignSystem.Typography.caption)
                                .foregroundColor(DesignSystem.Colors.textSecondary)
                        }
                    }
                }
            }
        }
        .task {
            await loadAuthor()
            await checkBookmarkStatus()
        }
    }
    private func loadAuthor() async {
        guard let ndk = appState.ndk else { return }
        for await profile in await ndk.profileManager.observe(for: article.author, maxAge: TimeConstants.hour) {
            await MainActor.run {
                self.author = profile
            }
            break
        }
    }
    private func checkBookmarkStatus() async {
        await MainActor.run {
            isBookmarked = appState.bookmarkService.isArticleBookmarked(article.id)
        }
    }
}
// MARK: - Featured Article Card using UnifiedCard
struct ModernArticleFeaturedCard: View {
    let article: Article
    @State private var author: NDKUserProfile?
    @EnvironmentObject var appState: AppState
    var body: some View {
        UnifiedCard(
            variant: .elevated,
            action: nil
        ) {
            VStack(alignment: .leading, spacing: 0) {
                // Image
                if let imageURL = article.image, let url = URL(string: imageURL) {
                    AsyncImage(url: url) { phase in
                        switch phase {
                        case .success(let image):
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                .frame(width: 280, height: 200)
                                .clipped()
                        case .failure(_), .empty:
                            Rectangle()
                                .fill(
                                    LinearGradient(
                                        colors: [
                                            DesignSystem.Colors.primaryDark.opacity(0.2),
                                            DesignSystem.Colors.primary.opacity(0.2)
                                        ],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                                .frame(width: 280, height: 200)
                                .overlay {
                                    Image(systemName: "photo")
                                        .font(.system(size: 40))
                                        .foregroundColor(.gray.opacity(0.5))
                                }
                        @unknown default:
                            EmptyView()
                        }
                    }
                }
                VStack(alignment: .leading, spacing: DesignSystem.Spacing.small) {
                    // Title
                    Text(article.title)
                        .font(DesignSystem.Typography.headline)
                        .foregroundColor(DesignSystem.Colors.text)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)
                    // Summary
                    if let summary = article.summary {
                        Text(summary)
                            .font(DesignSystem.Typography.body)
                            .foregroundColor(DesignSystem.Colors.textSecondary)
                            .lineLimit(2)
                            .multilineTextAlignment(.leading)
                    }
                    Spacer()
                    // Author and metadata
                    HStack {
                        // Author
                        HStack(spacing: DesignSystem.Spacing.mini) {
                            EnhancedAsyncProfileImage(pubkey: article.author, size: 24)
                            Text(author?.displayName ?? PubkeyFormatter.formatShort(article.author))
                                .font(DesignSystem.Typography.caption)
                                .foregroundColor(DesignSystem.Colors.textSecondary)
                                .lineLimit(1)
                        }
                        Spacer()
                        // Reading time
                        Text("\(article.estimatedReadingTime) min")
                            .font(DesignSystem.Typography.caption)
                            .foregroundColor(DesignSystem.Colors.textSecondary)
                    }
                }
                .padding()
            }
            .frame(width: 280, height: 380)
        }
        .task {
            await loadAuthor()
        }
    }
    private func loadAuthor() async {
        guard let ndk = appState.ndk else { return }
        for await profile in await ndk.profileManager.observe(for: article.author, maxAge: TimeConstants.hour) {
            await MainActor.run {
                self.author = profile
            }
            break
        }
    }
}
// MARK: - Row Article Card using UnifiedCard
struct ModernArticleRowCard: View {
    let article: Article
    @State private var author: NDKUserProfile?
    @EnvironmentObject var appState: AppState
    var body: some View {
        UnifiedCard(
            variant: .standard
        ) {
            HStack(spacing: DesignSystem.Spacing.medium) {
                // Small image on the left
                if let imageURL = article.image, let url = URL(string: imageURL) {
                    AsyncImage(url: url) { phase in
                        switch phase {
                        case .success(let image):
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                .frame(width: 100, height: 100)
                                .clipShape(RoundedRectangle(cornerRadius: 12))
                        case .failure(_), .empty:
                            RoundedRectangle(cornerRadius: 12)
                                .fill(
                                    LinearGradient(
                                        colors: [
                                            DesignSystem.Colors.primaryDark.opacity(0.1),
                                            DesignSystem.Colors.primary.opacity(0.1)
                                        ],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                                .frame(width: 100, height: 100)
                                .overlay {
                                    Image(systemName: "photo")
                                        .foregroundColor(.gray.opacity(0.5))
                                }
                        @unknown default:
                            EmptyView()
                        }
                    }
                }
                // Content on the right
                VStack(alignment: .leading, spacing: DesignSystem.Spacing.mini) {
                    // Title
                    Text(article.title)
                        .font(DesignSystem.Typography.headline)
                        .foregroundColor(DesignSystem.Colors.text)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)
                    // Summary
                    if let summary = article.summary {
                        Text(summary)
                            .font(DesignSystem.Typography.caption)
                            .foregroundColor(DesignSystem.Colors.textSecondary)
                            .lineLimit(2)
                            .multilineTextAlignment(.leading)
                    }
                    Spacer()
                    // Metadata
                    HStack(spacing: DesignSystem.Spacing.small) {
                        // Author
                        HStack(spacing: 4) {
                            EnhancedAsyncProfileImage(pubkey: article.author, size: 20)
                            Text(author?.displayName ?? PubkeyFormatter.formatShort(article.author))
                                .font(DesignSystem.Typography.caption)
                                .foregroundColor(DesignSystem.Colors.textSecondary)
                                .lineLimit(1)
                        }
                        Spacer()
                        // Reading time & date
                        HStack(spacing: 4) {
                            Label("\(article.estimatedReadingTime) min", systemImage: "clock")
                                .font(DesignSystem.Typography.caption)
                                .foregroundColor(DesignSystem.Colors.textSecondary)
                                .labelStyle(.titleOnly)
                            if let publishedAt = article.publishedAt {
                                Text("•")
                                    .foregroundColor(DesignSystem.Colors.textSecondary)
                                Text(RelativeTimeFormatter.relativeTime(from: publishedAt))
                                    .font(DesignSystem.Typography.caption)
                                    .foregroundColor(DesignSystem.Colors.textSecondary)
                                    .lineLimit(1)
                            }
                        }
                    }
                }
                Spacer()
            }
            .frame(height: 120)
        }
        .task {
            await loadAuthor()
        }
    }
    private func loadAuthor() async {
        guard let ndk = appState.ndk else { return }
        for await profile in await ndk.profileManager.observe(for: article.author, maxAge: TimeConstants.hour) {
            await MainActor.run {
                self.author = profile
            }
            break
        }
    }
}
</file>

<file path="Sources/Highlighter/Views/Components/CommentsSection.swift">
import SwiftUI
import NDKSwift
struct CommentsSection: View {
    let highlightId: String
    @EnvironmentObject var appState: AppState
    @State private var comments: [Comment] = []
    // No loading states - stream progressively
    @State private var newCommentText = ""
    @State private var isPostingComment = false
    @State private var commentAuthors: [String: NDKUserProfile] = [:]
    @State private var showComposer = false
    @State private var animatedCommentIds = Set<String>()
    @State private var replyingTo: Comment?
    @State private var commentReactions: [String: CommentReactions] = [:]
    @State private var currentUserPubkey: String = ""
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Enhanced section header
            CommentsSectionHeader(
                commentsCount: comments.count
            )
            .padding(.horizontal)
            // Enhanced comments list with animations
            if comments.isEmpty {
                EmptyCommentsView(onComment: { showComposer = true })
                    .padding(.horizontal)
                    .transition(.asymmetric(
                        insertion: .push(from: .bottom).combined(with: .opacity),
                        removal: .scale.combined(with: .opacity)
                    ))
            } else {
                CommentsList(
                    comments: comments,
                    commentAuthors: commentAuthors,
                    commentReactions: commentReactions,
                    animatedCommentIds: $animatedCommentIds,
                    onReply: { comment in replyingTo = comment },
                    onReact: handleReaction
                )
            }
            // Enhanced comment composer
            VStack(spacing: 12) {
                if let replyingTo = replyingTo {
                    HStack {
                        Image(systemName: "arrow.turn.down.right")
                            .font(.caption)
                            .foregroundColor(DesignSystem.Colors.primary)
                        Text("Replying to \(commentAuthors[replyingTo.author]?.displayName ?? "user")")
                            .font(.caption)
                            .foregroundColor(DesignSystem.Colors.textSecondary)
                        Spacer()
                        Button(action: { self.replyingTo = nil }) {
                            Image(systemName: "xmark.circle.fill")
                                .font(.caption)
                                .foregroundColor(DesignSystem.Colors.textTertiary)
                        }
                    }
                    .padding(.horizontal)
                    .padding(.vertical, 8)
                    .background(
                        RoundedRectangle(cornerRadius: 12)
                            .fill(DesignSystem.Colors.primary.opacity(0.1))
                    )
                    .padding(.horizontal)
                    .transition(.move(edge: .top).combined(with: .opacity))
                }
                HStack(spacing: 12) {
                    EnhancedAsyncProfileImage(pubkey: currentUserPubkey, size: 36)
                        .overlay(
                            Circle()
                                .stroke(
                                    LinearGradient(
                                        colors: [DesignSystem.Colors.primary, DesignSystem.Colors.secondary],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    ),
                                    lineWidth: showComposer ? 2 : 0
                                )
                        )
                        .animation(.spring(response: 0.3), value: showComposer)
                    ZStack(alignment: .trailing) {
                        // Glass morphism background
                        RoundedRectangle(cornerRadius: 24)
                            .fill(.ultraThinMaterial)
                            .overlay(
                                RoundedRectangle(cornerRadius: 24)
                                    .stroke(
                                        LinearGradient(
                                            colors: showComposer ? 
                                                [DesignSystem.Colors.primary.opacity(0.3), DesignSystem.Colors.secondary.opacity(0.3)] :
                                                [Color.clear, Color.clear],
                                            startPoint: .topLeading,
                                            endPoint: .bottomTrailing
                                        ),
                                        lineWidth: 1
                                    )
                            )
                        HStack {
                            TextField(
                                replyingTo != nil ? "Write your reply..." : "Add a comment...",
                                text: $newCommentText,
                                axis: .vertical
                            )
                            .font(DesignSystem.Typography.body)
                            .disabled(isPostingComment)
                            .onTapGesture {
                                withAnimation(.spring(response: 0.3)) {
                                    showComposer = true
                                }
                            }
                            .lineLimit(showComposer ? 5 : 1)
                            if !newCommentText.isEmpty {
                                Button(action: postComment) {
                                    ZStack {
                                        Circle()
                                            .fill(
                                                LinearGradient(
                                                    colors: [DesignSystem.Colors.primary, DesignSystem.Colors.secondary],
                                                    startPoint: .topLeading,
                                                    endPoint: .bottomTrailing
                                                )
                                            )
                                            .frame(width: 32, height: 32)
                                        if isPostingComment {
                                            ProgressView()
                                                .progressViewStyle(CircularProgressViewStyle(tint: .white))
                                                .scaleEffect(0.6)
                                        } else {
                                            Image(systemName: "arrow.up")
                                                .font(.system(size: 16, weight: .bold))
                                                .foregroundColor(.white)
                                        }
                                    }
                                }
                                .disabled(isPostingComment || newCommentText.isEmpty)
                                .transition(.scale.combined(with: .opacity))
                            }
                        }
                        .padding(.horizontal, 16)
                        .padding(.vertical, showComposer ? 12 : 10)
                    }
                    .frame(height: showComposer ? nil : 44)
                    .animation(.spring(response: 0.3), value: showComposer)
                }
                .padding(.horizontal)
                .padding(.bottom)
            }
        }
        .task {
            await loadComments()
            await loadCurrentUserPubkey()
        }
    }
    private func loadComments() async {
        guard let ndk = appState.ndk else { return }
        let filter = NDKFilter(
            kinds: [1],
            limit: 50,
            tags: ["e": [highlightId]]
        )
        let dataSource = await ndk.outbox.observe(
            filter: filter,
            maxAge: 300,
            cachePolicy: .cacheWithNetwork
        )
        var hasReceivedFirstComment = false
        for await event in dataSource.events {
            // Check if this is a reply to the highlight
            let eTags = event.tags.filter { $0.first == "e" }
            let isReplyToHighlight = eTags.contains { tag in
                tag.count > 1 && tag[1] == highlightId
            }
            if isReplyToHighlight,
               let comment = try? Comment(from: event) {
                await MainActor.run {
                    if !comments.contains(where: { $0.id == comment.id }) {
                        comments.append(comment)
                        comments.sort { $0.createdAt > $1.createdAt }
                        if !hasReceivedFirstComment {
                            hasReceivedFirstComment = true
                            // Comment loaded
                        }
                    }
                }
                // Load author profile
                Task {
                    await loadAuthorProfile(for: comment.author)
                }
            }
        }
        // Comments stream in progressively - no artificial delays
    }
    private func loadAuthorProfile(for pubkey: String) async {
        guard let ndk = appState.ndk else { return }
        if commentAuthors[pubkey] != nil { return }
        for await profile in await ndk.profileManager.observe(for: pubkey, maxAge: TimeConstants.hour) {
            await MainActor.run {
                self.commentAuthors[pubkey] = profile
            }
            break
        }
    }
    private func loadCurrentUserPubkey() async {
        if let signer = appState.activeSigner {
            if let pubkey = try? await signer.pubkey {
                await MainActor.run {
                    self.currentUserPubkey = pubkey
                }
            }
        }
    }
    private func postComment() {
        guard let ndk = appState.ndk,
              let signer = appState.activeSigner,
              !newCommentText.isEmpty else { return }
        isPostingComment = true
        Task {
            do {
                // Create comment event using NDKEventBuilder
                let commentEvent = try await NDKEventBuilder(ndk: ndk)
                    .kind(1)
                    .content(newCommentText)
                    .tags([["e", highlightId]])
                    .build(signer: signer)
                // Publish
                _ = try await ndk.publish(commentEvent)
                await MainActor.run {
                    newCommentText = ""
                    isPostingComment = false
                    showComposer = false
                    replyingTo = nil
                    HapticManager.shared.impact(.medium)
                }
            } catch {
                await MainActor.run {
                    isPostingComment = false
                }
            }
        }
    }
}
struct EmptyCommentsView: View {
    let onComment: () -> Void
    @State private var bubbleScale: CGFloat = 1
    @State private var bubbleRotation: Double = 0
    var body: some View {
        VStack(spacing: 16) {
            ZStack {
                // Animated background circles
                Circle()
                    .fill(DesignSystem.Colors.primary.opacity(0.1))
                    .frame(width: 100, height: 100)
                    .scaleEffect(bubbleScale)
                    .animation(
                        .easeInOut(duration: 2)
                        .repeatForever(autoreverses: true),
                        value: bubbleScale
                    )
                Circle()
                    .fill(DesignSystem.Colors.secondary.opacity(0.1))
                    .frame(width: 80, height: 80)
                    .scaleEffect(bubbleScale * 0.8)
                    .animation(
                        .easeInOut(duration: 2)
                        .repeatForever(autoreverses: true)
                        .delay(0.5),
                        value: bubbleScale
                    )
                Image(systemName: "bubble.left.and.bubble.right")
                    .font(.system(size: 48))
                    .foregroundStyle(
                        LinearGradient(
                            colors: [DesignSystem.Colors.primary, DesignSystem.Colors.secondary],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .rotationEffect(.degrees(bubbleRotation))
                    .animation(
                        .spring(response: 0.5, dampingFraction: 0.6)
                        .repeatForever(autoreverses: true),
                        value: bubbleRotation
                    )
            }
            VStack(spacing: 8) {
                Text("No comments yet")
                    .font(.system(size: 18, weight: .semibold, design: .rounded))
                    .foregroundColor(DesignSystem.Colors.text)
                Text("Be the first to share your thoughts")
                    .font(.system(size: 14))
                    .foregroundColor(DesignSystem.Colors.textSecondary)
            }
            Button(action: onComment) {
                Text("Add Comment")
                    .font(.system(size: 14, weight: .medium))
                    .foregroundColor(.white)
                    .padding(.horizontal, 20)
                    .padding(.vertical, 10)
                    .background(
                        LinearGradient(
                            colors: [DesignSystem.Colors.primary, DesignSystem.Colors.secondary],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .clipShape(Capsule())
                    .shadow(color: DesignSystem.Colors.primary.opacity(0.3), radius: 8, y: 4)
            }
        }
        .frame(maxWidth: .infinity)
        .padding(.vertical, 40)
        .onAppear {
            bubbleScale = 1.1
            bubbleRotation = 5
        }
    }
}
// Enhanced comment row with animations and interactions
struct EnhancedCommentRow: View {
    let comment: Comment
    let author: NDKUserProfile?
    let reactions: CommentReactions
    let isAnimated: Bool
    let onReply: () -> Void
    let onReact: (String) -> Void
    @State private var isPressed = false
    @State private var showReactions = false
    var body: some View {
        HStack(alignment: .top, spacing: 12) {
            // Enhanced author avatar
            EnhancedAsyncProfileImage(pubkey: comment.author, size: 36)
                .overlay(
                    Circle()
                        .stroke(DesignSystem.Colors.divider, lineWidth: 0.5)
                )
                .scaleEffect(isAnimated ? 1 : 0.8)
                .opacity(isAnimated ? 1 : 0)
            VStack(alignment: .leading, spacing: 8) {
                // Author info with verified badge
                HStack(spacing: 6) {
                    Text(authorName)
                        .font(.system(size: 15, weight: .semibold))
                        .foregroundColor(DesignSystem.Colors.text)
                    Text("·")
                        .foregroundColor(DesignSystem.Colors.textTertiary)
                    Text(RelativeTimeFormatter.shortRelativeTime(from: comment.createdAt))
                        .font(.system(size: 13))
                        .foregroundColor(DesignSystem.Colors.textTertiary)
                }
                .opacity(isAnimated ? 1 : 0)
                .offset(y: isAnimated ? 0 : 10)
                // Comment content with better typography
                Text(comment.content)
                    .font(.system(size: 15))
                    .foregroundColor(DesignSystem.Colors.text)
                    .fixedSize(horizontal: false, vertical: true)
                    .opacity(isAnimated ? 1 : 0)
                    .offset(y: isAnimated ? 0 : 10)
                // Interactive reaction bar
                HStack(spacing: 16) {
                    ReactionButton(
                        icon: "heart.fill",
                        count: reactions.likes,
                        isActive: reactions.userLiked,
                        activeColor: .red,
                        action: { onReact("like") }
                    )
                    ReactionButton(
                        icon: "bubble.right",
                        count: 0,
                        isActive: false,
                        action: onReply
                    )
                    ReactionButton(
                        icon: "bolt.fill",
                        count: reactions.zaps,
                        isActive: reactions.userZapped,
                        activeColor: DesignSystem.Colors.secondary,
                        action: { onReact("zap") }
                    )
                }
                .padding(.top, 4)
                .opacity(isAnimated ? 1 : 0)
                .offset(y: isAnimated ? 0 : 10)
            }
            Spacer(minLength: 0)
        }
        .padding(.vertical, 12)
        .contentShape(Rectangle())
        .scaleEffect(isPressed ? 0.97 : 1)
        .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isPressed)
        .onLongPressGesture(
            minimumDuration: 0.1,
            maximumDistance: .infinity,
            pressing: { pressing in
                isPressed = pressing
                if pressing {
                    HapticManager.shared.impact(.light)
                }
            },
            perform: {}
        )
    }
    private var authorName: String {
        author?.displayName ?? author?.name ?? PubkeyFormatter.formatCompact(comment.author)
    }
}
struct ReactionButton: View {
    let icon: String
    let count: Int
    let isActive: Bool
    var activeColor: Color = DesignSystem.Colors.primary
    let action: () -> Void
    @State private var isAnimating = false
    var body: some View {
        Button(action: {
            HapticManager.shared.impact(.light)
            withAnimation(.spring(response: 0.3, dampingFraction: 0.5)) {
                isAnimating = true
            }
            action()
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                isAnimating = false
            }
        }) {
            HStack(spacing: 4) {
                Image(systemName: icon)
                    .font(.system(size: 14))
                    .foregroundColor(isActive ? activeColor : DesignSystem.Colors.textSecondary)
                    .scaleEffect(isAnimating ? 1.3 : 1)
                    .rotationEffect(.degrees(isAnimating ? 15 : 0))
                if count > 0 {
                    Text("\(count)")
                        .font(.system(size: 12, weight: .medium))
                        .foregroundColor(isActive ? activeColor : DesignSystem.Colors.textSecondary)
                }
            }
        }
        .buttonStyle(PlainButtonStyle())
    }
}
// Comment reactions model
struct CommentReactions {
    var likes: Int = 0
    var zaps: Int = 0
    var userLiked: Bool = false
    var userZapped: Bool = false
}
// Loading dots animation
struct LoadingDots: View {
    @State private var currentDot = 0
    var body: some View {
        HStack(spacing: 4) {
            ForEach(0..<3) { index in
                Circle()
                    .fill(DesignSystem.Colors.primary)
                    .frame(width: 6, height: 6)
                    .scaleEffect(currentDot == index ? 1.2 : 0.8)
                    .opacity(currentDot == index ? 1 : 0.5)
            }
        }
        .onAppear {
            withAnimation(
                .easeInOut(duration: 0.6)
                .repeatForever()
            ) {
                currentDot = 2
            }
        }
    }
}
// MARK: - Subcomponents
struct CommentsList: View {
    let comments: [Comment]
    let commentAuthors: [String: NDKUserProfile]
    let commentReactions: [String: CommentReactions]
    @Binding var animatedCommentIds: Set<String>
    let onReply: (Comment) -> Void
    let onReact: (Comment, String) -> Void
    var body: some View {
        ScrollView {
            LazyVStack(alignment: .leading, spacing: 0) {
                ForEach(comments.indices, id: \.self) { index in
                    CommentRowWrapper(
                        comment: comments[index],
                        author: commentAuthors[comments[index].author],
                        reactions: commentReactions[comments[index].id] ?? CommentReactions(),
                        isAnimated: animatedCommentIds.contains(comments[index].id),
                        index: index,
                        isLast: index == comments.count - 1,
                        animatedCommentIds: $animatedCommentIds,
                        onReply: onReply,
                        onReact: onReact
                    )
                }
            }
            .padding(.horizontal)
        }
    }
}
// Simplified wrapper to reduce complexity
struct CommentRowWrapper: View {
    let comment: Comment
    let author: NDKUserProfile?
    let reactions: CommentReactions
    let isAnimated: Bool
    let index: Int
    let isLast: Bool
    @Binding var animatedCommentIds: Set<String>
    let onReply: (Comment) -> Void
    let onReact: (Comment, String) -> Void
    var body: some View {
        VStack(spacing: 0) {
            EnhancedCommentRow(
                comment: comment,
                author: author,
                reactions: reactions,
                isAnimated: isAnimated,
                onReply: { onReply(comment) },
                onReact: { reaction in onReact(comment, reaction) }
            )
            .id(comment.id)
            .transition(.asymmetric(
                insertion: .push(from: .bottom).combined(with: .opacity),
                removal: .push(from: .top).combined(with: .opacity)
            ))
            .onAppear {
                withAnimation(.spring(response: 0.5, dampingFraction: 0.7).delay(Double(index) * 0.05)) {
                    _ = animatedCommentIds.insert(comment.id)
                }
            }
            if !isLast {
                Divider()
                    .background(DesignSystem.Colors.divider.opacity(0.3))
                    .padding(.leading, 48)
            }
        }
    }
}
struct CommentsSectionHeader: View {
    let commentsCount: Int
    var body: some View {
        HStack {
            HStack(spacing: 8) {
                Image(systemName: "bubble.left.and.bubble.right.fill")
                    .font(.system(size: 20, weight: .semibold))
                    .foregroundStyle(
                        LinearGradient(
                            colors: [DesignSystem.Colors.primary, DesignSystem.Colors.secondary],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .symbolEffect(.bounce, value: commentsCount)
                Text("Comments")
                    .font(.system(size: 24, weight: .bold, design: .rounded))
                    .foregroundColor(DesignSystem.Colors.text)
                if commentsCount > 0 {
                    Text("\(commentsCount)")
                        .font(.system(size: 14, weight: .medium, design: .rounded))
                        .foregroundColor(.white)
                        .padding(.horizontal, 8)
                        .padding(.vertical, 4)
                        .background(
                            Capsule()
                                .fill(
                                    LinearGradient(
                                        colors: [DesignSystem.Colors.primary, DesignSystem.Colors.primary.opacity(0.8)],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                        )
                        .transition(.scale.combined(with: .opacity))
                }
            }
            Spacer()
        }
    }
}
// AsyncProfileImage has been replaced with EnhancedAsyncProfileImage
// Extension to handle reactions
extension CommentsSection {
    private func handleReaction(comment: Comment, reaction: String) {
        var reactions = commentReactions[comment.id] ?? CommentReactions()
        switch reaction {
        case "like":
            reactions.userLiked.toggle()
            reactions.likes += reactions.userLiked ? 1 : -1
        case "zap":
            reactions.userZapped.toggle()
            reactions.zaps += reactions.userZapped ? 1 : -1
        default:
            break
        }
        commentReactions[comment.id] = reactions
        // In a real app, this would publish reaction events to Nostr
        HapticManager.shared.impact(.light)
    }
}
</file>

<file path="Sources/Highlighter/Views/Components/CommentView.swift">
import SwiftUI
import NDKSwift
struct CommentView: View {
    let comment: Comment
    let authorProfile: NDKUserProfile?
    let isReply: Bool
    let onReply: () -> Void
    let onLike: () -> Void
    let onDelete: (() -> Void)?
    let onAuthorTap: () -> Void
    @State private var showOptions = false
    @State private var likeScale: CGFloat = 1.0
    init(
        comment: Comment,
        authorProfile: NDKUserProfile? = nil,
        onReply: @escaping () -> Void,
        onLike: @escaping () -> Void,
        onDelete: (() -> Void)? = nil,
        onAuthorTap: @escaping () -> Void
    ) {
        self.comment = comment
        self.authorProfile = authorProfile
        self.isReply = comment.isReply
        self.onReply = onReply
        self.onLike = onLike
        self.onDelete = onDelete
        self.onAuthorTap = onAuthorTap
    }
    var body: some View {
        HStack(alignment: .top, spacing: .ds.base) {
            // Reply indicator
            if isReply {
                Rectangle()
                    .fill(DesignSystem.Colors.divider)
                    .frame(width: 2)
                    .padding(.leading, 20)
            }
            // Author avatar
            Button(action: onAuthorTap) {
                AuthorAvatar(
                    pubkey: comment.author,
                    profile: authorProfile,
                    size: isReply ? 32 : 40
                )
            }
            .buttonStyle(.plain)
            VStack(alignment: .leading, spacing: .ds.small) {
                // Header
                HStack(alignment: .center, spacing: .ds.small) {
                    Button(action: onAuthorTap) {
                        Text(displayName)
                            .font(isReply ? .ds.footnoteMedium : .ds.bodyMedium)
                            .foregroundColor(.ds.text)
                    }
                    .buttonStyle(.plain)
                    Text("·")
                        .font(.ds.caption)
                        .foregroundColor(.ds.textTertiary)
                    Text(comment.formattedTime)
                        .font(.ds.caption)
                        .foregroundColor(.ds.textTertiary)
                    Spacer()
                    if let onDelete = onDelete {
                        Menu {
                            Button(role: .destructive, action: onDelete) {
                                Label("Delete", systemImage: "trash")
                            }
                        } label: {
                            Image(systemName: "ellipsis")
                                .font(.system(size: 14, weight: .medium))
                                .foregroundColor(.ds.textTertiary)
                                .frame(width: 24, height: 24)
                        }
                    }
                }
                // Content
                Text(comment.content)
                    .font(isReply ? .ds.callout : .ds.body)
                    .foregroundColor(.ds.text)
                    .multilineTextAlignment(.leading)
                    .fixedSize(horizontal: false, vertical: true)
                // Actions
                HStack(spacing: .ds.large) {
                    // Like button
                    Button(action: {
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {
                            likeScale = 1.2
                        }
                        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {
                                likeScale = 1.0
                            }
                        }
                        onLike()
                    }) {
                        HStack(spacing: 6) {
                            Image(systemName: comment.isLiked ? "heart.fill" : "heart")
                                .font(.system(size: 14, weight: .medium))
                                .foregroundColor(comment.isLiked ? .red : .ds.textTertiary)
                                .scaleEffect(likeScale)
                            if comment.likes > 0 {
                                Text("\(comment.likes)")
                                    .font(.ds.caption)
                                    .foregroundColor(.ds.textSecondary)
                            }
                        }
                    }
                    .buttonStyle(.plain)
                    // Reply button
                    Button(action: onReply) {
                        HStack(spacing: 6) {
                            Image(systemName: "arrowshape.turn.up.left")
                                .font(.system(size: 14, weight: .medium))
                                .foregroundColor(.ds.textTertiary)
                            Text("Reply")
                                .font(.ds.caption)
                                .foregroundColor(.ds.textSecondary)
                        }
                    }
                    .buttonStyle(.plain)
                    Spacer()
                }
                .padding(.top, .ds.micro)
            }
        }
        .padding(.vertical, .ds.small)
        .padding(.horizontal, .ds.screenPadding)
        .contentShape(Rectangle())
    }
    private var displayName: String {
        if let profile = authorProfile {
            return profile.displayName ?? profile.name ?? PubkeyFormatter.formatShort(comment.author)
        }
        return PubkeyFormatter.formatShort(comment.author)
    }
}
// MARK: - Author Avatar
struct AuthorAvatar: View {
    let pubkey: String
    let profile: NDKUserProfile?
    let size: CGFloat
    var body: some View {
        Group {
            if let picture = profile?.picture, let url = URL(string: picture) {
                AsyncImage(url: url) { phase in
                    switch phase {
                    case .success(let image):
                        image
                            .resizable()
                            .scaledToFill()
                    case .empty, .failure:
                        placeholderAvatar
                    @unknown default:
                        placeholderAvatar
                    }
                }
            } else {
                placeholderAvatar
            }
        }
        .frame(width: size, height: size)
        .clipShape(Circle())
        .overlay(
            Circle()
                .stroke(DesignSystem.Colors.border, lineWidth: 0.5)
        )
    }
    private var placeholderAvatar: some View {
        ZStack {
            Circle()
                .fill(
                    LinearGradient(
                        colors: [
                            Color(hex: generateColorForPubkey(pubkey)),
                            Color(hex: generateColorForPubkey(pubkey)).opacity(0.8)
                        ],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
            Text(avatarInitial)
                .font(.system(size: size * 0.45, weight: .medium))
                .foregroundColor(.white)
        }
    }
    private var avatarInitial: String {
        if let profile = profile {
            let name = profile.displayName ?? profile.name ?? "?"
            return String(name.prefix(1)).uppercased()
        }
        return PubkeyFormatter.formatForAvatar(pubkey)
    }
    private func generateColorForPubkey(_ pubkey: String) -> String {
        let colors = ["FF6B6B", "4ECDC4", "45B7D1", "96CEB4", "FECA57", "FF9FF3", "54A0FF"]
        let index = abs(pubkey.hashValue) % colors.count
        return colors[index]
    }
}
// MARK: - Comments Section
// MARK: - Supporting Views
struct LoadingCommentsView: View {
    @State private var shimmer = false
    var body: some View {
        VStack(spacing: .ds.base) {
            ForEach(0..<3) { _ in
                HStack(alignment: .top, spacing: .ds.base) {
                    Circle()
                        .fill(DesignSystem.Colors.surfaceSecondary)
                        .frame(width: 40, height: 40)
                        .opacity(shimmer ? 1 : 0.7)
                        .animation(.easeInOut(duration: 1).repeatForever(autoreverses: true), value: shimmer)
                    VStack(alignment: .leading, spacing: .ds.small) {
                        RoundedRectangle(cornerRadius: 4)
                            .fill(DesignSystem.Colors.surfaceSecondary)
                            .frame(width: 120, height: 14)
                            .opacity(shimmer ? 1 : 0.7)
                            .animation(.easeInOut(duration: 1).repeatForever(autoreverses: true), value: shimmer)
                        RoundedRectangle(cornerRadius: 4)
                            .fill(DesignSystem.Colors.surfaceSecondary)
                            .frame(width: 200, height: 12)
                            .opacity(shimmer ? 1 : 0.7)
                            .animation(.easeInOut(duration: 1).repeatForever(autoreverses: true), value: shimmer)
                    }
                    Spacer()
                }
                .padding(.horizontal, .ds.screenPadding)
                .padding(.vertical, .ds.small)
            }
        }
        .onAppear {
            shimmer = true
        }
    }
}
struct CommentInputField: View {
    @Binding var text: String
    let replyingTo: Comment?
    let isLoading: Bool
    let onCancel: () -> Void
    let onSubmit: () -> Void
    var body: some View {
        VStack(alignment: .leading, spacing: .ds.small) {
            if let replyingTo = replyingTo {
                HStack {
                    Text("Replying to @\(PubkeyFormatter.formatShort(replyingTo.author))")
                        .font(.ds.caption)
                        .foregroundColor(.ds.textSecondary)
                    Spacer()
                    Button(action: onCancel) {
                        Image(systemName: "xmark.circle.fill")
                            .font(.system(size: 16))
                            .foregroundColor(.ds.textTertiary)
                    }
                }
                .padding(.horizontal, .ds.screenPadding)
                .padding(.top, .ds.small)
            }
            HStack(alignment: .bottom, spacing: .ds.base) {
                TextField("Add a comment...", text: $text, axis: .vertical)
                    .textFieldStyle(.plain)
                    .lineLimit(1...4)
                    .padding(.ds.base)
                    .background(
                        RoundedRectangle(cornerRadius: .ds.medium)
                            .fill(DesignSystem.Colors.surface)
                            .overlay(
                                RoundedRectangle(cornerRadius: .ds.medium)
                                    .stroke(DesignSystem.Colors.border, lineWidth: 1)
                            )
                    )
                Button(action: onSubmit) {
                    if isLoading {
                        ProgressView()
                            .scaleEffect(0.8)
                    } else {
                        Image(systemName: "arrow.up.circle.fill")
                            .font(.system(size: 32))
                            .foregroundStyle(
                                text.isEmpty ? Color.ds.textTertiary : Color.ds.primary
                            )
                    }
                }
                .disabled(text.isEmpty || isLoading)
            }
            .padding(.horizontal, .ds.screenPadding)
            .padding(.vertical, .ds.base)
            .background(DesignSystem.Colors.surfaceSecondary)
        }
    }
}
</file>

<file path="Sources/Highlighter/Views/Components/EmptyHighlightsView.swift">
import SwiftUI
struct EmptyHighlightsView: View {
    @State private var animationPhase = false
    @State private var isPressed = false
    @State private var particleAnimation = false
    @State private var textGlow = false
    @State private var cardRotation: Double = 0
    let onCreateHighlight: (() -> Void)?
    init(onCreateHighlight: (() -> Void)? = nil) {
        self.onCreateHighlight = onCreateHighlight
    }
    var body: some View {
        ZStack {
            // Animated background particles
            ForEach(0..<6) { index in
                Circle()
                    .fill(
                        LinearGradient(
                            colors: [
                                DesignSystem.Colors.primary.opacity(0.3),
                                DesignSystem.Colors.secondary.opacity(0.2)
                            ],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .frame(width: particleAnimation ? CGFloat.random(in: 40...80) : 20)
                    .blur(radius: particleAnimation ? 15 : 5)
                    .offset(
                        x: particleAnimation ? CGFloat.random(in: -150...150) : 0,
                        y: particleAnimation ? CGFloat.random(in: -200...200) : 0
                    )
                    .opacity(particleAnimation ? 0 : 0.6)
                    .animation(
                        .easeInOut(duration: Double.random(in: 8...12))
                        .repeatForever(autoreverses: true)
                        .delay(Double(index) * 0.5),
                        value: particleAnimation
                    )
            }
            VStack(spacing: 40) {
                Spacer()
                // Enhanced central visualization
                ZStack {
                    // Outer glow ring
                    Circle()
                        .stroke(
                            LinearGradient(
                                colors: [
                                    DesignSystem.Colors.primary.opacity(0.4),
                                    DesignSystem.Colors.secondary.opacity(0.3)
                                ],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ),
                            lineWidth: 2
                        )
                        .frame(width: 120, height: 120)
                        .scaleEffect(animationPhase ? 1.1 : 0.95)
                        .opacity(animationPhase ? 0.6 : 0.3)
                        .blur(radius: 1)
                    // Inner material circle
                    Circle()
                        .fill(.thinMaterial)
                        .frame(width: 90, height: 90)
                        .overlay(
                            Circle()
                                .stroke(
                                    LinearGradient(
                                        colors: [
                                            Color.white.opacity(0.2),
                                            Color.white.opacity(0.05)
                                        ],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    ),
                                    lineWidth: 1
                                )
                        )
                        .shadow(
                            color: DesignSystem.Colors.primary.opacity(0.2),
                            radius: 20,
                            x: 0,
                            y: 5
                        )
                    // Animated highlighter icon
                    Image(systemName: "highlighter")
                        .font(.system(size: 40, weight: .light))
                        .foregroundStyle(
                            LinearGradient(
                                colors: [
                                    DesignSystem.Colors.primary,
                                    DesignSystem.Colors.secondary
                                ],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .rotationEffect(.degrees(animationPhase ? -5 : 5))
                        .shadow(
                            color: textGlow ? DesignSystem.Colors.primary.opacity(0.6) : Color.clear,
                            radius: 10
                        )
                }
                .scaleEffect(animationPhase ? 1.02 : 0.98)
                .rotation3DEffect(
                    .degrees(cardRotation),
                    axis: (x: 0, y: 1, z: 0),
                    perspective: 1
                )
                VStack(spacing: 20) {
                    Text("Your Wisdom Awaits")
                        .font(.system(size: 32, weight: .bold, design: .serif))
                        .foregroundStyle(
                            LinearGradient(
                                colors: [
                                    DesignSystem.Colors.text,
                                    DesignSystem.Colors.text.opacity(0.8)
                                ],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .opacity(animationPhase ? 1 : 0.8)
                        .shadow(
                            color: textGlow ? DesignSystem.Colors.text.opacity(0.3) : Color.clear,
                            radius: 8
                        )
                    Text("Transform your reading into a curated collection of insights.\nHighlight the ideas that shape your thinking.")
                        .font(.system(size: 16, weight: .regular, design: .default))
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                        .multilineTextAlignment(.center)
                        .frame(maxWidth: 320)
                        .lineSpacing(6)
                        .opacity(0.9)
                }
                // Enhanced CTA Button
                Button(action: {
                    HapticManager.shared.impact(.medium)
                    onCreateHighlight?()
                }) {
                    ZStack {
                        // Button background with gradient
                        Capsule()
                            .fill(
                                LinearGradient(
                                    colors: [
                                        DesignSystem.Colors.primary,
                                        DesignSystem.Colors.secondary
                                    ],
                                    startPoint: .leading,
                                    endPoint: .trailing
                                )
                            )
                            .overlay(
                                Capsule()
                                    .stroke(
                                        LinearGradient(
                                            colors: [
                                                Color.white.opacity(0.3),
                                                Color.white.opacity(0.1)
                                            ],
                                            startPoint: .topLeading,
                                            endPoint: .bottomTrailing
                                        ),
                                        lineWidth: 1
                                    )
                            )
                        HStack(spacing: 12) {
                            Image(systemName: "highlighter")
                                .font(.system(size: 18, weight: .semibold))
                                .rotationEffect(.degrees(isPressed ? -10 : 0))
                            Text("Begin Highlighting")
                                .font(.system(size: 17, weight: .semibold, design: .rounded))
                        }
                        .foregroundColor(.white)
                    }
                    .frame(height: 52)
                    .frame(maxWidth: 220)
                    .shadow(
                        color: DesignSystem.Colors.primary.opacity(0.4),
                        radius: isPressed ? 6 : 12,
                        x: 0,
                        y: isPressed ? 3 : 6
                    )
                }
                .scaleEffect(isPressed ? 0.94 : 1.0)
                .onLongPressGesture(minimumDuration: 0.05, maximumDistance: .infinity, pressing: { pressing in
                    withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                        isPressed = pressing
                    }
                }, perform: {})
                Spacer()
                // Enhanced bottom suggestions
                VStack(spacing: 20) {
                    Text("Get Started")
                        .font(.system(size: 14, weight: .semibold))
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                        .textCase(.uppercase)
                        .tracking(1)
                    HStack(spacing: 16) {
                        ActionPill(
                            icon: "doc.text.fill",
                            text: "Import",
                            color: .blue
                        )
                        ActionPill(
                            icon: "sparkle.magnifyingglass",
                            text: "Explore",
                            color: .purple
                        )
                        ActionPill(
                            icon: "person.2.fill",
                            text: "Connect",
                            color: .green
                        )
                    }
                }
                .padding(.bottom, 50)
                .opacity(0.9)
            }
        }
        .onAppear {
            startAnimations()
        }
    }
    private func startAnimations() {
        withAnimation(.easeInOut(duration: 4).repeatForever(autoreverses: true)) {
            animationPhase = true
        }
        withAnimation(.easeInOut(duration: 0.5)) {
            particleAnimation = true
        }
        withAnimation(.easeInOut(duration: 2).repeatForever(autoreverses: true).delay(0.5)) {
            textGlow = true
        }
        withAnimation(.easeInOut(duration: 10).repeatForever(autoreverses: true)) {
            cardRotation = 5
        }
    }
}
struct ActionPill: View {
    let icon: String
    let text: String
    let color: Color
    @State private var isHovered = false
    @State private var isPressed = false
    var body: some View {
        HStack(spacing: 8) {
            Image(systemName: icon)
                .font(.system(size: 14, weight: .semibold))
                .foregroundColor(isHovered ? .white : color)
            Text(text)
                .font(.system(size: 13, weight: .semibold))
                .foregroundColor(isHovered ? .white : DesignSystem.Colors.text)
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 10)
        .background(
            ZStack {
                if isHovered {
                    Capsule()
                        .fill(
                            LinearGradient(
                                colors: [color, color.opacity(0.8)],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .shadow(
                            color: color.opacity(0.4),
                            radius: 8,
                            x: 0,
                            y: 4
                        )
                } else {
                    Capsule()
                        .fill(Color.ds.surfaceSecondary)
                        .overlay(
                            Capsule()
                                .stroke(color.opacity(0.3), lineWidth: 1)
                        )
                }
            }
        )
        .scaleEffect(isPressed ? 0.92 : (isHovered ? 1.08 : 1))
        .onHover { hovering in
            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                isHovered = hovering
            }
        }
        .onTapGesture {
            withAnimation(.spring(response: 0.2, dampingFraction: 0.8)) {
                isPressed = true
            }
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                isPressed = false
            }
            HapticManager.shared.impact(.light)
        }
    }
}
</file>

<file path="Sources/Highlighter/Views/Components/EnhancedTabBar.swift">
import SwiftUI
import UIKit
// MARK: - Liquid Morphing Tab Bar with Advanced Animations
struct EnhancedTabBar: View {
    @Binding var selectedTab: ContentView.Tab
    @State private var animatingTab: ContentView.Tab?
    @State private var tabWidths: [ContentView.Tab: CGFloat] = [:]
    @State private var tabOffsets: [ContentView.Tab: CGFloat] = [:]
    @State private var bubbleOffset: CGFloat = 0
    @State private var bubbleWidth: CGFloat = 60
    @State private var bubbleHeight: CGFloat = 52
    @State private var showTabLabels = true
    @State private var selectedTabScale: CGFloat = 1
    @Namespace private var animation
    // Haptic feedback
    private let impactMedium = UIImpactFeedbackGenerator(style: .medium)
    private let impactLight = UIImpactFeedbackGenerator(style: .light)
    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .bottom) {
                // Clean minimal background
                Rectangle()
                    .fill(.ultraThinMaterial)
                    .overlay(
                        Rectangle()
                            .fill(Color.ds.surface.opacity(0.85))
                    )
                    .overlay(
                        Divider()
                            .frame(height: 0.5)
                            .foregroundColor(Color.ds.border),
                        alignment: .top
                    )
                    .frame(height: 56)
                // Subtle selection indicator
                if let offset = tabOffsets[selectedTab] {
                    Rectangle()
                        .fill(DesignSystem.Colors.primary)
                        .frame(width: 28, height: 2)
                        .offset(x: offset, y: -24)
                        .animation(
                            .easeInOut(duration: 0.25),
                            value: selectedTab
                        )
                }
                // Tab items
                HStack(spacing: 0) {
                    ForEach(ContentView.Tab.allCases, id: \.self) { tab in
                        TabItem(
                            tab: tab,
                            isSelected: selectedTab == tab,
                            animatingTab: animatingTab,
                            showLabel: showTabLabels,
                            namespace: animation
                        )
                        .frame(maxWidth: .infinity)
                        .background(
                            GeometryReader { itemGeometry in
                                Color.clear
                                    .onAppear {
                                        let frame = itemGeometry.frame(in: .named("tabBar"))
                                        tabOffsets[tab] = frame.midX - geometry.size.width / 2
                                        tabWidths[tab] = frame.width
                                    }
                                    .onChange(of: geometry.size) { _, _ in
                                        let frame = itemGeometry.frame(in: .named("tabBar"))
                                        tabOffsets[tab] = frame.midX - geometry.size.width / 2
                                        tabWidths[tab] = frame.width
                                    }
                            }
                        )
                        .onTapGesture {
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                if selectedTab != tab {
                                    impactMedium.impactOccurred()
                                    animatingTab = tab
                                    selectedTab = tab
                                    // Trigger selection animation
                                    triggerSelectionAnimation(for: tab)
                                    // Clear animation state
                                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                                        animatingTab = nil
                                    }
                                } else {
                                    // Double tap effect
                                    impactLight.impactOccurred()
                                    withAnimation(.spring(response: 0.2, dampingFraction: 0.5)) {
                                        animatingTab = tab
                                    }
                                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
                                        animatingTab = nil
                                    }
                                }
                            }
                        }
                        .onLongPressGesture {
                            impactMedium.impactOccurred()
                            withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {
                                showTabLabels.toggle()
                            }
                        }
                    }
                }
                .padding(.horizontal, 8)
                .padding(.top, 6)
                .padding(.bottom, 20)
                .coordinateSpace(name: "tabBar")
            }
            .frame(height: 72)
        }
        .frame(height: 72)
        .onAppear {
            impactMedium.prepare()
            impactLight.prepare()
            updateBubbleWidth(for: selectedTab)
        }
    }
    private func updateBubbleWidth(for tab: ContentView.Tab) {
        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
            switch tab {
            case .home, .profile:
                bubbleWidth = 65
                bubbleHeight = 52
            case .feed, .library:
                bubbleWidth = 70
                bubbleHeight = 54
            case .discover:
                bubbleWidth = 75
                bubbleHeight = 56
            }
        }
    }
    private func triggerSelectionAnimation(for tab: ContentView.Tab) {
        // Simple selection feedback
    }
}
struct TabItem: View {
    let tab: ContentView.Tab
    let isSelected: Bool
    let animatingTab: ContentView.Tab?
    let showLabel: Bool
    let namespace: Namespace.ID
    @State private var iconRotation: Double = 0
    @State private var iconScale: CGFloat = 1
    var body: some View {
        VStack(spacing: showLabel ? 4 : 0) {
            ZStack {
                // Background icon (for smooth transitions)
                Image(systemName: tab.icon)
                    .font(.system(size: 22, weight: .medium))
                    .opacity(isSelected ? 0 : 1)
                    .foregroundColor(.ds.textSecondary)
                // Filled icon with animations
                Image(systemName: tab.filledIcon)
                    .font(.system(size: 22, weight: .semibold))
                    .opacity(isSelected ? 1 : 0)
                    .foregroundColor(.ds.primary)
                    .rotationEffect(.degrees(iconRotation))
                    .scaleEffect(iconScale)
            }
            .frame(width: 24, height: 24)
            .animation(.spring(response: 0.3, dampingFraction: 0.6), value: isSelected)
            if showLabel {
                Text(tab.title)
                    .font(.system(size: 10, weight: isSelected ? .semibold : .medium))
                    .foregroundColor(isSelected ? .ds.primary : .ds.textSecondary)
                    .transition(.asymmetric(
                        insertion: .push(from: .bottom).combined(with: .opacity),
                        removal: .push(from: .top).combined(with: .opacity)
                    ))
            }
        }
        .scaleEffect(animatingTab == tab ? 1.15 : 1.0)
        .animation(.spring(response: 0.3, dampingFraction: 0.6), value: animatingTab)
        .onChange(of: isSelected) { _, newValue in
            if newValue {
                // Animate icon when selected
                withAnimation(.spring(response: 0.4, dampingFraction: 0.6)) {
                    iconScale = 1.2
                    iconRotation = 10
                }
                withAnimation(.spring(response: 0.4, dampingFraction: 0.6).delay(0.1)) {
                    iconScale = 1.0
                    iconRotation = 0
                }
            }
        }
    }
}
// MARK: - Supporting Views
#Preview {
    ZStack {
        // Background content
        LinearGradient(
            colors: [.blue, .purple],
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
        .ignoresSafeArea()
        // Tab bar at bottom
        VStack {
            Spacer()
            EnhancedTabBar(selectedTab: .constant(.home))
        }
    }
}
</file>

<file path="Sources/Highlighter/Views/Components/LoadingHighlightView.swift">
import SwiftUI
struct LoadingHighlightView: View {
    @State private var shimmerOffset: CGFloat = -200
    @State private var pulseScale: CGFloat = 1.0
    @State private var rotationAngle: Double = 0
    @State private var particleScale: CGFloat = 0
    @State private var textOpacity: Double = 0
    @State private var loadingPhase = 0
    let loadingMessages = [
        "Curating your highlights",
        "Finding wisdom in words",
        "Preparing your collection"
    ]
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                backgroundView
                floatingParticles
                mainContent
            }
        }
        .onAppear {
            startAnimations()
        }
    }
    @ViewBuilder
    private var backgroundView: some View {
        MeshGradientBackground()
            .opacity(0.3)
            .ignoresSafeArea()
    }
    @ViewBuilder
    private var floatingParticles: some View {
        ForEach(0..<8) { index in
            floatingParticle(index: index)
        }
    }
    @ViewBuilder
    private func floatingParticle(index: Int) -> some View {
        let angle = rotationAngle * .pi / 180 + Double(index) * .pi / 4
        Circle()
            .fill(
                RadialGradient(
                    colors: [
                        DesignSystem.Colors.primary.opacity(0.4),
                        DesignSystem.Colors.primary.opacity(0)
                    ],
                    center: .center,
                    startRadius: 5,
                    endRadius: 20
                )
            )
            .frame(width: 30)
            .offset(
                x: cos(angle) * 80,
                y: sin(angle) * 80
            )
            .scaleEffect(particleScale)
            .blur(radius: 2)
            .opacity(0.6)
    }
    @ViewBuilder
    private var mainContent: some View {
        VStack(spacing: 32) {
            Spacer()
            animatedIcon
            loadingContent
            Spacer()
            hintText
        }
    }
    @ViewBuilder
    private var animatedIcon: some View {
        ZStack {
            outerRings
            centralOrb
            quoteIcon
        }
    }
    @ViewBuilder
    private var outerRings: some View {
        ForEach(0..<3) { index in
            animatedRing(index: index)
        }
    }
    @ViewBuilder
    private func animatedRing(index: Int) -> some View {
        Circle()
            .stroke(
                LinearGradient(
                    colors: [
                        DesignSystem.Colors.primary.opacity(0.3 - Double(index) * 0.1),
                        DesignSystem.Colors.secondary.opacity(0.2 - Double(index) * 0.05)
                    ],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                ),
                lineWidth: 2
            )
            .frame(
                width: 140 + CGFloat(index * 30),
                height: 140 + CGFloat(index * 30)
            )
            .scaleEffect(pulseScale + CGFloat(index) * 0.05)
            .opacity(1 - Double(index) * 0.3)
            .rotationEffect(.degrees(rotationAngle * (index % 2 == 0 ? 1 : -1)))
    }
    @ViewBuilder
    private var centralOrb: some View {
        Circle()
            .fill(.thinMaterial)
            .frame(width: 100, height: 100)
            .overlay(centralOrbGradient)
            .overlay(centralOrbStroke)
            .shadow(
                color: DesignSystem.Colors.primary.opacity(0.3),
                radius: 20,
                x: 0,
                y: 0
            )
    }
    @ViewBuilder
    private var centralOrbGradient: some View {
        Circle()
            .fill(
                LinearGradient(
                    colors: [
                        DesignSystem.Colors.primary.opacity(0.3),
                        DesignSystem.Colors.secondary.opacity(0.2)
                    ],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
            )
    }
    @ViewBuilder
    private var centralOrbStroke: some View {
        Circle()
            .stroke(
                LinearGradient(
                    colors: [
                        Color.white.opacity(0.3),
                        Color.white.opacity(0.1)
                    ],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                ),
                lineWidth: 1
            )
    }
    @ViewBuilder
    private var quoteIcon: some View {
        Image(systemName: "quote.opening")
            .font(.system(size: 42, weight: .thin))
            .foregroundStyle(
                LinearGradient(
                    colors: [
                        DesignSystem.Colors.primary,
                        DesignSystem.Colors.secondary
                    ],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
            )
            .scaleEffect(pulseScale * 0.9)
            .rotationEffect(.degrees(sin(rotationAngle * .pi / 180) * 5))
    }
    @ViewBuilder
    private var loadingContent: some View {
        VStack(spacing: 20) {
            loadingText
            loadingIndicator
            progressDots
        }
    }
    @ViewBuilder
    private var loadingText: some View {
        Text(loadingMessages[loadingPhase % loadingMessages.count])
            .font(.system(size: 22, weight: .medium, design: .rounded))
            .foregroundStyle(
                LinearGradient(
                    colors: [
                        DesignSystem.Colors.text,
                        DesignSystem.Colors.text.opacity(0.8)
                    ],
                    startPoint: .leading,
                    endPoint: .trailing
                )
            )
            .opacity(textOpacity)
            .animation(.easeInOut(duration: 0.5), value: loadingPhase)
    }
    @ViewBuilder
    private var loadingIndicator: some View {
        ZStack {
            Capsule()
                .fill(DesignSystem.Colors.surfaceSecondary)
                .frame(width: 240, height: 6)
            shimmerProgress
        }
    }
    @ViewBuilder
    private var shimmerProgress: some View {
        GeometryReader { geo in
            Capsule()
                .fill(shimmerGradient)
                .frame(width: 240, height: 6)
                .mask(shimmerMask)
        }
        .frame(width: 240, height: 6)
    }
    private var shimmerGradient: LinearGradient {
        LinearGradient(
            colors: [
                DesignSystem.Colors.primary,
                DesignSystem.Colors.secondary,
                DesignSystem.Colors.primary
            ],
            startPoint: .leading,
            endPoint: .trailing
        )
    }
    @ViewBuilder
    private var shimmerMask: some View {
        Rectangle()
            .fill(
                LinearGradient(
                    stops: [
                        .init(color: .clear, location: 0),
                        .init(color: .white, location: 0.5),
                        .init(color: .clear, location: 1)
                    ],
                    startPoint: .leading,
                    endPoint: .trailing
                )
            )
            .frame(width: 100)
            .offset(x: shimmerOffset)
    }
    @ViewBuilder
    private var progressDots: some View {
        HStack(spacing: 8) {
            ForEach(0..<3) { index in
                progressDot(index: index)
            }
        }
    }
    @ViewBuilder
    private func progressDot(index: Int) -> some View {
        Circle()
            .fill(
                index == loadingPhase % 3
                    ? DesignSystem.Colors.primary
                    : DesignSystem.Colors.textTertiary.opacity(0.3)
            )
            .frame(width: 6, height: 6)
            .scaleEffect(index == loadingPhase % 3 ? 1.2 : 1)
            .animation(.spring(response: 0.3), value: loadingPhase)
    }
    @ViewBuilder
    private var hintText: some View {
        Text("Preparing your personalized feed")
            .font(.system(size: 14, weight: .regular))
            .foregroundColor(DesignSystem.Colors.textSecondary)
            .opacity(0.7 * textOpacity)
            .padding(.bottom, 50)
    }
    private func startAnimations() {
        // Pulse animation
        withAnimation(.easeInOut(duration: 1.8).repeatForever(autoreverses: true)) {
            pulseScale = 1.15
        }
        // Rotation animation
        withAnimation(.linear(duration: 20).repeatForever(autoreverses: false)) {
            rotationAngle = 360
        }
        // Particle scale animation
        withAnimation(.easeOut(duration: 0.8)) {
            particleScale = 1
        }
        // Shimmer animation
        withAnimation(.linear(duration: 1.5).repeatForever(autoreverses: false)) {
            shimmerOffset = 340
        }
        // Text fade in
        withAnimation(.easeIn(duration: 0.5)) {
            textOpacity = 1
        }
        // Phase animation
        Timer.scheduledTimer(withTimeInterval: 2.0, repeats: true) { _ in
            withAnimation(.easeInOut(duration: 0.3)) {
                loadingPhase += 1
            }
        }
    }
}
struct LoadingBar: View {
    let delay: Double
    @State private var offset: CGFloat = -200
    var body: some View {
        GeometryReader { geometry in
            RoundedRectangle(cornerRadius: 4)
                .fill(DesignSystem.Colors.surface)
                .frame(height: 4)
                .overlay(
                    RoundedRectangle(cornerRadius: 4)
                        .fill(
                            LinearGradient(
                                colors: [
                                    Color.clear,
                                    DesignSystem.Colors.primary.opacity(0.8),
                                    Color.clear
                                ],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .frame(width: 100)
                        .offset(x: offset)
                )
                .clipped()
                .onAppear {
                    withAnimation(
                        .linear(duration: 1.5)
                        .repeatForever(autoreverses: false)
                        .delay(delay)
                    ) {
                        offset = geometry.size.width + 100
                    }
                }
        }
        .frame(height: 4)
    }
}
</file>

<file path="Sources/Highlighter/Views/Components/UnifiedCard.swift">
import SwiftUI
import NDKSwift
// MARK: - Unified Card System
// A flexible, reusable card component that consolidates multiple similar card implementations
struct UnifiedCard<Content: View>: View {
    let content: Content
    let variant: CardVariant
    let isSelected: Bool
    let action: (() -> Void)?
    init(
        variant: CardVariant = .standard,
        isSelected: Bool = false,
        action: (() -> Void)? = nil,
        @ViewBuilder content: () -> Content
    ) {
        self.variant = variant
        self.isSelected = isSelected
        self.action = action
        self.content = content()
    }
    var body: some View {
        Group {
            if let action = action {
                Button(action: action) {
                    cardContent
                }
                .buttonStyle(PlainButtonStyle())
            } else {
                cardContent
            }
        }
    }
    @ViewBuilder
    private var cardContent: some View {
        content
            .padding(variant.padding)
            .frame(maxWidth: variant.maxWidth, minHeight: variant.minHeight)
            .background(variant.backgroundView)
            .overlay(variant.borderView(isSelected: isSelected))
            .clipShape(RoundedRectangle(cornerRadius: variant.cornerRadius, style: .continuous))
            .shadow(
                color: variant.shadowColor(isSelected: isSelected),
                radius: variant.shadowRadius(isSelected: isSelected),
                x: 0,
                y: variant.shadowY(isSelected: isSelected)
            )
            .scaleEffect(isSelected ? 1.02 : 1.0)
            .opacity(isSelected ? 1.0 : 0.95)
            .animation(AnimationSystem.Curves.premiumSpring, value: isSelected)
            .premiumCardInteraction()
            .premiumEntrance(delay: 0.1)
    }
}
// MARK: - Card Variants
enum CardVariant {
    case standard
    case compact
    case glass
    case elevated
    case highlight
    case placeholder
    var padding: CGFloat {
        switch self {
        case .standard, .glass, .elevated, .highlight: return DesignSystem.Spacing.cardPadding
        case .compact: return DesignSystem.Spacing.base
        case .placeholder: return DesignSystem.Spacing.cardPadding
        }
    }
    var maxWidth: CGFloat? {
        switch self {
        case .compact: return 280
        default: return nil
        }
    }
    var minHeight: CGFloat? {
        switch self {
        case .compact: return 140
        case .elevated: return 160
        default: return nil
        }
    }
    var cornerRadius: CGFloat {
        switch self {
        case .standard, .elevated, .highlight: return DesignSystem.CornerRadius.large
        case .compact, .glass: return DesignSystem.CornerRadius.medium
        case .placeholder: return DesignSystem.CornerRadius.large
        }
    }
    @ViewBuilder
    var backgroundView: some View {
        switch self {
        case .glass:
            RoundedRectangle(cornerRadius: cornerRadius, style: .continuous)
                .fill(.ultraThinMaterial)
        case .placeholder:
            RoundedRectangle(cornerRadius: cornerRadius, style: .continuous)
                .fill(DesignSystem.Colors.surface)
        default:
            RoundedRectangle(cornerRadius: cornerRadius, style: .continuous)
                .fill(DesignSystem.Colors.surface)
        }
    }
    @ViewBuilder
    func borderView(isSelected: Bool) -> some View {
        RoundedRectangle(cornerRadius: cornerRadius, style: .continuous)
            .stroke(
                borderGradient(isSelected: isSelected),
                lineWidth: borderWidth(isSelected: isSelected)
            )
    }
    private func borderGradient(isSelected: Bool) -> LinearGradient {
        if isSelected {
            return LinearGradient(
                colors: [DesignSystem.Colors.secondary, DesignSystem.Colors.primary],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        }
        switch self {
        case .highlight:
            return LinearGradient(
                colors: [DesignSystem.Colors.secondary.opacity(0.3), Color.clear],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        case .glass:
            return LinearGradient(
                colors: [Color.white.opacity(0.3), Color.white.opacity(0.1)],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        default:
            return LinearGradient(
                colors: [DesignSystem.Colors.border, DesignSystem.Colors.border.opacity(0.5)],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        }
    }
    private func borderWidth(isSelected: Bool) -> CGFloat {
        switch self {
        case .highlight where isSelected: return 2
        case .highlight: return 1.5
        default: return isSelected ? 2 : 1
        }
    }
    func shadowColor(isSelected: Bool) -> Color {
        if isSelected {
            return DesignSystem.Colors.secondary.opacity(0.3)
        }
        switch self {
        case .standard: return DesignSystem.Shadow.small.color
        case .compact: return DesignSystem.Shadow.subtle.color
        case .glass: return Color.black.opacity(0.1)
        case .elevated: return DesignSystem.Shadow.medium.color
        case .highlight: return Color.black.opacity(0.08)
        case .placeholder: return DesignSystem.Shadow.subtle.color
        }
    }
    func shadowRadius(isSelected: Bool) -> CGFloat {
        if isSelected { return 12 }
        switch self {
        case .standard: return DesignSystem.Shadow.small.radius
        case .compact: return DesignSystem.Shadow.subtle.radius
        case .glass: return 8
        case .elevated: return DesignSystem.Shadow.medium.radius
        case .highlight: return 8
        case .placeholder: return DesignSystem.Shadow.subtle.radius
        }
    }
    func shadowY(isSelected: Bool) -> CGFloat {
        if isSelected { return 6 }
        switch self {
        case .standard: return DesignSystem.Shadow.small.y
        case .compact: return DesignSystem.Shadow.subtle.y
        case .glass: return 4
        case .elevated: return DesignSystem.Shadow.medium.y
        case .highlight: return 4
        case .placeholder: return DesignSystem.Shadow.subtle.y
        }
    }
}
// MARK: - Specialized Card Components
// Highlight Card using the unified system
struct ModernHighlightCard: View {
    let highlight: HighlightEvent
    @EnvironmentObject var appState: AppState
    @State private var author: NDKUserProfile?
    @State private var isZapped = false
    @State private var showDetail = false
    var body: some View {
        UnifiedCard(
            variant: .standard,
            isSelected: isZapped,
            action: { showDetail = true }
        ) {
            VStack(alignment: .leading, spacing: 12) {
                // Quote
                Text("\"\(highlight.content)\"")
                    .font(.ds.title3)
                    .fontWeight(.medium)
                    .foregroundColor(.ds.text)
                    .multilineTextAlignment(.leading)
                    .lineLimit(4)
                    .frame(maxWidth: .infinity, alignment: .leading)
                // Comment if available
                if let comment = highlight.comment {
                    Text(comment)
                        .font(.ds.body)
                        .foregroundColor(.ds.textSecondary)
                        .lineLimit(2)
                        .padding(.top, .ds.micro)
                }
                // Metadata row
                HStack {
                    // Author
                    HStack(spacing: .ds.small) {
                        Image(systemName: "person.circle.fill")
                            .font(.system(size: 20))
                            .foregroundColor(.ds.primary)
                        Text(author?.name ?? author?.displayName ?? String(highlight.author.prefix(8)))
                            .font(.ds.caption)
                            .fontWeight(.medium)
                            .foregroundColor(.ds.text)
                    }
                    Spacer()
                    // Actions
                    HStack(spacing: .ds.medium) {
                        // Zap button
                        Button(action: zapHighlight) {
                            Image(systemName: isZapped ? "bolt.fill" : "bolt")
                                .font(.system(size: 16))
                                .foregroundColor(isZapped ? .ds.warning : .ds.textSecondary)
                        }
                        .buttonStyle(PlainButtonStyle())
                        // Time
                        Text(RelativeTimeFormatter.relativeTime(from: highlight.createdAt))
                            .font(.ds.caption)
                            .foregroundColor(.ds.textSecondary)
                    }
                }
                // Source indicator
                if let url = highlight.url {
                    HStack(spacing: .ds.micro) {
                        Image(systemName: "link")
                            .font(.system(size: 12))
                        Text(URL(string: url)?.host ?? "Source")
                            .font(.ds.caption)
                    }
                    .foregroundColor(.ds.primary)
                }
            }
        }
        .task {
            await loadAuthor()
        }
        .sheet(isPresented: $showDetail) {
            HighlightDetailView(highlight: highlight)
                .environmentObject(appState)
        }
    }
    private func loadAuthor() async {
        guard let ndk = appState.ndk else { return }
        for await profile in await ndk.profileManager.observe(for: highlight.author, maxAge: TimeConstants.hour) {
            await MainActor.run {
                self.author = profile
            }
            break
        }
    }
    private func zapHighlight() {
        isZapped.toggle()
        HapticManager.shared.impact(.light)
        // Note: Actual zapping requires wallet integration (NIP-57/NIP-60)
        // This demo app only simulates the UI interaction
    }
}
// Compact Highlight Card using the unified system
struct ModernCompactHighlightCard: View {
    let highlight: HighlightEvent
    @State private var showDetail = false
    var body: some View {
        UnifiedCard(
            variant: .compact,
            action: { showDetail = true }
        ) {
            VStack(alignment: .leading, spacing: .ds.small) {
                Text("\"\(highlight.content)\"")
                    .font(.ds.body)
                    .fontWeight(.medium)
                    .foregroundColor(.ds.text)
                    .multilineTextAlignment(.leading)
                    .lineLimit(3)
                    .frame(minHeight: 60, alignment: .topLeading)
                HStack {
                    Image(systemName: "person.circle.fill")
                        .font(.system(size: 16))
                        .foregroundColor(.ds.primary)
                    Text(String(highlight.author.prefix(8)))
                        .font(.ds.caption)
                        .foregroundColor(.ds.textSecondary)
                    Spacer()
                    Image(systemName: "bolt")
                        .font(.system(size: 14))
                        .foregroundColor(.ds.textSecondary)
                }
            }
        }
        .sheet(isPresented: $showDetail) {
            HighlightDetailView(highlight: highlight)
        }
    }
}
// Placeholder Card using the unified system
struct PlaceholderCard: View {
    let lines: Int
    init(lines: Int = 3) {
        self.lines = lines
    }
    var body: some View {
        UnifiedCard(variant: .placeholder) {
            VStack(alignment: .leading, spacing: 8) {
                ForEach(0..<lines, id: \.self) { index in
                    RoundedRectangle(cornerRadius: 4)
                        .fill(Color.gray.opacity(index == 0 ? 0.2 : 0.15))
                        .frame(height: 16)
                        .frame(maxWidth: index == lines - 1 ? .infinity * 0.7 : .infinity)
                }
            }
        }
        .shimmer()
    }
}
#Preview {
    ScrollView {
        VStack(spacing: 16) {
            // Standard cards
            ModernHighlightCard(
                highlight: HighlightEvent(
                    id: "1",
                    event: NDKEvent(id: "", pubkey: "", createdAt: 0, kind: 9802, tags: [], content: "", sig: ""),
                    content: PreviewData.highlightTexts[0],
                    author: "npub1sg6plzptd64u62a878hep2kev88swjh3tw00gjsfl8f237lmu63q0uf63m",
                    createdAt: Date(),
                    context: PreviewData.highlightContexts[0],
                    url: PreviewData.articleURLs[0],
                    referencedEvent: nil,
                    attributedAuthors: [],
                    comment: "A profound insight about technology"
                )
            )
            .environmentObject(AppState())
            // Compact cards
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 16) {
                    ForEach(0..<3) { _ in
                        ModernCompactHighlightCard(
                            highlight: HighlightEvent(
                                id: "2",
                                event: NDKEvent(id: "", pubkey: "", createdAt: 0, kind: 9802, tags: [], content: "", sig: ""),
                                content: "Innovation distinguishes between a leader and a follower.",
                                author: "test2",
                                createdAt: Date(),
                                context: nil,
                                url: nil,
                                referencedEvent: nil,
                                attributedAuthors: [],
                                comment: nil
                            )
                        )
                    }
                }
                .padding(.horizontal)
            }
            // Placeholder cards
            PlaceholderCard(lines: 4)
            PlaceholderCard(lines: 2)
        }
        .padding()
    }
    .background(DesignSystem.Colors.background)
}
</file>

<file path="Sources/Highlighter/Views/Components/ZapButton.swift">
import SwiftUI
import NDKSwift
struct ZapButton: View {
    let event: NDKEvent
    let size: ButtonSize
    var highlight: HighlightEvent? = nil
    var article: Article? = nil
    var onZapComplete: (() -> Void)? = nil
    @EnvironmentObject var appState: AppState
    @StateObject private var lightning = LightningService()
    @State private var zapState: ZapState = .idle
    @State private var showZapSheet = false
    @State private var showPaymentFlow = false
    @State private var zapAmount = 21
    @State private var showParticles = false
    @State private var particles: [ZapParticle] = []
    enum ButtonSize {
        case small, medium, large
        var iconSize: CGFloat {
            switch self {
            case .small: return 16
            case .medium: return 20
            case .large: return 24
            }
        }
        var padding: CGFloat {
            switch self {
            case .small: return 8
            case .medium: return 12
            case .large: return 16
            }
        }
    }
    enum ZapState {
        case idle
        case zapping
        case zapped
        case failed
        var iconName: String {
            switch self {
            case .idle: return "bolt"
            case .zapping: return "bolt"
            case .zapped: return "bolt.fill"
            case .failed: return "bolt.slash"
            }
        }
        var color: Color {
            switch self {
            case .idle: return DesignSystem.Colors.textSecondary
            case .zapping: return DesignSystem.Colors.primary.opacity(0.7)
            case .zapped: return DesignSystem.Colors.primary
            case .failed: return Color.red.opacity(0.7)
            }
        }
    }
    var body: some View {
        ZStack {
            // Particle effects layer
            ForEach(particles) { particle in
                ZapParticleView(particle: particle)
            }
            Button(action: handleZap) {
                HStack(spacing: 4) {
                    Image(systemName: zapState.iconName)
                        .font(.system(size: size.iconSize, weight: zapState == .zapped ? .semibold : .regular))
                        .foregroundColor(zapState.color)
                        .animation(.easeInOut(duration: 0.2), value: zapState)
                    if zapState == .zapped {
                        Text("\(zapAmount)")
                            .font(.system(size: size.iconSize * 0.7, weight: .medium, design: .rounded))
                            .foregroundColor(zapState.color)
                            .transition(.opacity)
                    }
                }
                .padding(.horizontal, size.padding * 0.8)
                .padding(.vertical, size.padding * 0.6)
            }
            .enhancedZapButton()
            .contextualFeedback(isActive: zapState == .zapping)
            .disabled(zapState == .zapping)
            .opacity(zapState == .failed ? 0.6 : 1.0)
        }
        .sheet(isPresented: $showZapSheet) {
            // Smart zap sheet will be enabled when Lightning service is integrated
            ZapAmountSheet(
                event: event,
                zapAmount: $zapAmount,
                onZap: performZap
            )
            .environmentObject(appState)
        }
        .sheet(isPresented: $showPaymentFlow) {
            if let highlight = highlight {
                LightningPaymentFlowView(
                    highlight: highlight,
                    authorProfile: nil, // Would fetch from ProfileManager
                    highlighterProfile: nil, // Would fetch from ProfileManager
                    curatorProfile: nil // Would fetch from ProfileManager
                )
            }
        }
    }
    private func handleZap() {
        HapticManager.shared.impact(.light)
        // If we have a highlight event and Lightning is connected, show the smart payment flow
        if highlight != nil && lightning.isConnected {
            showPaymentFlow = true
        } else if zapState == .zapped {
            // If already zapped, show amount picker to zap again
            showZapSheet = true
        } else {
            // Quick zap with default amount
            performZap(amount: zapAmount)
        }
    }
    private func performZap(amount: Int) {
        guard appState.ndk != nil else { return }
        zapState = .zapping
        HapticManager.shared.impact(.medium)
        Task {
            // Note: Actual zapping requires wallet integration (NIP-57/NIP-60)
            // This would create a zap event (kind 9735) and send payment
            // This demo app simulates the zap UI without actual payment
            await MainActor.run {
                zapAmount = amount
                withAnimation(.spring(response: 0.5, dampingFraction: 0.7)) {
                    zapState = .zapped
                }
                // Use advanced particle effect for smart splits
                if highlight != nil {
                    createAdvancedParticleEffect(splitCount: 3) // Author, Highlighter, Platform
                } else {
                    createParticleEffect()
                }
                HapticManager.shared.notification(.success)
                // Add a subtle second feedback after delay
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                    HapticManager.shared.impact(.light)
                }
            }
            // Perform the actual zap with no comment for now
            performSmartZap(amount: amount, comment: nil)
        }
    }
    private func performSmartZap(amount: Int, comment: String?) {
        Task {
            do {
                if let highlight = highlight {
                    _ = try await appState.lightningService.sendSmartZap(
                        amount: amount,
                        to: highlight,
                        comment: comment
                    )
                    await MainActor.run {
                        zapAmount = amount
                        HapticManager.shared.notification(.success)
                        onZapComplete?()
                    }
                } else {
                    // For regular events, send a standard zap
                    // This would be implemented when Lightning service supports regular zaps
                    HapticManager.shared.notification(.warning)
                }
            } catch {
                await MainActor.run {
                    HapticManager.shared.notification(.error)
                }
            }
        }
    }
    private func createParticleEffect() {
        particles.removeAll()
        // More subtle particle effect with fewer particles
        for i in 0..<6 {
            let angle = Double(i) * 60.0 + Double.random(in: -15...15)
            let particle = ZapParticle(
                angle: angle,
                distance: CGFloat.random(in: 20...40),
                duration: Double.random(in: 0.8...1.0),
                color: DesignSystem.Colors.primary.opacity(0.8),
                size: 3
            )
            particles.append(particle)
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            particles.removeAll()
        }
    }
    private func createAdvancedParticleEffect(splitCount: Int) {
        particles.removeAll()
        // Create particles for each split recipient
        for i in 0..<splitCount {
            let baseAngle = (360.0 / Double(splitCount)) * Double(i)
            // Create a burst of particles for each recipient
            for j in 0..<3 {
                let angleVariation = Double.random(in: -10...10)
                let angle = baseAngle + angleVariation + (Double(j) * 5)
                let particle = ZapParticle(
                    angle: angle,
                    distance: CGFloat.random(in: 30...60),
                    duration: Double.random(in: 0.8...1.2),
                    color: [Color.orange, Color.purple, Color.blue][i % 3].opacity(0.8),
                    size: CGFloat.random(in: 2...5)
                )
                particles.append(particle)
            }
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
            particles.removeAll()
        }
    }
}
struct ZapAmountSheet: View {
    let event: NDKEvent
    @Binding var zapAmount: Int
    let onZap: (Int) -> Void
    @Environment(\.dismiss) var dismiss
    let presetAmounts = [21, 42, 69, 100, 420, 1000, 5000, 10000]
    @State private var customAmount = ""
    @State private var useCustomAmount = false
    var body: some View {
        NavigationStack {
            VStack(spacing: 24) {
                // Simplified lightning icon
                Image(systemName: "bolt.fill")
                    .font(.system(size: 48, weight: .regular))
                    .foregroundColor(DesignSystem.Colors.primary)
                    .padding(.bottom, 8)
                .padding(.top)
                VStack(spacing: 8) {
                    Text("Choose Amount")
                        .font(.system(size: 24, weight: .semibold))
                    Text("Send sats to show appreciation")
                        .font(.system(size: 16))
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                }
                // Preset amounts grid
                LazyVGrid(columns: [GridItem(.adaptive(minimum: 80))], spacing: 16) {
                    ForEach(presetAmounts, id: \.self) { amount in
                        Button(action: {
                            zapAmount = amount
                            useCustomAmount = false
                            customAmount = ""
                        }) {
                            Text("\(amount)")
                                .font(DesignSystem.Typography.body)
                                .fontWeight(.medium)
                                .frame(width: 80, height: 50)
                                .background(
                                    RoundedRectangle(cornerRadius: 12)
                                        .fill(zapAmount == amount && !useCustomAmount ? DesignSystem.Colors.primaryDark : DesignSystem.Colors.surface)
                                )
                                .foregroundColor(zapAmount == amount && !useCustomAmount ? .white : DesignSystem.Colors.text)
                        }
                    }
                }
                .padding(.horizontal)
                // Custom amount
                HStack {
                    TextField("Custom amount", text: $customAmount)
                        .keyboardType(.numberPad)
                        .textFieldStyle(RoundedBorderTextFieldStyle())
                        .onChange(of: customAmount) { _, newValue in
                            useCustomAmount = !newValue.isEmpty
                            if let amount = Int(newValue) {
                                zapAmount = amount
                            }
                        }
                    Text("sats")
                        .font(DesignSystem.Typography.body)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                }
                .padding(.horizontal)
                Spacer()
                // Zap button
                Button(action: {
                    onZap(zapAmount)
                    dismiss()
                }) {
                    HStack {
                        Image(systemName: "bolt.fill")
                        Text("Zap \(zapAmount) sats")
                            .fontWeight(.semibold)
                    }
                    .frame(maxWidth: .infinity)
                    .padding()
                    .background(
                        LinearGradient(
                            colors: [DesignSystem.Colors.primary, DesignSystem.Colors.primaryDark],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    )
                    .foregroundColor(.white)
                    .cornerRadius(12)
                }
                .padding(.horizontal)
                .padding(.bottom)
            }
            .navigationTitle("⚡ Zap")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
            }
        }
    }
}
// Enhanced ZapParticle with color support
struct ZapParticle: Identifiable {
    let id = UUID()
    let angle: Double
    let distance: CGFloat
    let duration: Double
    var color: Color = .orange
    var size: CGFloat = 4
}
struct ZapParticleView: View {
    let particle: ZapParticle
    @State private var offset: CGSize = .zero
    @State private var opacity: Double = 1
    @State private var scale: CGFloat = 1
    var body: some View {
        Circle()
            .fill(particle.color)
            .frame(width: particle.size, height: particle.size)
            .scaleEffect(scale)
            .offset(offset)
            .opacity(opacity)
            .blur(radius: opacity < 0.5 ? 2 : 0)
            .onAppear {
                let radians = particle.angle * .pi / 180
                let x = cos(radians) * particle.distance
                let y = sin(radians) * particle.distance
                withAnimation(.easeOut(duration: particle.duration)) {
                    offset = CGSize(width: x, height: y)
                    opacity = 0
                    scale = 0.3
                }
            }
    }
}
#Preview {
    VStack(spacing: 20) {
        HStack(spacing: 20) {
            ZapButton(
                event: NDKEvent(id: "", pubkey: "", createdAt: 0, kind: 1, tags: [], content: "", sig: ""),
                size: .small
            )
            ZapButton(
                event: NDKEvent(id: "", pubkey: "", createdAt: 0, kind: 1, tags: [], content: "", sig: ""),
                size: .medium
            )
            ZapButton(
                event: NDKEvent(id: "", pubkey: "", createdAt: 0, kind: 1, tags: [], content: "", sig: ""),
                size: .large
            )
        }
    }
    .padding()
    .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Views/Discovery/CurationDiscoveryView.swift">
import SwiftUI
import NDKSwift
struct CurationDiscoveryView: View {
    let searchText: String
    @EnvironmentObject var appState: AppState
    @State private var curations: [ArticleCuration] = []
    var filteredCurations: [ArticleCuration] {
        if searchText.isEmpty {
            return curations
        }
        return curations.filter { curation in
            curation.title.localizedCaseInsensitiveContains(searchText) ||
            curation.description?.localizedCaseInsensitiveContains(searchText) == true
        }
    }
    var body: some View {
        ScrollView {
            LazyVStack(spacing: 16) {
                ForEach(filteredCurations) { curation in
                    CurationCard(curation: curation)
                }
            }
            .padding()
        }
        .task {
            await loadCurations()
        }
    }
    private func loadCurations() async {
        guard let ndk = appState.ndk else { return }
        let curationSource = await ndk.outbox.observe(
            filter: NDKFilter(kinds: [30004], limit: 50),
            maxAge: 300,
            cachePolicy: .cacheWithNetwork
        )
        for await event in curationSource.events {
            if let curation = try? ArticleCuration(from: event) {
                await MainActor.run {
                    if !curations.contains(where: { $0.id == curation.id }) {
                        curations.append(curation)
                        curations.sort { $0.createdAt > $1.createdAt }
                    }
                }
            }
        }
    }
}
// MARK: - Curation Card
struct CurationCard: View {
    let curation: ArticleCuration
    @State private var curator: NDKUserProfile?
    @EnvironmentObject var appState: AppState
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Cover image or gradient
            if let imageURL = curation.image, let url = URL(string: imageURL) {
                AsyncImage(url: url) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .frame(height: 150)
                        .clipped()
                } placeholder: {
                    gradientPlaceholder
                }
                .cornerRadius(8)
            } else {
                gradientPlaceholder
                    .cornerRadius(8)
            }
            VStack(alignment: .leading, spacing: 8) {
                // Title
                Text(curation.title)
                    .font(.ds.headline)
                    .foregroundColor(.ds.text)
                    .lineLimit(2)
                // Description
                if let description = curation.description {
                    Text(description)
                        .font(.ds.body)
                        .foregroundColor(.ds.textSecondary)
                        .lineLimit(2)
                }
                // Stats and curator
                HStack {
                    HStack(spacing: 8) {
                        Circle()
                            .fill(Color.ds.primaryDark.opacity(0.2))
                            .frame(width: 24, height: 24)
                            .overlay {
                                if let picture = curator?.picture, let url = URL(string: picture) {
                                    AsyncImage(url: url) { image in
                                        image
                                            .resizable()
                                            .scaledToFill()
                                            .clipShape(Circle())
                                    } placeholder: {
                                        Image(systemName: "person.fill")
                                            .font(.system(size: 12))
                                            .foregroundColor(.ds.primaryDark)
                                    }
                                } else {
                                    Image(systemName: "person.fill")
                                        .font(.system(size: 12))
                                        .foregroundColor(.ds.primaryDark)
                                }
                            }
                        Text(curator?.displayName ?? PubkeyFormatter.formatShort(curation.author))
                            .font(.ds.caption)
                            .foregroundColor(.ds.textSecondary)
                    }
                    Spacer()
                    HStack(spacing: 12) {
                        Label("\(curation.articles.count)", systemImage: "doc.text")
                            .font(.ds.caption)
                            .foregroundColor(.ds.textSecondary)
                    }
                }
            }
            .padding()
        }
        .modernCard(noPadding: true)
        .task {
            await loadCurator()
        }
    }
    private var gradientPlaceholder: some View {
        LinearGradient(
            colors: [
                Color.ds.primary.opacity(0.2),
                Color.ds.secondary.opacity(0.2)
            ],
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
        .frame(height: 150)
        .overlay {
            Image(systemName: "folder.fill")
                .font(.system(size: 40))
                .foregroundColor(.white.opacity(0.5))
        }
    }
    private func loadCurator() async {
        guard let ndk = appState.ndk else { return }
        let profileDataSource = await ndk.outbox.observe(
            filter: NDKFilter(
                authors: [curation.author],
                kinds: [0]
            ),
            maxAge: 3600,
            cachePolicy: .cacheWithNetwork
        )
        for await event in profileDataSource.events {
            if let fetchedProfile = JSONCoding.safeDecode(NDKUserProfile.self, from: event.content) {
                await MainActor.run {
                    self.curator = fetchedProfile
                }
                break
            }
        }
    }
}
</file>

<file path="Sources/Highlighter/Views/Discovery/HighlightDiscoveryView.swift">
import SwiftUI
import NDKSwift
struct HighlightDiscoveryView: View {
    let searchText: String
    @EnvironmentObject var appState: AppState
    @State private var highlights: [HighlightEvent] = []
    var filteredHighlights: [HighlightEvent] {
        if searchText.isEmpty {
            return highlights
        }
        return highlights.filter { highlight in
            highlight.content.localizedCaseInsensitiveContains(searchText)
        }
    }
    var body: some View {
        ScrollView {
            LazyVStack(spacing: 16) {
                ForEach(filteredHighlights) { highlight in
                    DiscoveryHighlightCard(highlight: highlight)
                }
            }
            .padding()
        }
        .task {
            await loadHighlights()
        }
    }
    private func loadHighlights() async {
        guard let ndk = appState.ndk else { return }
        let highlightSource = await ndk.outbox.observe(
            filter: NDKFilter(kinds: [9802], limit: 100),
            maxAge: 300,
            cachePolicy: .cacheWithNetwork
        )
        for await event in highlightSource.events {
            if let highlight = try? HighlightEvent(from: event) {
                await MainActor.run {
                    if !highlights.contains(where: { $0.id == highlight.id }) {
                        highlights.append(highlight)
                        highlights.sort { $0.createdAt > $1.createdAt }
                    }
                }
            }
        }
    }
}
// MARK: - Discovery Highlight Card
struct DiscoveryHighlightCard: View {
    let highlight: HighlightEvent
    @State private var author: NDKUserProfile?
    @EnvironmentObject var appState: AppState
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Highlight content with quote styling
            Text(highlight.content)
                .font(DesignSystem.Typography.highlighterQuote)
                .foregroundColor(.ds.text)
                .lineLimit(6)
                .multilineTextAlignment(.leading)
                .padding(.horizontal, 12)
                .overlay(alignment: .leading) {
                    Rectangle()
                        .fill(Color.ds.secondary)
                        .frame(width: 3)
                        .offset(x: -12)
                }
            // Context if available
            if let context = highlight.context {
                Text("from: \(context)")
                    .font(.ds.caption)
                    .foregroundColor(.ds.textSecondary)
                    .lineLimit(2)
            }
            Divider()
            // Author and interaction row
            HStack {
                // Author info
                HStack(spacing: 8) {
                    Circle()
                        .fill(Color.ds.primaryDark.opacity(0.2))
                        .frame(width: 28, height: 28)
                        .overlay {
                            if let picture = author?.picture, let url = URL(string: picture) {
                                AsyncImage(url: url) { image in
                                    image
                                        .resizable()
                                        .scaledToFill()
                                        .clipShape(Circle())
                                } placeholder: {
                                    Image(systemName: "person.fill")
                                        .font(.system(size: 14))
                                        .foregroundColor(.ds.primaryDark)
                                }
                            } else {
                                Image(systemName: "person.fill")
                                    .font(.system(size: 14))
                                    .foregroundColor(.ds.primaryDark)
                            }
                        }
                    Text(author?.displayName ?? PubkeyFormatter.formatShort(highlight.author))
                        .font(.ds.footnoteMedium)
                        .foregroundColor(.ds.text)
                }
                Spacer()
                HStack(spacing: 16) {
                    // Zap button
                    Button {
                        HapticManager.shared.impact(HapticManager.ImpactStyle.light)
                    } label: {
                        Label("21", systemImage: "bolt.fill")
                            .font(.ds.caption)
                            .foregroundColor(.ds.secondary)
                    }
                    // Share button
                    Button {
                        HapticManager.shared.triggerSelection()
                    } label: {
                        Image(systemName: "square.and.arrow.up")
                            .font(.ds.caption)
                            .foregroundColor(.ds.textSecondary)
                    }
                }
            }
        }
        .padding()
        .modernCard()
        .task {
            await loadAuthor()
        }
    }
    private func loadAuthor() async {
        guard let ndk = appState.ndk else { return }
        let profileDataSource = await ndk.outbox.observe(
            filter: NDKFilter(
                authors: [highlight.author],
                kinds: [0]
            ),
            maxAge: 3600,
            cachePolicy: .cacheWithNetwork
        )
        for await event in profileDataSource.events {
            if let fetchedProfile = JSONCoding.safeDecode(NDKUserProfile.self, from: event.content) {
                await MainActor.run {
                    self.author = fetchedProfile
                }
                break
            }
        }
    }
}
</file>

<file path="Sources/Highlighter/Views/Discovery/UserDiscoveryView.swift">
import SwiftUI
import NDKSwift
struct UserDiscoveryView: View {
    let searchText: String
    @EnvironmentObject var appState: AppState
    @State private var users: [(pubkey: String, profile: NDKUserProfile)] = []
    var filteredUsers: [(pubkey: String, profile: NDKUserProfile)] {
        if searchText.isEmpty {
            return users
        }
        return users.filter { user in
            user.profile.displayName?.localizedCaseInsensitiveContains(searchText) == true ||
            user.profile.name?.localizedCaseInsensitiveContains(searchText) == true ||
            user.profile.about?.localizedCaseInsensitiveContains(searchText) == true
        }
    }
    var body: some View {
        ScrollView {
            LazyVStack(spacing: 16) {
                ForEach(filteredUsers, id: \.pubkey) { user in
                    UserCard(pubkey: user.pubkey, profile: user.profile)
                }
            }
            .padding()
        }
        .task {
            await loadUsers()
        }
    }
    private func loadUsers() async {
        guard let ndk = appState.ndk else { return }
        // For now, load some popular users or recent profile updates
        let profileSource = await ndk.outbox.observe(
            filter: NDKFilter(kinds: [0], limit: 100),
            maxAge: 300,
            cachePolicy: .cacheWithNetwork
        )
        for await event in profileSource.events {
            if let profile = JSONCoding.safeDecode(NDKUserProfile.self, from: event.content) {
                await MainActor.run {
                    if !users.contains(where: { $0.pubkey == event.pubkey }) {
                        users.append((pubkey: event.pubkey, profile: profile))
                        // Sort by display name
                        users.sort { 
                            ($0.profile.displayName ?? $0.profile.name ?? "") < 
                            ($1.profile.displayName ?? $1.profile.name ?? "")
                        }
                    }
                }
            }
        }
    }
}
// MARK: - User Card
struct UserCard: View {
    let pubkey: String
    let profile: NDKUserProfile
    @EnvironmentObject var appState: AppState
    @State private var isFollowing = false
    @State private var highlightCount = 0
    var body: some View {
        HStack(spacing: 16) {
            // Profile picture
            Circle()
                .fill(Color.ds.primaryDark.opacity(0.2))
                .frame(width: 56, height: 56)
                .overlay {
                    if let picture = profile.picture, let url = URL(string: picture) {
                        AsyncImage(url: url) { image in
                            image
                                .resizable()
                                .scaledToFill()
                                .clipShape(Circle())
                        } placeholder: {
                            Image(systemName: "person.fill")
                                .font(.system(size: 24))
                                .foregroundColor(.ds.primaryDark)
                        }
                    } else {
                        Image(systemName: "person.fill")
                            .font(.system(size: 24))
                            .foregroundColor(.ds.primaryDark)
                    }
                }
            VStack(alignment: .leading, spacing: 4) {
                // Name
                Text(profile.displayName ?? profile.name ?? PubkeyFormatter.formatShort(pubkey))
                    .font(.ds.headline)
                    .foregroundColor(.ds.text)
                    .lineLimit(1)
                // Username if different from display name
                if let name = profile.name, 
                   let displayName = profile.displayName,
                   name != displayName {
                    Text("@\(name)")
                        .font(.ds.caption)
                        .foregroundColor(.ds.textSecondary)
                        .lineLimit(1)
                }
                // About
                if let about = profile.about {
                    Text(about)
                        .font(.ds.caption)
                        .foregroundColor(.ds.textSecondary)
                        .lineLimit(2)
                }
                // Stats
                HStack(spacing: 12) {
                    Label("\(highlightCount)", systemImage: "highlighter")
                        .font(.ds.caption)
                        .foregroundColor(.ds.textSecondary)
                    if profile.lud16 != nil || profile.lud06 != nil {
                        Image(systemName: "bolt.fill")
                            .font(.ds.caption)
                            .foregroundColor(.ds.secondary)
                    }
                }
            }
            Spacer()
            // Follow button
            Button {
                Task { @MainActor in
                    await toggleFollow()
                }
            } label: {
                Text(isFollowing ? "Following" : "Follow")
                    .font(.ds.footnoteMedium)
            }
            .unifiedPrimaryButton(enabled: true, variant: isFollowing ? .standard : .compact)
        }
        .padding()
        .modernCard()
        .task {
            await loadUserStats()
        }
    }
    private func toggleFollow() async {
        let wasFollowing = isFollowing
        isFollowing.toggle()
        HapticManager.shared.impact(.light)
        do {
            if isFollowing {
                try await appState.followUser(pubkey)
            } else {
                try await appState.unfollowUser(pubkey)
            }
        } catch {
            // Revert on error
            await MainActor.run {
                isFollowing = wasFollowing
                HapticManager.shared.notification(.error)
            }
        }
    }
    private func loadUserStats() async {
        guard let ndk = appState.ndk else { return }
        // Count highlights by this user
        let highlightSource = await ndk.outbox.observe(
            filter: NDKFilter(
                authors: [pubkey],
                kinds: [9802],
                limit: 100
            ),
            maxAge: 3600,
            cachePolicy: .cacheOnly
        )
        var count = 0
        for await _ in highlightSource.events {
            count += 1
        }
        await MainActor.run {
            self.highlightCount = count
        }
        // Check if following
        do {
            isFollowing = try await appState.isFollowing(pubkey)
        } catch {
            isFollowing = false
        }
    }
}
// Type-erasing wrapper for button styles
struct AnyButtonStyle: ButtonStyle {
    private let _makeBody: (Configuration) -> AnyView
    init<S: ButtonStyle>(_ style: S) {
        _makeBody = { configuration in
            AnyView(style.makeBody(configuration: configuration))
        }
    }
    func makeBody(configuration: Configuration) -> some View {
        _makeBody(configuration)
    }
}
</file>

<file path="Sources/Highlighter/Views/FollowPacks/FollowPackDetailView.swift">
import SwiftUI
import NDKSwift
struct FollowPackDetailView: View {
    let followPack: FollowPack
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) var dismiss
    @State private var profiles: [String: NDKUserProfile] = [:]
    @State private var showSuccess = false
    @State private var creator: NDKUserProfile?
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: 24) {
                    headerSection
                    creatorSection
                    importSection
                    profilesSection
                }
                .padding(.vertical)
            }
            .background(DesignSystem.Colors.background)
            .navigationTitle("Follow Pack")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Done") {
                        dismiss()
                    }
                    .foregroundColor(DesignSystem.Colors.primary)
                }
            }
        }
        .task {
            await loadProfiles()
        }
    }
    @ViewBuilder
    private var headerSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            HStack {
                Image(systemName: "person.3.fill")
                    .font(.system(size: 48))
                    .foregroundColor(DesignSystem.Colors.primary)
                Spacer()
                // Stats
                VStack(alignment: .trailing, spacing: 4) {
                    Text("\(followPack.profiles.count)")
                        .font(DesignSystem.Typography.title)
                        .foregroundColor(DesignSystem.Colors.primary)
                    Text("Profiles")
                        .font(DesignSystem.Typography.caption)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                }
            }
            VStack(alignment: .leading, spacing: 8) {
                Text(followPack.title)
                    .font(DesignSystem.Typography.headline)
                if let description = followPack.description {
                    Text(description)
                        .font(DesignSystem.Typography.body)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                }
            }
        }
    }
    @ViewBuilder
    private var creatorSection: some View {
        HStack {
            Image(systemName: "person.circle.fill")
                .font(.system(size: 24))
                .foregroundColor(DesignSystem.Colors.primary)
            VStack(alignment: .leading, spacing: 2) {
                Text("Created by")
                    .font(DesignSystem.Typography.caption)
                    .foregroundColor(DesignSystem.Colors.textSecondary)
                Text(creator?.name ?? creator?.displayName ?? PubkeyFormatter.formatShort(followPack.author))
                    .font(DesignSystem.Typography.caption)
                    .fontWeight(.medium)
            }
            Spacer()
        }
        .padding()
        .background(
            LinearGradient(
                colors: [
                    DesignSystem.Colors.primary.opacity(0.1),
                    DesignSystem.Colors.secondary.opacity(0.1)
                ],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        )
        .cornerRadius(DesignSystem.CornerRadius.large)
        .padding(.horizontal)
    }
    @ViewBuilder
    private var importSection: some View {
        Button(action: importFollowPack) {
            HStack {
                Image(systemName: showSuccess ? "checkmark.circle.fill" : "plus.circle.fill")
                Text(showSuccess ? "Imported!" : "Import Follow Pack")
                    .fontWeight(.semibold)
            }
            .frame(maxWidth: .infinity)
            .padding()
            .background(
                Group {
                    if showSuccess {
                        Color.green
                    } else {
                        LinearGradient(
                            colors: [DesignSystem.Colors.primary, DesignSystem.Colors.primary.opacity(0.8)],
                            startPoint: .leading,
                            endPoint: .trailing
                        )
                    }
                }
            )
            .foregroundColor(.white)
            .cornerRadius(DesignSystem.CornerRadius.medium)
            .disabled(showSuccess)
        }
        .padding(.horizontal)
    }
    @ViewBuilder
    private var profilesSection: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Profiles in this pack")
                .font(DesignSystem.Typography.headline)
                .padding(.horizontal)
            ForEach(followPack.profiles, id: \.self) { pubkey in
                ProfileRow(pubkey: pubkey, profile: profiles[pubkey])
                    .padding(.horizontal)
            }
        }
    }
    private func loadProfiles() async {
        guard let ndk = appState.ndk else { return }
        // Load creator profile
        for await profile in await ndk.profileManager.observe(for: followPack.author, maxAge: TimeConstants.hour) {
            await MainActor.run {
                self.creator = profile
            }
            break
        }
        // Load profiles in the pack
        for pubkey in followPack.profiles {
            Task {
                for await profile in await ndk.profileManager.observe(for: pubkey, maxAge: TimeConstants.hour) {
                    await MainActor.run {
                        self.profiles[pubkey] = profile
                    }
                    break
                }
            }
        }
    }
    private func importFollowPack() {
        HapticManager.shared.impact(.medium)
        Task {
            do {
                guard let ndk = appState.ndk,
                      let signer = appState.activeSigner else {
                    throw AuthError.noSigner
                }
                // Get current contact list
                let pubkey = try await signer.pubkey
                let filter = NDKFilter(
                    authors: [pubkey],
                    kinds: [3],
                    limit: 1
                )
                let dataSource = await ndk.outbox.observe(filter: filter)
                var currentFollows: Set<String> = []
                // Parse existing follows
                for await event in dataSource.events {
                    currentFollows = Set(event.tags
                        .filter { $0.first == "p" && $0.count > 1 }
                        .compactMap { $0[1] })
                    break // Only need the first event
                }
                // Add follow pack members to current follows
                for pubkey in followPack.profiles {
                    currentFollows.insert(pubkey)
                }
                // Create new contact list event
                var tags: [[String]] = []
                for follow in currentFollows {
                    tags.append(["p", follow])
                }
                let contactEvent = try await NDKEventBuilder(ndk: ndk)
                    .kind(3)
                    .content("")
                    .tags(tags)
                    .build(signer: signer)
                _ = try await ndk.publish(contactEvent)
                await MainActor.run {
                    showSuccess = true
                    HapticManager.shared.notification(.success)
                    // Reset after delay
                    Task {
                        try? await Task.sleep(nanoseconds: 3_000_000_000)
                        await MainActor.run {
                            showSuccess = false
                        }
                    }
                }
            } catch {
                await MainActor.run {
                    HapticManager.shared.notification(.error)
                }
            }
        }
    }
}
struct ProfileRow: View {
    let pubkey: String
    let profile: NDKUserProfile?
    @State private var isFollowing = false
    var body: some View {
        HStack {
            Image(systemName: "person.circle.fill")
                .font(.system(size: 40))
                .foregroundColor(DesignSystem.Colors.primary)
            VStack(alignment: .leading, spacing: 4) {
                Text(profile?.name ?? profile?.displayName ?? String(pubkey.prefix(16)))
                    .font(DesignSystem.Typography.body)
                    .fontWeight(.medium)
                if let about = profile?.about {
                    Text(about)
                        .font(DesignSystem.Typography.caption)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                        .lineLimit(1)
                }
            }
            Spacer()
            Button(action: { isFollowing.toggle() }) {
                Text(isFollowing ? "Following" : "Follow")
                    .font(DesignSystem.Typography.caption)
                    .fontWeight(.medium)
                    .padding(.horizontal, DesignSystem.Spacing.medium)
                    .padding(.vertical, DesignSystem.Spacing.mini)
                    .background(isFollowing ? Color.gray : DesignSystem.Colors.primary)
                    .foregroundColor(.white)
                    .cornerRadius(DesignSystem.CornerRadius.large)
            }
        }
        .modernCard()
    }
}
#Preview {
    FollowPackDetailView(
        followPack: FollowPack(
            id: "1",
            event: NDKEvent(id: "", pubkey: "", createdAt: 0, kind: 39089, tags: [], content: "", sig: ""),
            name: "bitcoin-devs",
            title: "Bitcoin Developers",
            description: "Core Bitcoin developers and contributors",
            image: nil,
            author: "test",
            createdAt: Date(),
            profiles: ["pubkey1", "pubkey2", "pubkey3"]
        )
    )
    .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Views/Highlights/HighlightsFeedView.swift">
import SwiftUI
import NDKSwift
struct HighlightsFeedView: View {
    @EnvironmentObject var appState: AppState
    @State private var highlights: [HighlightEvent] = []
    @State private var currentIndex = 0
    @State private var dragOffset: CGSize = .zero
    @State private var isDragging = false
    // Stream task reference
    @State private var streamTask: Task<Void, Never>?
    @State private var selectedHighlight: HighlightEvent?
    @State private var showHighlightDetail = false
    @State private var showCommentSheet = false
    @State private var hapticPrepared = false
    @State private var selectedUserPubkey: String?
    @State private var showUserProfile = false
    @Binding var tabBarVisible: Bool
    // Author cache
    @State private var authorProfiles: [String: NDKUserProfile] = [:]
    // Article cache for highlights from articles
    @State private var articleCache: [String: Article] = [:]
    @State private var articleImages: [String: UIImage] = [:]
    // Comment counts cache
    @State private var commentCounts: [String: Int] = [:]
    // Animation states
    @State private var backgroundAnimation = false
    @State private var pulseAnimation = false
    private let impactGenerator = UIImpactFeedbackGenerator(style: .light)
    private let selectionGenerator = UISelectionFeedbackGenerator()
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // Enhanced animated background
                ImmersiveGradientBackground(animate: $backgroundAnimation)
                if highlights.isEmpty {
                    EmptyHighlightsView()
                        .transition(.scale.combined(with: .opacity))
                } else {
                    // Wrap in ScrollView for pull-to-refresh
                    ScrollView(.vertical, showsIndicators: false) {
                        // Enhanced Highlights Stack with gestures
                        ZStack {
                            ForEach(Array(highlights.enumerated()), id: \.element.id) { index, highlight in
                                if index >= currentIndex - 1 && index <= currentIndex + 1 {
                                    HighlightFeedItemView(
                                    highlight: highlight,
                                    author: authorProfiles[highlight.author],
                                    article: articleForHighlight(highlight),
                                    articleImage: articleImageForHighlight(highlight),
                                    onAuthorTap: { 
                                        impactGenerator.impactOccurred()
                                        showProfile(for: highlight.author) 
                                    },
                                    onZap: { 
                                        impactGenerator.impactOccurred(intensity: 0.7)
                                        zapHighlight(highlight) 
                                    },
                                    onShare: { 
                                        selectionGenerator.selectionChanged()
                                        shareHighlight(highlight) 
                                    },
                                    onComment: { 
                                        selectedHighlight = highlight
                                        showCommentSheet = true
                                    },
                                    commentCount: commentCounts[highlight.id] ?? 0,
                                    onDoubleTap: {
                                        likeHighlight(highlight)
                                    }
                                )
                                .scaleEffect(index == currentIndex ? 1 : 0.95)
                                .opacity(index == currentIndex ? 1 : 0)
                                .offset(y: CGFloat(index - currentIndex) * geometry.size.height + dragOffset.height)
                                .animation(.interactiveSpring(response: 0.4, dampingFraction: 0.8), value: currentIndex)
                                .animation(.interactiveSpring(response: 0.3, dampingFraction: 0.7), value: dragOffset)
                                .zIndex(index == currentIndex ? 1 : 0)
                            }
                        }
                    }
                    .gesture(createDragGesture())
                    .frame(width: geometry.size.width, height: geometry.size.height)
                }
                .refreshable {
                    await refreshFeed()
                }
                // Progress indicator - moved outside ScrollView
                if !highlights.isEmpty && highlights.count > 1 {
                    VStack {
                        HighlightProgressIndicator(
                            currentIndex: currentIndex,
                            total: highlights.count
                        )
                        .padding(.top, geometry.safeAreaInsets.top + 20)
                        .padding(.horizontal, 20)
                        Spacer()
                    }
                    .transition(.move(edge: .top).combined(with: .opacity))
                    .allowsHitTesting(false)
                }
            }
            }
        }
        .onAppear {
            tabBarVisible = true
            prepareHaptics()
            withAnimation(.easeInOut(duration: 3).repeatForever(autoreverses: true)) {
                backgroundAnimation = true
            }
            // Start streaming immediately
            streamHighlights()
        }
        .onDisappear {
            streamTask?.cancel()
        }
        .sheet(isPresented: $showCommentSheet) {
            if let highlight = selectedHighlight {
                CommentSheetView(highlight: highlight)
                    .presentationDetents([.medium, .large])
                    .presentationDragIndicator(.visible)
                    .presentationBackground(.ultraThinMaterial)
            }
        }
        .sheet(isPresented: $showUserProfile) {
            if let pubkey = selectedUserPubkey {
                NavigationStack {
                    UserProfileView(pubkey: pubkey)
                }
            }
        }
        .onChange(of: currentIndex) { oldValue, newValue in
            if oldValue != newValue {
                selectionGenerator.selectionChanged()
            }
        }
    }
    private func streamHighlights() {
        guard let ndk = appState.ndk else { return }
        streamTask?.cancel()
        streamTask = Task {
            let filter = NDKFilter(
                kinds: [9802],
                limit: 50
            )
            // Stream highlights as they arrive
            let dataSource = await ndk.outbox.observe(
                filter: filter,
                maxAge: 300, // Use 5 minute cache
                cachePolicy: .cacheWithNetwork
            )
            // Process each highlight as it arrives - no waiting!
            for await event in dataSource.events {
                if let highlightEvent = try? HighlightEvent(from: event) {
                    await MainActor.run {
                        // Add if not already present
                        if !highlights.contains(where: { $0.id == highlightEvent.id }) {
                            highlights.append(highlightEvent)
                            highlights.sort { $0.createdAt > $1.createdAt }
                        }
                    }
                    // Load author profile for this highlight
                    Task {
                        await loadAuthorProfile(for: highlightEvent.author)
                    }
                    // Load referenced article if any
                    if highlightEvent.referencedEvent != nil {
                        Task {
                            await loadReferencedArticleForHighlight(highlightEvent)
                        }
                    }
                    // Load comment count
                    Task {
                        await loadCommentCount(for: highlightEvent.id)
                    }
                }
            }
        }
    }
    private func loadAuthorProfile(for author: String) async {
        guard let ndk = appState.ndk else { return }
        // Don't reload if we already have it
        if authorProfiles[author] != nil { return }
        for await profile in await ndk.profileManager.observe(for: author, maxAge: TimeConstants.hour) {
            await MainActor.run {
                self.authorProfiles[author] = profile
            }
            break
        }
    }
    private func loadReferencedArticleForHighlight(_ highlight: HighlightEvent) async {
        guard let ndk = appState.ndk,
              let ref = highlight.referencedEvent,
              ref.contains(":") else { return }
        let parts = ref.split(separator: ":")
        guard parts.count >= 3,
              let kind = Int(parts[0]),
              kind == 30023 else { return }
        let author = String(parts[1])
        let identifier = parts[2...].joined(separator: ":")
        let filter = NDKFilter(
            authors: [author],
            kinds: [30023],
            limit: 1,
            tags: ["d": [String(identifier)]]
        )
        let dataSource = await ndk.outbox.observe(filter: filter, maxAge: 3600)
        for await event in dataSource.events {
            if let article = try? Article(from: event) {
                await MainActor.run {
                    self.articleCache[ref] = article
                }
                // Load article image if available
                if let imageUrl = article.image,
                   let url = URL(string: imageUrl) {
                    await loadArticleImage(url: url, for: ref)
                }
                break
            }
        }
    }
    private func refreshFeed() async {
        // Haptic feedback for pull-to-refresh
        await MainActor.run {
            HapticManager.shared.impact(.medium)
        }
        // Clear existing data to show fresh content
        await MainActor.run {
            highlights.removeAll()
            authorProfiles.removeAll()
            articleCache.removeAll()
            articleImages.removeAll()
            commentCounts.removeAll()
            currentIndex = 0
        }
        // Cancel existing stream and restart
        streamTask?.cancel()
        streamHighlights()
    }
    private func showProfile(for pubkey: String) {
        selectedUserPubkey = pubkey
        showUserProfile = true
        HapticManager.shared.impact(.light)
    }
    private func zapHighlight(_ highlight: HighlightEvent) {
        Task {
            do {
                _ = try await appState.lightningService.sendSmartZap(
                    amount: 1000, // Default 1000 sats
                    to: highlight,
                    comment: nil
                )
                HapticManager.shared.impact(.medium)
            } catch {
                // Handle zap error
                HapticManager.shared.notification(.error)
            }
        }
    }
    private func shareHighlight(_ highlight: HighlightEvent) {
        let shareText = """
        "\(highlight.content)"
        — Highlighted on Nostr
        nostr:\(highlight.id)
        """
        let activityController = UIActivityViewController(
            activityItems: [shareText],
            applicationActivities: nil
        )
        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
           let window = windowScene.windows.first,
           let rootViewController = window.rootViewController {
            rootViewController.present(activityController, animated: true)
        }
        HapticManager.shared.impact(.light)
    }
    private func commentOnHighlight(_ highlight: HighlightEvent) {
        selectedHighlight = highlight
        showCommentSheet = true
        HapticManager.shared.impact(.light)
    }
    private func loadReferencedArticles(for highlights: [HighlightEvent]) async {
        guard let ndk = appState.ndk else { return }
        // Collect all referenced events that look like article references
        let articleReferences = highlights.compactMap { highlight -> String? in
            guard let ref = highlight.referencedEvent else { return nil }
            // Check if it's an article reference (contains ":" for replaceable events)
            return ref.contains(":") ? ref : nil
        }
        guard !articleReferences.isEmpty else { return }
        // Parse article references and create filters
        for reference in Set(articleReferences) {
            let parts = reference.split(separator: ":")
            guard parts.count >= 3,
                  let kind = Int(parts[0]),
                  kind == 30023 else { continue }
            let author = String(parts[1])
            let identifier = parts[2...].joined(separator: ":")
            // Create filter for this specific article
            let filter = NDKFilter(
                authors: [author],
                kinds: [30023],
                limit: 1,
                tags: ["d": [String(identifier)]]
            )
            // Fetch the article
            let dataSource = await ndk.outbox.observe(filter: filter, maxAge: 3600, cachePolicy: .cacheWithNetwork)
            for await event in dataSource.events {
                if let article = try? Article(from: event) {
                    await MainActor.run {
                        self.articleCache[reference] = article
                    }
                    // Load article image if available
                    if let imageUrl = article.image,
                       let url = URL(string: imageUrl) {
                        await loadArticleImage(url: url, for: reference)
                    }
                    break
                }
            }
        }
    }
    private func loadArticleImage(url: URL, for reference: String) async {
        do {
            let (data, _) = try await URLSession.shared.data(from: url)
            if let image = UIImage(data: data) {
                await MainActor.run {
                    self.articleImages[reference] = image
                }
            }
        } catch {
        }
    }
    private func articleForHighlight(_ highlight: HighlightEvent) -> Article? {
        guard let ref = highlight.referencedEvent else { return nil }
        return articleCache[ref]
    }
    private func articleImageForHighlight(_ highlight: HighlightEvent) -> UIImage? {
        guard let ref = highlight.referencedEvent else { return nil }
        return articleImages[ref]
    }
    private func loadCommentCount(for highlightId: String) async {
        guard let ndk = appState.ndk else { return }
        // Create filter for replies to this highlight (kind 1 events that tag this event)
        let filter = NDKFilter(
            kinds: [1], // Kind 1 = text note/comment
            limit: 50,
            tags: ["e": [highlightId]]
        )
        let dataSource = await ndk.outbox.observe(
            filter: filter,
            maxAge: 300, // 5 minute cache
            cachePolicy: .cacheWithNetwork
        )
        var count = 0
        for await _ in dataSource.events {
            count += 1
        }
        await MainActor.run {
            self.commentCounts[highlightId] = count
        }
    }
}
// MARK: - Feed Item View
struct HighlightFeedItemView: View {
    let highlight: HighlightEvent
    let author: NDKUserProfile?
    let article: Article?
    let articleImage: UIImage?
    let onAuthorTap: () -> Void
    let onZap: () -> Void
    let onShare: () -> Void
    let onComment: () -> Void
    let commentCount: Int
    let onDoubleTap: () -> Void
    @State private var isLiked = false
    @State private var showingActions = false
    @State private var showHeartAnimation = false
    @State private var likeScale: CGFloat = 1.0
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // Background Layer - Fullscreen image with overlay
                if let articleImage = articleImage {
                    // Article image background with blur
                    Image(uiImage: articleImage)
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .frame(width: geometry.size.width, height: geometry.size.height)
                        .clipped()
                        .blur(radius: 20) // Gaussian blur
                        .opacity(0.4) // Standardized opacity (0.3-0.5)
                } else {
                    // Purple-to-orange gradient fallback
                    LinearGradient(
                        colors: [
                            Color(hex: "7B3FF2"), // Purple
                            Color(hex: "E94057"), // Pink-red
                            Color(hex: "F27121")  // Orange
                        ],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                }
                // Dark overlay for text contrast - increased to 0.5
                Color.black.opacity(0.5)
                    .ignoresSafeArea()
                // Main Content Layout
                VStack {
                    // Header Area - Source info capsule (top-left)
                    HStack {
                        HStack(spacing: 4) {
                            Text(sourceText)
                                .font(.system(size: 13, weight: .medium))
                                .foregroundColor(Color(hex: "CCCCCC"))
                            Text("·")
                                .font(.system(size: 13, weight: .medium))
                                .foregroundColor(Color(hex: "CCCCCC"))
                            Text(relativeTime(from: highlight.createdAt))
                                .font(.system(size: 13, weight: .medium))
                                .foregroundColor(Color(hex: "CCCCCC"))
                        }
                        .padding(.horizontal, 12)
                        .padding(.vertical, 6)
                        .background(
                            Capsule()
                                .fill(Color.black.opacity(0.3))
                                .overlay(
                                    Capsule()
                                        .strokeBorder(Color.white.opacity(0.1), lineWidth: 0.5)
                                )
                        )
                        .padding(.leading, 16)
                        .padding(.top, 16)
                        Spacer()
                    }
                    Spacer()
                    // Main Quote Block (centered vertically)
                    Text(highlight.content)
                        .font(.system(size: 26, weight: .semibold, design: .serif))
                        .foregroundColor(.white)
                        .lineSpacing(10)
                        .multilineTextAlignment(.center)
                        .frame(maxWidth: geometry.size.width * 0.8)
                        .shadow(color: .black.opacity(0.5), radius: 4, x: 0, y: 2)
                    Spacer()
                    // Bottom User Info (bottom-left)
                    HStack {
                        HStack(spacing: 10) {
                            // Small avatar or placeholder
                            Circle()
                                .fill(Color.white.opacity(0.2))
                                .frame(width: 32, height: 32)
                                .overlay(
                                    Text(authorInitial)
                                        .font(.system(size: 14, weight: .medium))
                                        .foregroundColor(.white)
                                )
                            Text(authorName)
                                .font(.system(size: 13, weight: .regular))
                                .foregroundColor(.white)
                            // Follow button only shown if not already following
                            // (Removed for now as it needs proper follow state management)
                        }
                        Spacer()
                    }
                    .padding(.horizontal, 16)
                    .padding(.bottom, 16)
                }
                // Action buttons overlay (positioned absolutely)
                VStack {
                    Spacer()
                    HStack {
                        Spacer()
                        // Actions Stack (bottom-right, vertical)
                        VStack(spacing: 16) {
                            // Like
                            Button(action: {
                                withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {
                                    isLiked.toggle()
                                }
                                HapticManager.shared.impact(.light)
                            }) {
                                VStack(spacing: 4) {
                                    ZStack {
                                        Circle()
                                            .fill(Color.black.opacity(0.3))
                                            .frame(width: 42, height: 42)
                                        Image(systemName: isLiked ? "heart.fill" : "heart")
                                            .font(.system(size: 20))
                                            .foregroundColor(isLiked ? .red : .white)
                                            .scaleEffect(isLiked ? 1.1 : 1.0)
                                    }
                                    .shadow(color: .black.opacity(0.3), radius: 3, x: 0, y: 2)
                                }
                            }
                            // Comment
                            Button(action: onComment) {
                                VStack(spacing: 4) {
                                    ZStack {
                                        Circle()
                                            .fill(Color.black.opacity(0.3))
                                            .frame(width: 42, height: 42)
                                        Image(systemName: "message")
                                            .font(.system(size: 18))
                                            .foregroundColor(.white)
                                    }
                                    .shadow(color: .black.opacity(0.3), radius: 3, x: 0, y: 2)
                                    if commentCount > 0 {
                                        Text("\(commentCount)")
                                            .font(.system(size: 11))
                                            .foregroundColor(.white.opacity(0.8))
                                    }
                                }
                            }
                            // Repost - removed for now as it needs implementation
                            // Share
                            Button(action: onShare) {
                                ZStack {
                                    Circle()
                                        .fill(Color.black.opacity(0.3))
                                        .frame(width: 42, height: 42)
                                    Image(systemName: "square.and.arrow.up")
                                        .font(.system(size: 18))
                                        .foregroundColor(.white)
                                }
                                .shadow(color: .black.opacity(0.3), radius: 3, x: 0, y: 2)
                            }
                        }
                        .padding(.trailing, 16)
                        .padding(.bottom, 80) // Extra padding to position above user info
                    }
                }
                // Double tap heart animation
                if showHeartAnimation {
                    Image(systemName: "heart.fill")
                        .font(.system(size: 120))
                        .foregroundStyle(
                            LinearGradient(
                                colors: [.red, .pink],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .scaleEffect(likeScale)
                        .opacity(showHeartAnimation ? 0 : 1)
                        .shadow(color: .black.opacity(0.3), radius: 10)
                        .allowsHitTesting(false)
                }
            }
        }
        .ignoresSafeArea()
        .onTapGesture(count: 2) {
            onDoubleTap()
            triggerLikeAnimation()
        }
    }
    private func triggerLikeAnimation() {
        withAnimation(.easeOut(duration: 0.1)) {
            likeScale = 1.3
            showHeartAnimation = true
            isLiked = true
        }
        withAnimation(.easeInOut(duration: 0.3).delay(0.1)) {
            likeScale = 0.8
        }
        withAnimation(.easeOut(duration: 0.2).delay(0.4)) {
            showHeartAnimation = false
            likeScale = 1.0
        }
    }
    // Computed properties for cleaner code
    private var sourceText: String {
        if let article = article {
            return article.title.count > 30 ? String(article.title.prefix(27)) + "..." : article.title
        } else if let url = highlight.url, let host = URL(string: url)?.host {
            return host.replacingOccurrences(of: "www.", with: "")
        } else {
            return "Highlight"
        }
    }
    private var authorName: String {
        if let name = author?.name ?? author?.displayName {
            return name.count > 20 ? String(name.prefix(17)) + "..." : name
        } else {
            return String(highlight.author.prefix(8))
        }
    }
    private var authorInitial: String {
        (author?.name ?? author?.displayName ?? "U").prefix(1).uppercased()
    }
    private func relativeTime(from date: Date) -> String {
        let formatter = RelativeDateTimeFormatter()
        formatter.unitsStyle = .abbreviated
        return formatter.localizedString(for: date, relativeTo: Date())
    }
}
struct HighlightProgressIndicator: View {
    let currentIndex: Int
    let total: Int
    @State private var animatedProgress: Double = 0
    var body: some View {
        HStack(spacing: 4) {
            ForEach(0..<total, id: \.self) { index in
                RoundedRectangle(cornerRadius: 2)
                    .fill(index == currentIndex ? Color.white : Color.white.opacity(0.3))
                    .frame(height: 3)
                    .scaleEffect(x: index == currentIndex ? animatedProgress : 1, y: 1, anchor: .leading)
            }
        }
        .padding(.horizontal, 20)
        .padding(.top, 10)
        .onAppear {
            withAnimation(.linear(duration: 5)) {
                animatedProgress = 1
            }
        }
        .onChange(of: currentIndex) { _, _ in
            animatedProgress = 0
            withAnimation(.linear(duration: 5)) {
                animatedProgress = 1
            }
        }
    }
}
struct CommentSheetView: View {
    let highlight: HighlightEvent
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) var dismiss
    @State private var commentText = ""
    @FocusState private var isCommentFieldFocused: Bool
    var body: some View {
        NavigationStack {
            VStack(spacing: 16) {
                // Highlight preview
                VStack(alignment: .leading, spacing: 8) {
                    Text("Replying to highlight")
                        .font(DesignSystem.Typography.caption)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                    Text(highlight.content)
                        .font(DesignSystem.Typography.body)
                        .foregroundColor(DesignSystem.Colors.text)
                        .lineLimit(3)
                        .padding()
                        .background(DesignSystem.Colors.surface)
                        .cornerRadius(12)
                }
                .padding(.horizontal)
                // Comment input
                VStack(alignment: .leading, spacing: 8) {
                    Text("Your comment")
                        .font(DesignSystem.Typography.caption)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                        .padding(.horizontal)
                    TextEditor(text: $commentText)
                        .padding(8)
                        .background(DesignSystem.Colors.surface)
                        .cornerRadius(12)
                        .frame(minHeight: 100)
                        .focused($isCommentFieldFocused)
                        .padding(.horizontal)
                }
                Spacer()
            }
            .padding(.top)
            .navigationTitle("Add Comment")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Post") {
                        Task {
                            await postComment()
                        }
                    }
                    .disabled(commentText.isEmpty)
                }
            }
        }
        .onAppear {
            isCommentFieldFocused = true
        }
    }
    private func postComment() async {
        guard !commentText.isEmpty else { return }
        do {
            try await appState.commentService.postComment(
                on: highlight.id,
                content: commentText
            )
            dismiss()
        } catch {
        }
    }
}
// MARK: - Extensions
extension HighlightsFeedView {
    private func prepareHaptics() {
        impactGenerator.prepare()
        selectionGenerator.prepare()
        hapticPrepared = true
    }
    private func createDragGesture() -> some Gesture {
        DragGesture()
            .onChanged { value in
                if !isDragging {
                    isDragging = true
                }
                dragOffset = value.translation
            }
            .onEnded { value in
                let threshold: CGFloat = 100
                let verticalThreshold: CGFloat = 150
                withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                    if abs(value.translation.height) > verticalThreshold {
                        // Vertical swipe - dismiss or refresh
                        if value.translation.height > 0 {
                            // Swipe down - could trigger refresh
                        }
                    } else if value.translation.width > threshold {
                        // Swipe right - previous
                        if currentIndex > 0 {
                            currentIndex -= 1
                        }
                    } else if value.translation.width < -threshold {
                        // Swipe left - next
                        if currentIndex < highlights.count - 1 {
                            currentIndex += 1
                        }
                    }
                    dragOffset = .zero
                    isDragging = false
                }
            }
    }
    private func likeHighlight(_ highlight: HighlightEvent) {
        impactGenerator.impactOccurred()
        Task {
            do {
                // Create a reaction event (kind: 7)
                try await appState.engagementService.react(
                    to: highlight.id,
                    reaction: "+"  // "+" is a like/upvote
                )
            } catch {
                // Handle reaction error
                HapticManager.shared.notification(.error)
            }
        }
    }
}
#Preview {
    HighlightsFeedView(tabBarVisible: .constant(false))
        .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Views/Highlights/ImmersiveHighlightDetailView.swift">
import SwiftUI
import NDKSwift
struct ImmersiveHighlightDetailView: View {
    let highlight: HighlightEvent
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) var dismiss
    // State
    @State private var author: NDKUserProfile?
    @State private var scrollOffset: CGFloat = 0
    @State private var showShareSheet = false
    @State private var showComments = false
    @State private var isBookmarked = false
    @State private var hasZapped = false
    @State private var engagementMetrics = EngagementService.EngagementMetrics()
    @State private var relatedHighlights: [HighlightEvent] = []
    // Animation states
    @State private var contentAppeared = false
    @State private var headerScale: CGFloat = 1.0
    @State private var glowAnimation = false
    @State private var floatingElementsAnimation = false
    @State private var reactionAnimation = false
    @State private var pulseAnimation = false
    // Gesture states
    @State private var dragOffset: CGSize = .zero
    @State private var isDragging = false
    var body: some View {
        NavigationStack {
            ZStack {
                // Animated gradient background
                animatedBackground
                ScrollViewReader { proxy in
                    ScrollView(.vertical, showsIndicators: false) {
                        VStack(spacing: 0) {
                            // Parallax header
                            parallaxHeader
                                .offset(y: scrollOffset > 0 ? -scrollOffset * 0.8 : 0)
                                .scaleEffect(scrollOffset > 0 ? 1 + scrollOffset / 500 : 1)
                                .opacity(1.0 - (scrollOffset / 200.0))
                            // Main content
                            mainContent
                                .offset(y: dragOffset.height)
                                .scaleEffect(isDragging ? 0.95 : 1.0)
                                .animation(.spring(response: 0.4, dampingFraction: 0.8), value: isDragging)
                        }
                        .background(GeometryReader { geo in
                            Color.clear.preference(
                                key: ScrollOffsetPreferenceKey.self,
                                value: geo.frame(in: .named("scroll")).minY
                            )
                        })
                    }
                    .coordinateSpace(name: "scroll")
                    .onPreferenceChange(ScrollOffsetPreferenceKey.self) { value in
                        scrollOffset = value
                    }
                }
                // Floating action buttons
                floatingActionButtons
                    .opacity(contentAppeared ? 1 : 0)
                    .animation(.spring(response: 0.6, dampingFraction: 0.8).delay(0.3), value: contentAppeared)
                // Custom navigation bar
                customNavigationBar
            }
            .navigationBarHidden(true)
            .gesture(dragGesture)
        }
        .task {
            await loadData()
            startAnimations()
        }
        .sheet(isPresented: $showShareSheet) {
            ShareSheet(items: [highlight.content])
        }
        .sheet(isPresented: $showComments) {
            CommentsSheetView(highlightId: highlight.id)
        }
    }
    // MARK: - Background
    private var animatedBackground: some View {
        ZStack {
            // Base gradient
            LinearGradient(
                colors: [
                    DesignSystem.Colors.background,
                    DesignSystem.Colors.primary.opacity(0.05),
                    DesignSystem.Colors.secondary.opacity(0.03)
                ],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            .ignoresSafeArea()
            // Floating orbs
            GeometryReader { geometry in
                ForEach(0..<5) { index in
                    Circle()
                        .fill(
                            RadialGradient(
                                colors: [
                                    DesignSystem.Colors.primary.opacity(0.15),
                                    DesignSystem.Colors.primary.opacity(0)
                                ],
                                center: .center,
                                startRadius: 0,
                                endRadius: 100
                            )
                        )
                        .frame(width: 200, height: 200)
                        .blur(radius: 30)
                        .offset(
                            x: floatingOffset(index: index, width: geometry.size.width).x,
                            y: floatingOffset(index: index, width: geometry.size.width).y
                        )
                        .opacity(floatingElementsAnimation ? 0.8 : 0.3)
                        .animation(
                            .easeInOut(duration: Double.random(in: 15...25))
                            .repeatForever(autoreverses: true)
                            .delay(Double(index) * 0.5),
                            value: floatingElementsAnimation
                        )
                }
            }
            .ignoresSafeArea()
        }
    }
    // MARK: - Parallax Header
    private var parallaxHeader: some View {
        ZStack(alignment: .bottom) {
            // Background image or gradient
            if let imageUrl = highlight.url {
                AsyncImage(url: URL(string: imageUrl)) { phase in
                    switch phase {
                    case .success(let image):
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                            .frame(height: 400)
                            .clipped()
                            .overlay(headerOverlay)
                    default:
                        headerGradient
                    }
                }
            } else {
                headerGradient
            }
            // Content overlay
            VStack(spacing: DesignSystem.Spacing.large) {
                Spacer()
                // Author info
                HStack(spacing: DesignSystem.Spacing.medium) {
                    EnhancedAsyncProfileImage(pubkey: highlight.author, size: 60)
                        .overlay(
                            Circle()
                                .stroke(Color.white.opacity(0.8), lineWidth: 3)
                        )
                        .shadow(radius: 10)
                        .scaleEffect(headerScale)
                    VStack(alignment: .leading, spacing: 4) {
                        Text(author?.displayName ?? PubkeyFormatter.formatCompact(highlight.author))
                            .font(.system(size: 20, weight: .semibold))
                            .foregroundColor(.white)
                        HStack(spacing: 4) {
                            Image(systemName: "clock")
                                .font(.system(size: 12))
                            Text(RelativeTimeFormatter.relativeTime(from: highlight.createdAt))
                                .font(.system(size: 14))
                        }
                        .foregroundColor(.white.opacity(0.8))
                    }
                    Spacer()
                    // Follow button
                    FollowButton(pubkey: highlight.author)
                }
                .padding(.horizontal, DesignSystem.Spacing.large)
                .padding(.bottom, DesignSystem.Spacing.large)
            }
        }
        .frame(height: 400)
        .clipShape(
            UnevenRoundedRectangle(
                bottomLeadingRadius: 40,
                bottomTrailingRadius: 40
            )
        )
        .shadow(radius: 20)
    }
    private var headerGradient: some View {
        ZStack {
            LinearGradient(
                colors: [
                    DesignSystem.Colors.primary,
                    DesignSystem.Colors.secondary
                ],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            // Animated pattern
            GeometryReader { geometry in
                ForEach(0..<20) { index in
                    Circle()
                        .fill(Color.white.opacity(0.05))
                        .frame(width: CGFloat.random(in: 20...60))
                        .position(
                            x: CGFloat.random(in: 0...geometry.size.width),
                            y: CGFloat.random(in: 0...geometry.size.height)
                        )
                        .blur(radius: 2)
                        .opacity(glowAnimation ? 0.8 : 0.3)
                        .animation(
                            .easeInOut(duration: Double.random(in: 3...6))
                            .repeatForever(autoreverses: true)
                            .delay(Double(index) * 0.1),
                            value: glowAnimation
                        )
                }
            }
        }
        .frame(height: 400)
        .overlay(headerOverlay)
    }
    private var headerOverlay: some View {
        LinearGradient(
            colors: [
                Color.black.opacity(0),
                Color.black.opacity(0.3),
                Color.black.opacity(0.6)
            ],
            startPoint: .top,
            endPoint: .bottom
        )
    }
    // MARK: - Main Content
    private var mainContent: some View {
        VStack(spacing: DesignSystem.Spacing.xl) {
            // Quote card with glass morphism
            quoteCard
                .padding(.horizontal, DesignSystem.Spacing.large)
                .padding(.top, -30) // Overlap with header
                .zIndex(1)
                .opacity(contentAppeared ? 1 : 0)
                .offset(y: contentAppeared ? 0 : 50)
                .animation(.spring(response: 0.8, dampingFraction: 0.8).delay(0.2), value: contentAppeared)
            // Engagement metrics
            engagementMetricsView
                .padding(.horizontal, DesignSystem.Spacing.large)
                .opacity(contentAppeared ? 1 : 0)
                .animation(.spring(response: 0.8, dampingFraction: 0.8).delay(0.3), value: contentAppeared)
            // Context section
            if let context = highlight.context {
                contextSection(context: context)
                    .padding(.horizontal, DesignSystem.Spacing.large)
                    .opacity(contentAppeared ? 1 : 0)
                    .animation(.spring(response: 0.8, dampingFraction: 0.8).delay(0.4), value: contentAppeared)
            }
            // Author's note
            if let comment = highlight.comment {
                authorNoteSection(comment: comment)
                    .padding(.horizontal, DesignSystem.Spacing.large)
                    .opacity(contentAppeared ? 1 : 0)
                    .animation(.spring(response: 0.8, dampingFraction: 0.8).delay(0.5), value: contentAppeared)
            }
            // Related highlights
            relatedHighlightsSection
                .opacity(contentAppeared ? 1 : 0)
                .animation(.spring(response: 0.8, dampingFraction: 0.8).delay(0.6), value: contentAppeared)
            // Spacer for floating buttons
            Color.clear.frame(height: 100)
        }
        .padding(.bottom, DesignSystem.Spacing.huge)
    }
    // MARK: - Quote Card
    private var quoteCard: some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.medium) {
            // Opening quote mark
            Text("\u{201C}")
                .font(.system(size: 60, weight: .black, design: .serif))
                .foregroundColor(DesignSystem.Colors.primary.opacity(0.3))
                .offset(x: -10, y: 20)
            // Highlighted text with selection effect
            Text(highlight.content)
                .font(.system(size: 22, weight: .medium, design: .rounded))
                .foregroundColor(DesignSystem.Colors.text)
                .lineSpacing(8)
                .fixedSize(horizontal: false, vertical: true)
                .padding(.horizontal, DesignSystem.Spacing.medium)
                .background(
                    RoundedRectangle(cornerRadius: 8)
                        .fill(DesignSystem.Colors.highlightSubtle.opacity(0.2))
                        .padding(.horizontal, -8)
                )
                .scaleEffect(pulseAnimation ? 1.02 : 1.0)
                .animation(
                    .easeInOut(duration: 3)
                    .repeatForever(autoreverses: true),
                    value: pulseAnimation
                )
            // Closing quote mark
            HStack {
                Spacer()
                Text("\u{201D}")
                    .font(.system(size: 60, weight: .black, design: .serif))
                    .foregroundColor(DesignSystem.Colors.primary.opacity(0.3))
                    .offset(x: 10, y: -20)
            }
        }
        .padding(DesignSystem.Spacing.xl)
        .background(glassMorphismBackground)
        .clipShape(RoundedRectangle(cornerRadius: 24, style: .continuous))
        .shadow(color: DesignSystem.Colors.primary.opacity(0.1), radius: 20, y: 10)
        .overlay(
            RoundedRectangle(cornerRadius: 24, style: .continuous)
                .stroke(
                    LinearGradient(
                        colors: [
                            Color.white.opacity(0.6),
                            Color.white.opacity(0.1)
                        ],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    ),
                    lineWidth: 1
                )
        )
    }
    private var glassMorphismBackground: some View {
        ZStack {
            // Base blur
            VisualEffectBlur(blurStyle: .systemUltraThinMaterial)
            // Gradient overlay
            LinearGradient(
                colors: [
                    DesignSystem.Colors.primary.opacity(0.05),
                    DesignSystem.Colors.secondary.opacity(0.05)
                ],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
        }
    }
    // MARK: - Engagement Metrics
    private var engagementMetricsView: some View {
        HStack(spacing: 0) {
            MetricView(
                icon: "heart.fill",
                value: engagementMetrics.likes,
                color: .red,
                label: "Likes"
            )
            Spacer()
            MetricView(
                icon: "bubble.right.fill",
                value: engagementMetrics.comments,
                color: .blue,
                label: "Comments"
            )
            Spacer()
            MetricView(
                icon: "arrow.2.squarepath",
                value: engagementMetrics.reposts,
                color: .green,
                label: "Reposts"
            )
            Spacer()
            MetricView(
                icon: "bolt.fill",
                value: engagementMetrics.zaps,
                color: .orange,
                label: "Zaps"
            )
        }
        .padding(.horizontal, DesignSystem.Spacing.medium)
        .padding(.vertical, DesignSystem.Spacing.large)
        .background(
            RoundedRectangle(cornerRadius: 20, style: .continuous)
                .fill(DesignSystem.Colors.surfaceSecondary)
        )
    }
    // MARK: - Context Section
    private func contextSection(context: String) -> some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.medium) {
            Label("Context", systemImage: "text.alignleft")
                .font(.system(size: 18, weight: .semibold))
                .foregroundColor(DesignSystem.Colors.text)
            Text(context)
                .font(.system(size: 16))
                .foregroundColor(DesignSystem.Colors.textSecondary)
                .lineSpacing(4)
        }
        .padding(DesignSystem.Spacing.large)
        .background(
            RoundedRectangle(cornerRadius: 16, style: .continuous)
                .fill(DesignSystem.Colors.surface)
        )
    }
    // MARK: - Author Note Section
    private func authorNoteSection(comment: String) -> some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.medium) {
            HStack {
                EnhancedAsyncProfileImage(pubkey: highlight.author, size: 32)
                VStack(alignment: .leading, spacing: 2) {
                    Text("Author's Note")
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundColor(DesignSystem.Colors.text)
                    Text(author?.displayName ?? "Author")
                        .font(.system(size: 14))
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                }
                Spacer()
                Image(systemName: "quote.bubble.fill")
                    .font(.system(size: 20))
                    .foregroundColor(DesignSystem.Colors.primary.opacity(0.5))
            }
            Text(comment)
                .font(.system(size: 16))
                .foregroundColor(DesignSystem.Colors.text)
                .lineSpacing(4)
        }
        .padding(DesignSystem.Spacing.large)
        .background(
            RoundedRectangle(cornerRadius: 16, style: .continuous)
                .fill(
                    LinearGradient(
                        colors: [
                            DesignSystem.Colors.primary.opacity(0.05),
                            DesignSystem.Colors.primary.opacity(0.02)
                        ],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .overlay(
                    RoundedRectangle(cornerRadius: 16, style: .continuous)
                        .stroke(DesignSystem.Colors.primary.opacity(0.2), lineWidth: 1)
                )
        )
    }
    // MARK: - Related Highlights
    private var relatedHighlightsSection: some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.large) {
            Text("Related Highlights")
                .font(.system(size: 24, weight: .bold))
                .foregroundColor(DesignSystem.Colors.text)
                .padding(.horizontal, DesignSystem.Spacing.large)
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: DesignSystem.Spacing.medium) {
                    ForEach(relatedHighlights, id: \.id) { relatedHighlight in
                        RelatedHighlightCard(highlight: relatedHighlight)
                            .frame(width: 280)
                    }
                }
                .padding(.horizontal, DesignSystem.Spacing.large)
            }
        }
    }
    // MARK: - Floating Action Buttons
    private var floatingActionButtons: some View {
        VStack {
            Spacer()
            HStack(spacing: DesignSystem.Spacing.large) {
                // Bookmark button
                ImmersiveFloatingActionButton(
                    icon: isBookmarked ? "bookmark.fill" : "bookmark",
                    color: .blue,
                    isActive: isBookmarked,
                    action: toggleBookmark
                )
                // Comment button
                ImmersiveFloatingActionButton(
                    icon: "bubble.left.fill",
                    color: .green,
                    badge: engagementMetrics.comments > 0 ? "\(engagementMetrics.comments)" : nil,
                    action: { showComments = true }
                )
                // Zap button
                ImmersiveFloatingActionButton(
                    icon: "bolt.fill",
                    color: .orange,
                    isActive: hasZapped,
                    action: zapHighlight
                )
                // Share button
                ImmersiveFloatingActionButton(
                    icon: "square.and.arrow.up",
                    color: .purple,
                    action: { showShareSheet = true }
                )
            }
            .padding(.horizontal, DesignSystem.Spacing.xl)
            .padding(.bottom, DesignSystem.Spacing.xl)
        }
    }
    // MARK: - Navigation Bar
    private var customNavigationBar: some View {
        VStack {
            HStack {
                Button(action: { dismiss() }) {
                    Image(systemName: "chevron.left")
                        .font(.system(size: 20, weight: .semibold))
                        .foregroundColor(scrollOffset < -50 ? DesignSystem.Colors.text : .white)
                        .padding(12)
                        .background(
                            Circle()
                                .fill(scrollOffset < -50 ? DesignSystem.Colors.surface : Color.black.opacity(0.3))
                                .shadow(radius: 4)
                        )
                }
                Spacer()
                if scrollOffset < -100 {
                    Text("Highlight")
                        .font(.system(size: 18, weight: .semibold))
                        .foregroundColor(DesignSystem.Colors.text)
                        .transition(.opacity)
                }
                Spacer()
                Menu {
                    Button(action: {}) {
                        Label("Report", systemImage: "exclamationmark.triangle")
                    }
                    Button(action: {}) {
                        Label("Copy Link", systemImage: "link")
                    }
                } label: {
                    Image(systemName: "ellipsis")
                        .font(.system(size: 20, weight: .semibold))
                        .foregroundColor(scrollOffset < -50 ? DesignSystem.Colors.text : .white)
                        .padding(12)
                        .background(
                            Circle()
                                .fill(scrollOffset < -50 ? DesignSystem.Colors.surface : Color.black.opacity(0.3))
                                .shadow(radius: 4)
                        )
                }
            }
            .padding(.horizontal, DesignSystem.Spacing.medium)
            .padding(.top, 50) // Account for status bar
            .background(
                scrollOffset < -50 ?
                    AnyView(
                        DesignSystem.Colors.background
                            .opacity(0.95)
                            .background(.ultraThinMaterial)
                            .ignoresSafeArea()
                    ) :
                    AnyView(Color.clear)
            )
            .animation(.easeInOut(duration: 0.3), value: scrollOffset)
            Spacer()
        }
    }
    // MARK: - Gestures
    private var dragGesture: some Gesture {
        DragGesture()
            .onChanged { value in
                if value.translation.height > 0 {
                    dragOffset = value.translation
                    isDragging = true
                }
            }
            .onEnded { value in
                if value.translation.height > 100 {
                    dismiss()
                } else {
                    withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                        dragOffset = .zero
                        isDragging = false
                    }
                }
            }
    }
    // MARK: - Helper Methods
    private func loadData() async {
        guard appState.ndk != nil else { return }
        // Load author profile
        if let profile = appState.profileManager.getCachedProfile(for: highlight.author) {
            await MainActor.run {
                self.author = profile
            }
        }
        // Load engagement metrics
        let metrics = await appState.engagementService.fetchEngagementBatch(for: [highlight.id])
        await MainActor.run {
            self.engagementMetrics = metrics[highlight.id] ?? EngagementService.EngagementMetrics()
        }
        // Load related highlights from the same source
        if let sourceUrl = highlight.source, let ndk = appState.ndk {
            // Fetch highlights from the same source
            let filter = NDKFilter(
                kinds: [9802], // NIP-84 highlights
                tags: ["r": Set([sourceUrl])]
            )
            var relatedEvents: [NDKEvent] = []
            let dataSource = await ndk.outbox.observe(filter: filter, maxAge: 3600, cachePolicy: .cacheWithNetwork)
            for await event in dataSource.events {
                relatedEvents.append(event)
                if relatedEvents.count >= 10 { break } // Limit to prevent excessive loading
            }
            let related = relatedEvents
                .compactMap { try? HighlightEvent(from: $0) }
                .filter { $0.id != highlight.id } // Exclude current highlight
                .prefix(5)
            await MainActor.run {
                self.relatedHighlights = Array(related)
            }
        } else if let ndk = appState.ndk {
            // If no source, fetch recent highlights by the same author
            let filter = NDKFilter(
                authors: [highlight.pubkey],
                kinds: [9802], // NIP-84 highlights
                limit: 6
            )
            var authorHighlights: [NDKEvent] = []
            let dataSource = await ndk.outbox.observe(filter: filter, maxAge: 3600, cachePolicy: .cacheWithNetwork)
            for await event in dataSource.events {
                authorHighlights.append(event)
                if authorHighlights.count >= 6 { break }
            }
            let related = authorHighlights
                .compactMap { try? HighlightEvent(from: $0) }
                .filter { $0.id != highlight.id } // Exclude current highlight
                .prefix(5)
            await MainActor.run {
                self.relatedHighlights = Array(related)
            }
        }
    }
    private func startAnimations() {
        withAnimation(.easeInOut(duration: 0.6)) {
            contentAppeared = true
        }
        withAnimation(.spring(response: 0.8, dampingFraction: 0.6)) {
            headerScale = 1.1
        }
        withAnimation(.easeInOut(duration: 2).repeatForever(autoreverses: true)) {
            glowAnimation = true
            pulseAnimation = true
        }
        floatingElementsAnimation = true
    }
    private func floatingOffset(index: Int, width: CGFloat) -> CGPoint {
        let baseX = CGFloat(index) * width / 5
        let baseY = CGFloat(index * 100)
        let offsetX = floatingElementsAnimation ? CGFloat.random(in: -50...50) : 0
        let offsetY = floatingElementsAnimation ? CGFloat.random(in: -50...50) : 0
        return CGPoint(x: baseX + offsetX, y: baseY + offsetY)
    }
    private func toggleBookmark() {
        withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {
            isBookmarked.toggle()
        }
        HapticManager.shared.impact(.medium)
        Task {
            do {
                try await appState.bookmarkService.toggleHighlightBookmark(highlight)
            } catch {
                // Revert the UI state on error
                await MainActor.run {
                    withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {
                        isBookmarked.toggle()
                    }
                }
                HapticManager.shared.notification(.error)
            }
        }
    }
    private func zapHighlight() {
        withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {
            hasZapped = true
            reactionAnimation = true
        }
        HapticManager.shared.notification(.success)
        // Trigger zap flow
        Task {
            do {
                if appState.lightningService.isConnected {
                    // Use smart zap for highlights to split payments
                    _ = try await appState.lightningService.sendSmartZap(
                        amount: 21, // Default zap amount
                        to: highlight,
                        article: nil, // No article context in this view
                        comment: "⚡ Zapped via Highlighter"
                    )
                } else {
                    // Show wallet connection UI if not connected
                    await MainActor.run {
                        hasZapped = false
                    }
                }
            } catch {
                HapticManager.shared.notification(.error)
                await MainActor.run {
                    hasZapped = false
                }
            }
        }
        // Reset animation
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            reactionAnimation = false
        }
    }
}
// MARK: - Supporting Views
struct MetricView: View {
    let icon: String
    let value: Int
    let color: Color
    let label: String
    @State private var animatedValue: Int = 0
    var body: some View {
        VStack(spacing: 8) {
            Image(systemName: icon)
                .font(.system(size: 24))
                .foregroundColor(color)
                .scaleEffect(animatedValue > 0 ? 1.1 : 1.0)
                .animation(.spring(response: 0.3, dampingFraction: 0.6), value: animatedValue)
            Text("\(animatedValue)")
                .font(.system(size: 18, weight: .bold, design: .rounded))
                .foregroundColor(DesignSystem.Colors.text)
                .contentTransition(.numericText())
            Text(label)
                .font(.system(size: 12))
                .foregroundColor(DesignSystem.Colors.textSecondary)
        }
        .onAppear {
            withAnimation(.spring(response: 0.6, dampingFraction: 0.8)) {
                animatedValue = value
            }
        }
    }
}
struct ImmersiveFloatingActionButton: View {
    let icon: String
    let color: Color
    var isActive: Bool = false
    var badge: String? = nil
    let action: () -> Void
    @State private var isPressed = false
    var body: some View {
        Button(action: action) {
            ZStack(alignment: .topTrailing) {
                Circle()
                    .fill(isActive ? color : DesignSystem.Colors.surface)
                    .frame(width: 56, height: 56)
                    .overlay(
                        Circle()
                            .stroke(color, lineWidth: isActive ? 0 : 2)
                    )
                    .shadow(
                        color: isActive ? color.opacity(0.4) : DesignSystem.Shadow.medium.color,
                        radius: isActive ? 15 : DesignSystem.Shadow.medium.radius,
                        y: DesignSystem.Shadow.medium.y
                    )
                    .overlay(
                        Image(systemName: icon)
                            .font(.system(size: 22))
                            .foregroundColor(isActive ? .white : color)
                    )
                    .scaleEffect(isPressed ? 0.9 : 1.0)
                if let badge = badge {
                    Text(badge)
                        .font(.system(size: 12, weight: .bold))
                        .foregroundColor(.white)
                        .padding(4)
                        .background(Circle().fill(Color.red))
                        .offset(x: 8, y: -8)
                }
            }
        }
        .buttonStyle(PlainButtonStyle())
        .onLongPressGesture(minimumDuration: 0.1, maximumDistance: .infinity, pressing: { pressing in
            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                isPressed = pressing
            }
            if pressing {
                HapticManager.shared.impact(.light)
            }
        }, perform: {})
    }
}
struct RelatedHighlightCard: View {
    let highlight: HighlightEvent
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text(highlight.content)
                .font(.system(size: 16, weight: .medium))
                .foregroundColor(DesignSystem.Colors.text)
                .lineLimit(3)
                .multilineTextAlignment(.leading)
            HStack {
                EnhancedAsyncProfileImage(pubkey: highlight.author, size: 24)
                Text(PubkeyFormatter.formatCompact(highlight.author))
                    .font(.system(size: 14))
                    .foregroundColor(DesignSystem.Colors.textSecondary)
                Spacer()
                Text(RelativeTimeFormatter.shortRelativeTime(from: highlight.createdAt))
                    .font(.system(size: 12))
                    .foregroundColor(DesignSystem.Colors.textTertiary)
            }
        }
        .padding(DesignSystem.Spacing.medium)
        .background(
            RoundedRectangle(cornerRadius: 16, style: .continuous)
                .fill(DesignSystem.Colors.surface)
                .shadow(color: DesignSystem.Shadow.small.color, radius: DesignSystem.Shadow.small.radius)
        )
    }
}
struct FollowButton: View {
    let pubkey: String
    @State private var isFollowing = false
    @State private var isLoading = false
    var body: some View {
        Button(action: toggleFollow) {
            HStack(spacing: 6) {
                if isLoading {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle(tint: .white))
                        .scaleEffect(0.8)
                } else {
                    Image(systemName: isFollowing ? "person.fill.checkmark" : "person.fill.badge.plus")
                        .font(.system(size: 14))
                    Text(isFollowing ? "Following" : "Follow")
                        .font(.system(size: 14, weight: .medium))
                }
            }
            .foregroundColor(.white)
            .padding(.horizontal, 16)
            .padding(.vertical, 8)
            .background(
                Capsule()
                    .fill(isFollowing ? Color.white.opacity(0.2) : DesignSystem.Colors.primary)
                    .overlay(
                        Capsule()
                            .stroke(Color.white.opacity(isFollowing ? 0.5 : 0), lineWidth: 1)
                    )
            )
            .shadow(radius: 4)
        }
        .disabled(isLoading)
    }
    private func toggleFollow() {
        HapticManager.shared.impact(.light)
        isLoading = true
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                isFollowing.toggle()
                isLoading = false
            }
        }
    }
}
struct CommentsSheetView: View {
    let highlightId: String
    @Environment(\.dismiss) var dismiss
    var body: some View {
        NavigationStack {
            CommentsSection(highlightId: highlightId)
                .navigationTitle("Comments")
                .navigationBarTitleDisplayMode(.inline)
                .toolbar {
                    ToolbarItem(placement: .navigationBarTrailing) {
                        Button("Done") {
                            dismiss()
                        }
                    }
                }
        }
    }
}
struct VisualEffectBlur: UIViewRepresentable {
    var blurStyle: UIBlurEffect.Style
    func makeUIView(context: Context) -> UIVisualEffectView {
        UIVisualEffectView(effect: UIBlurEffect(style: blurStyle))
    }
    func updateUIView(_ uiView: UIVisualEffectView, context: Context) {
        uiView.effect = UIBlurEffect(style: blurStyle)
    }
}
#Preview {
    ImmersiveHighlightDetailView(
        highlight: HighlightEvent(
            id: "1",
            event: NDKEvent(id: "", pubkey: "", createdAt: 0, kind: 9802, tags: [], content: "", sig: ""),
            content: PreviewData.highlightTexts[0],
            author: "npub1sg6plzptd64u62a878hep2kev88swjh3tw00gjsfl8f237lmu63q0uf63m",
            createdAt: Date(),
            context: PreviewData.highlightContexts[0],
            url: PreviewData.articleURLs[3],
            referencedEvent: nil,
            attributedAuthors: [],
            comment: "This perfectly captures the essence of ubiquitous computing. When technology becomes truly integrated into our lives, it stops being technology and becomes part of the fabric of existence."
        )
    )
    .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Views/Home/HomeDataManager.swift">
import SwiftUI
import NDKSwift
/// Manages home-specific data streaming and state, composing with DataStreamManager
/// This class focuses on home view specific data while delegating common data to DataStreamManager
@MainActor
class HomeDataManager: ObservableObject {
    // MARK: - Published State
    // Home-specific data only
    @Published var highlightedArticles: [HighlightedArticle] = []
    @Published var discussions: [NDKEvent] = []
    @Published var zappedArticles: [NDKEvent] = []
    @Published var userHighlights: [HighlightEvent] = []
    @Published var suggestedUsers: [NDKUserProfile] = []
    @Published var suggestedUserPubkeys: [String] = []
    @Published var isRefreshing = false
    // Common data from DataStreamManager
    var highlights: [HighlightEvent] { appState?.highlights ?? [] }
    var curations: [ArticleCuration] { appState?.curations ?? [] }
    // MARK: - Private Properties
    private var streamingTasks: [Task<Void, Never>] = []
    var appState: AppState? { // Made non-weak and internal for setting from view
        didSet {
            // Set up bindings to DataStreamManager when appState is set
            setupDataStreamBindings()
        }
    }
    // MARK: - Models
    struct HighlightedArticle {
        let article: Article
        let highlights: [HighlightEvent]
        let lastHighlightTime: Date
    }
    // MARK: - Initialization
    init() {
        // AppState will be set by the view that creates this manager
    }
    private func setupDataStreamBindings() {
        // DataStreamManager already handles highlights and curations
        // We only need to manage home-specific data
    }
    // MARK: - Public Methods
    /// Start streaming home-specific data sources
    func startStreaming() async {
        guard let ndk = appState?.ndk else { return }
        stopAllStreams()
        // Start home-specific streams only
        // Common data (highlights, curations) is handled by DataStreamManager
        await withTaskGroup(of: Void.self) { group in
            group.addTask { await self.fetchRecentlyHighlightedArticles(ndk: ndk) }
            group.addTask { await self.streamUserHighlights(ndk: ndk) }
            group.addTask { await self.streamDiscussions(ndk: ndk) }
            group.addTask { await self.streamZappedArticles(ndk: ndk) }
            group.addTask { await self.fetchSuggestedUsers(ndk: ndk) }
        }
    }
    /// Refresh all content by clearing and re-streaming
    func refresh() async {
        isRefreshing = true
        HapticManager.shared.impact(HapticManager.ImpactStyle.light)
        // Clear home-specific data only
        highlightedArticles.removeAll()
        discussions.removeAll()
        zappedArticles.removeAll()
        userHighlights.removeAll()
        suggestedUsers.removeAll()
        suggestedUserPubkeys.removeAll()
        // Trigger refresh on DataStreamManager for common data
        await appState?.dataStreamManager.refresh()
        // Restart home-specific streaming
        await startStreaming()
        HapticManager.shared.notification(.success)
        isRefreshing = false
    }
    /// Stop all streaming tasks
    func stopAllStreams() {
        for task in streamingTasks {
            task.cancel()
        }
        streamingTasks.removeAll()
    }
    // MARK: - Private Streaming Methods
    /// Fetch recently highlighted articles using highlights from DataStreamManager
    private func fetchRecentlyHighlightedArticles(ndk: NDK) async {
        // Wait for DataStreamManager to load some highlights
        var attempts = 0
        while highlights.isEmpty && attempts < 10 {
            try? await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds
            attempts += 1
        }
        // Use highlights from DataStreamManager
        let sevenDaysAgo = Date().addingTimeInterval(-7 * 24 * 60 * 60)
        let recentHighlights = highlights.filter { $0.createdAt > sevenDaysAgo }
        var articleReferences: Set<String> = []
        var highlightsByArticle: [String: [HighlightEvent]] = [:]
        // Process recent highlights
        for highlight in recentHighlights {
            // Track article references
            if let ref = highlight.referencedEvent {
                articleReferences.insert(ref)
                if highlightsByArticle[ref] != nil {
                    highlightsByArticle[ref]?.append(highlight)
                } else {
                    highlightsByArticle[ref] = [highlight]
                }
            }
        }
        // Now fetch the referenced articles
        if !articleReferences.isEmpty {
            await fetchHighlightedArticles(
                ndk: ndk,
                references: Array(articleReferences),
                highlightsByArticle: highlightsByArticle
            )
        }
    }
    // Removed streamHighlights - now handled by DataStreamManager
    private func streamUserHighlights(ndk: NDK) async {
        guard let signer = appState?.activeSigner else { return }
        let task = Task {
            do {
                let userPubkey = try await signer.pubkey
                let userHighlightSource = await ndk.outbox.observe(
                    filter: NDKFilter(
                        authors: [userPubkey],
                        kinds: [9802],
                        limit: 5
                    ),
                    maxAge: CachePolicies.mediumTerm
                )
                for await event in userHighlightSource.events {
                    if let highlight = try? HighlightEvent(from: event) {
                        await MainActor.run {
                            withAnimation(DesignSystem.Animation.quick) {
                                if !userHighlights.contains(where: { $0.id == highlight.id }) {
                                    userHighlights.append(highlight)
                                    userHighlights.sort { $0.createdAt > $1.createdAt }
                                }
                            }
                        }
                    }
                }
            } catch {
            }
        }
        streamingTasks.append(task)
    }
    private func streamDiscussions(ndk: NDK) async {
        let task = Task {
            let discussionSource = await ndk.outbox.observe(
                filter: NDKFilter(kinds: [1], limit: 10, tags: ["t": Set(["bookstr"])]),
                maxAge: CachePolicies.shortTerm,
                cachePolicy: .cacheWithNetwork
            )
            for await event in discussionSource.events {
                await MainActor.run {
                    withAnimation(DesignSystem.Animation.quick) {
                        if !discussions.contains(where: { $0.id == event.id }) {
                            discussions.append(event)
                            discussions.sort { $0.createdAt > $1.createdAt }
                        }
                    }
                }
            }
        }
        streamingTasks.append(task)
    }
    private func streamZappedArticles(ndk: NDK) async {
        let task = Task {
            let zapSource = await ndk.outbox.observe(
                filter: NDKFilter(kinds: [9735], limit: 10),
                maxAge: CachePolicies.shortTerm,
                cachePolicy: .cacheWithNetwork
            )
            for await event in zapSource.events {
                await MainActor.run {
                    withAnimation(DesignSystem.Animation.quick) {
                        if !zappedArticles.contains(where: { $0.id == event.id }) {
                            zappedArticles.append(event)
                            zappedArticles.sort { $0.createdAt > $1.createdAt }
                        }
                    }
                }
            }
        }
        streamingTasks.append(task)
    }
    private func fetchHighlightedArticles(
        ndk: NDK,
        references: [String],
        highlightsByArticle: [String: [HighlightEvent]]
    ) async {
        // Parse references to extract article IDs
        var articleFilters: [NDKFilter] = []
        for reference in references {
            if reference.contains(":") {
                // This is an "a" tag reference (kind:pubkey:d-tag)
                let parts = reference.split(separator: ":")
                if parts.count >= 3,
                   let kind = Int(parts[0]) {
                    let dTag = parts[2...].joined(separator: ":") // Handle d-tags with colons
                    articleFilters.append(NDKFilter(
                        authors: [String(parts[1])],
                        kinds: [kind],
                        tags: ["d": Set([dTag])]
                    ))
                }
            } else {
                // This is an "e" tag reference (event ID)
                articleFilters.append(NDKFilter(ids: [reference]))
            }
        }
        // Fetch articles for each filter
        for filter in articleFilters {
            let dataSource = NDKDataSource(
                ndk: ndk,
                filter: filter,
                maxAge: 0,
                cachePolicy: .networkOnly,
                closeOnEose: true
            )
            for await event in dataSource.events {
                if event.kind == 30023,
                   let article = try? Article(from: event) {
                    // Check both formats: event ID and "a" tag format
                    let aTagReference = "\(event.kind):\(event.pubkey):\(article.identifier ?? "")"
                    let highlights = highlightsByArticle[event.id] ?? highlightsByArticle[aTagReference]
                    if let highlights = highlights {
                        let lastHighlight = highlights.max(by: { $0.createdAt < $1.createdAt })
                        await MainActor.run {
                            withAnimation(DesignSystem.Animation.quick) {
                                let highlightedArticle = HighlightedArticle(
                                    article: article,
                                    highlights: highlights,
                                    lastHighlightTime: lastHighlight?.createdAt ?? Date()
                                )
                                if !highlightedArticles.contains(where: { $0.article.id == article.id }) {
                                    highlightedArticles.append(highlightedArticle)
                                    highlightedArticles.sort { $0.lastHighlightTime > $1.lastHighlightTime }
                                    // Limit to top 10 most recently highlighted articles
                                    if highlightedArticles.count > 10 {
                                        highlightedArticles = Array(highlightedArticles.prefix(10))
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    // Removed streamCurations - now handled by DataStreamManager
    private func fetchSuggestedUsers(ndk: NDK) async {
        // Fetch users who are actively creating highlights
        let highlightersFilter = NDKFilter(
            kinds: [9802],
            limit: 50
        )
        let dataSource = NDKDataSource(
            ndk: ndk,
            filter: highlightersFilter,
            maxAge: CachePolicies.mediumTerm,
            cachePolicy: .cacheOnly,
            closeOnEose: true
        )
        var userPubkeys = Set<String>()
        // Collect unique pubkeys from recent highlights
        for await event in dataSource.events {
            userPubkeys.insert(event.pubkey)
            if userPubkeys.count >= 20 {
                break
            }
        }
        // Fetch profiles for these users
        guard !userPubkeys.isEmpty else { return }
        let profileFilter = NDKFilter(
            authors: Array(userPubkeys),
            kinds: [0]
        )
        let profileSource = NDKDataSource(
            ndk: ndk,
            filter: profileFilter,
            maxAge: 0,
            cachePolicy: .cacheWithNetwork,
            closeOnEose: true
        )
        var profilesWithPubkeys: [(profile: NDKUserProfile, pubkey: String)] = []
        for await event in profileSource.events {
            if event.kind == 0,
               let profile = JSONCoding.safeDecode(NDKUserProfile.self, from: event.content) {
                profilesWithPubkeys.append((profile: profile, pubkey: event.pubkey))
            }
        }
        // Update suggested users - we'll need to handle this differently
        await MainActor.run {
            withAnimation(DesignSystem.Animation.quick) {
                // For now, store pubkeys separately
                suggestedUserPubkeys = profilesWithPubkeys.map { $0.pubkey }
                suggestedUsers = profilesWithPubkeys
                    .filter { $0.profile.displayName != nil || $0.profile.name != nil } // Only users with names
                    .prefix(10)
                    .map { $0.profile }
            }
        }
    }
    // MARK: - Cleanup
    deinit {
        Task { @MainActor [weak self] in
            self?.stopAllStreams()
        }
    }
}
</file>

<file path="Sources/Highlighter/Views/Home/SimplifiedHybridFeedView.swift">
import SwiftUI
import NDKSwift
// Make NDKEvent conform to Identifiable for SwiftUI usage
extension NDKEvent: @retroactive Identifiable {}
struct SimplifiedHybridFeedView: View {
    @EnvironmentObject var appState: AppState
    @StateObject private var dataManager = HomeDataManager()
    @State private var selectedSection = 0
    @State private var scrollOffset: CGFloat = 0
    @State private var headerOpacity: Double = 1
    @State private var discussionEngagements: [String: EngagementService.EngagementMetrics] = [:]
    @State private var isRefreshing = false
    @State private var refreshProgress: CGFloat = 0
    @State private var showFloatingElements = true
    @State private var contentAppeared = false
    // Dynamic gradient colors that shift based on time of day
    private var gradientColors: [Color] {
        let hour = Calendar.current.component(.hour, from: Date())
        switch hour {
        case 5..<12: // Morning - warm orange tones
            return [DesignSystem.Colors.secondary.opacity(0.2), DesignSystem.Colors.secondaryLight.opacity(0.1)]
        case 12..<17: // Afternoon - purple to orange blend
            return [DesignSystem.Colors.primary.opacity(0.15), DesignSystem.Colors.secondary.opacity(0.1)]
        case 17..<21: // Evening - deeper purple tones
            return [DesignSystem.Colors.primary.opacity(0.2), DesignSystem.Colors.primaryDark.opacity(0.15)]
        default: // Night - subtle dark purple
            return [DesignSystem.Colors.primaryDark.opacity(0.15), DesignSystem.Colors.primary.opacity(0.08)]
        }
    }
    // MARK: - Engagement Fetching
    private func fetchHighlightEngagements() async {
        let eventIds = dataManager.userHighlights.map { $0.id }
        guard !eventIds.isEmpty else { return }
        let engagements = await appState.engagementService.fetchEngagementBatch(for: eventIds)
        await MainActor.run {
        }
    }
    private func fetchDiscussionEngagements() async {
        let eventIds = dataManager.discussions.prefix(10).map { $0.id }
        guard !eventIds.isEmpty else { return }
        let engagements = await appState.engagementService.fetchEngagementBatch(for: eventIds)
        await MainActor.run {
            discussionEngagements = engagements
        }
    }
    var body: some View {
        NavigationStack {
            ZStack(alignment: .top) {
                // Animated gradient background with floating elements
                ZStack {
                    LinearGradient(
                        colors: gradientColors,
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                    .ignoresSafeArea()
                    .opacity(0.3)
                    .animation(.easeInOut(duration: 3), value: gradientColors)
                    // Floating ambient elements
                    if showFloatingElements {
                        FloatingAmbientView()
                            .ignoresSafeArea()
                            .opacity(contentAppeared ? 1 : 0)
                            .animation(.easeIn(duration: 1.5), value: contentAppeared)
                    }
                }
                // Custom refresh indicator
                RefreshIndicatorView(progress: refreshProgress, isRefreshing: isRefreshing)
                    .offset(y: -80 + (scrollOffset > 0 ? scrollOffset * 0.5 : 0))
                    .opacity(scrollOffset > 10 ? 1 : 0)
                    .animation(.spring(response: 0.3), value: scrollOffset)
                ScrollViewReader { scrollProxy in
                    ScrollView(.vertical, showsIndicators: false) {
                        VStack(spacing: 0) {
                            // Parallax header with live indicator
                            headerView
                                .padding(.horizontal, DesignSystem.Spacing.large)
                                .padding(.top, DesignSystem.Spacing.medium)
                                .offset(y: scrollOffset * 0.5)
                                .opacity(headerOpacity)
                                .id("header")
                            VStack(spacing: DesignSystem.Spacing.xxl) {
                                // Recently Highlighted Articles
                                if !dataManager.highlightedArticles.isEmpty {
                                    recentlyHighlightedSection
                                }
                                // Featured Highlights with enhanced carousel
                                if !dataManager.userHighlights.isEmpty {
                                    enhancedCarouselSection(
                                        title: "Featured Highlights",
                                        subtitle: "Top highlights from your network",
                                        items: dataManager.userHighlights,
                                        icon: "sparkle"
                                    ) { highlight in
                                        ModernHighlightCard(highlight: highlight)
                                            .environmentObject(appState)
                                    }
                                } else {
                                    // Loading state with skeleton UI
                                    carouselLoadingState(title: "Featured Highlights")
                                }
                                // Active Discussions
                                if !dataManager.discussions.isEmpty {
                                    enhancedDiscussionsSection
                                }
                            }
                            .padding(.top, DesignSystem.Spacing.xl)
                        }
                        .padding(.bottom, DesignSystem.Spacing.huge * 2.5)
                        .background(GeometryReader { geo in
                            Color.clear.preference(
                                key: ScrollOffsetPreferenceKey.self,
                                value: geo.frame(in: .named("scroll")).minY
                            )
                        })
                    }
                    .coordinateSpace(name: "scroll")
                    .onPreferenceChange(ScrollOffsetPreferenceKey.self) { value in
                        scrollOffset = value
                        withAnimation(.easeOut(duration: 0.2)) {
                            headerOpacity = min(1.0, max(0.0, (50.0 + value) / 50.0))
                        }
                    }
                    .refreshable {
                        HapticManager.shared.impact(.medium)
                        withAnimation(.spring(response: 0.5, dampingFraction: 0.6)) {
                            isRefreshing = true
                        }
                        await dataManager.refresh()
                        withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
                            isRefreshing = false
                        }
                    }
                }
            }
            .navigationBarHidden(true)
        }
        .onAppear {
            dataManager.appState = appState
            withAnimation(.easeInOut(duration: 0.8).delay(0.3)) {
                contentAppeared = true
            }
        }
        .task {
            await dataManager.startStreaming()
        }
        .onChange(of: dataManager.userHighlights) {
            Task {
                await fetchHighlightEngagements()
            }
        }
        .onChange(of: dataManager.discussions) {
            Task {
                await fetchDiscussionEngagements()
            }
        }
    }
    private var headerView: some View {
        HStack {
            Text("Highlighter")
                .font(.system(size: 34, weight: .bold, design: .rounded))
                .foregroundColor(DesignSystem.Colors.text)
            Spacer()
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
    private var timeBasedEmoji: String {
        let hour = Calendar.current.component(.hour, from: Date())
        switch hour {
        case 5..<12: return "☀️"
        case 12..<17: return "🌤"
        case 17..<21: return "🌅"
        default: return "🌙"
        }
    }
    private func enhancedCarouselSection<Item: Identifiable, Content: View>(
        title: String,
        subtitle: String? = nil,
        items: [Item],
        icon: String? = nil,
        @ViewBuilder content: @escaping (Item) -> Content
    ) -> some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.large) {
            VStack(alignment: .leading, spacing: DesignSystem.Spacing.mini) {
                HStack(spacing: DesignSystem.Spacing.small) {
                    if let icon = icon {
                        Image(systemName: icon)
                            .font(.system(size: 20, weight: .semibold))
                            .foregroundColor(DesignSystem.Colors.primary)
                    }
                    Text(title)
                        .font(.system(size: 24, weight: .bold, design: .rounded))
                        .foregroundColor(DesignSystem.Colors.text)
                }
                if let subtitle = subtitle {
                    Text(subtitle)
                        .font(.ds.footnote)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                }
            }
            .padding(.horizontal, DesignSystem.Spacing.large)
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: DesignSystem.Spacing.large) {
                    ForEach(items) { item in
                        content(item)
                            .frame(width: 300)
                            .transition(.asymmetric(
                                insertion: .scale.combined(with: .opacity),
                                removal: .scale.combined(with: .opacity)
                            ))
                    }
                }
                .padding(.horizontal, DesignSystem.Spacing.large)
                .padding(.vertical, DesignSystem.Spacing.micro) // For shadows
            }
        }
    }
    private func carouselLoadingState(title: String) -> some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.large) {
            Text(title)
                .font(.system(size: 24, weight: .bold, design: .rounded))
                .foregroundColor(DesignSystem.Colors.text)
                .padding(.horizontal, DesignSystem.Spacing.large)
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: DesignSystem.Spacing.large) {
                    ForEach(0..<3, id: \.self) { index in
                        SkeletonHighlightCard()
                            .frame(width: 300, height: 200)
                            .transition(.asymmetric(
                                insertion: .scale(scale: 0.8).combined(with: .opacity),
                                removal: .scale(scale: 1.2).combined(with: .opacity)
                            ))
                            .animation(
                                .spring(response: 0.5, dampingFraction: 0.7)
                                .delay(Double(index) * 0.1),
                                value: dataManager.userHighlights.isEmpty
                            )
                    }
                }
                .padding(.horizontal, DesignSystem.Spacing.large)
            }
        }
    }
    private var recentlyHighlightedSection: some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.large) {
            VStack(alignment: .leading, spacing: DesignSystem.Spacing.mini) {
                Text("Recently Highlighted")
                    .font(.system(size: 28, weight: .bold, design: .rounded))
                    .foregroundColor(DesignSystem.Colors.text)
                Text("Articles you might enjoy")
                    .font(.ds.body)
                    .foregroundColor(DesignSystem.Colors.textSecondary)
            }
            .padding(.horizontal, DesignSystem.Spacing.large)
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: DesignSystem.Spacing.medium) {
                    ForEach(dataManager.highlightedArticles.prefix(5), id: \.article.id) { highlightedArticle in
                        NavigationLink(destination: ArticleView(article: highlightedArticle.article)) {
                            RecentlyHighlightedArticleCard(highlightedArticle: highlightedArticle)
                                .frame(width: 280)
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                }
                .padding(.horizontal, DesignSystem.Spacing.large)
                .padding(.vertical, 4)
            }
        }
    }
    private var enhancedDiscussionsSection: some View {
        VStack(alignment: .leading, spacing: DesignSystem.Spacing.large) {
            HStack {
                VStack(alignment: .leading, spacing: DesignSystem.Spacing.mini) {
                    HStack(spacing: DesignSystem.Spacing.small) {
                        Image(systemName: "bubble.left.and.bubble.right.fill")
                            .font(.system(size: 20, weight: .semibold))
                            .foregroundColor(DesignSystem.Colors.primary)
                        Text("Active Discussions")
                            .font(.system(size: 24, weight: .bold, design: .rounded))
                            .foregroundColor(DesignSystem.Colors.text)
                    }
                    Text("\(dataManager.discussions.count) conversations happening now")
                        .font(.ds.footnote)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                }
                Spacer()
            }
            .padding(.horizontal, DesignSystem.Spacing.large)
            VStack(spacing: 0) {
                ForEach(dataManager.discussions.prefix(5), id: \.id) { event in
                    EnhancedDiscussionRow(
                        event: event,
                        engagement: discussionEngagements[event.id] ?? EngagementService.EngagementMetrics()
                    )
                    if event.id != dataManager.discussions.prefix(5).last?.id {
                        Divider()
                            .background(DesignSystem.Colors.divider)
                            .padding(.leading, DesignSystem.Spacing.huge + DesignSystem.Spacing.large)
                    }
                }
            }
            .background(
                RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.xl, style: .continuous)
                    .fill(DesignSystem.Colors.surfaceSecondary)
                    .shadow(color: DesignSystem.Shadow.medium.color, radius: DesignSystem.Shadow.medium.radius, x: DesignSystem.Shadow.medium.x, y: DesignSystem.Shadow.medium.y)
            )
            .padding(.horizontal, DesignSystem.Spacing.large)
        }
    }
}
// MARK: - Enhanced Cards
// Now using UnifiedCard system - see UnifiedCard.swift for ModernHighlightCard implementation
struct EnhancedDiscussionRow: View {
    let event: NDKEvent
    let engagement: EngagementService.EngagementMetrics
    @State private var author: NDKUserProfile?
    var body: some View {
        HStack(alignment: .top, spacing: 12) {
            // Avatar
            EnhancedAsyncProfileImage(pubkey: event.pubkey, size: 44)
            VStack(alignment: .leading, spacing: DesignSystem.Spacing.mini) {
                HStack {
                    Text(author?.displayName ?? PubkeyFormatter.formatCompact(event.pubkey))
                        .font(.system(size: 15, weight: .semibold))
                        .foregroundColor(DesignSystem.Colors.text)
                    Text("·")
                        .foregroundColor(DesignSystem.Colors.textTertiary)
                    Text(RelativeTimeFormatter.shortRelativeTime(from: event.createdAt))
                        .font(.ds.caption)
                        .foregroundColor(DesignSystem.Colors.textTertiary)
                    Spacer()
                    if Bool.random() {
                        Image(systemName: "checkmark.seal.fill")
                            .font(.system(size: 14))
                            .foregroundColor(DesignSystem.Colors.primary)
                    }
                }
                Text(event.content)
                    .font(.system(size: 14))
                    .foregroundColor(DesignSystem.Colors.text)
                    .lineLimit(2)
                    .fixedSize(horizontal: false, vertical: true)
                // Engagement row with real metrics
                HStack(spacing: DesignSystem.Spacing.large) {
                    EngagementButton(icon: "bubble.right", count: engagement.comments)
                    EngagementButton(icon: "arrow.2.squarepath", count: engagement.reposts)
                    EngagementButton(icon: "heart", count: engagement.likes)
                    EngagementButton(icon: "bolt.fill", count: engagement.zaps, color: DesignSystem.Colors.secondary)
                }
                .padding(.top, 4)
            }
            Spacer(minLength: 0)
        }
        .padding(.horizontal, DesignSystem.Spacing.medium)
        .padding(.vertical, DesignSystem.Spacing.base)
    }
}
// MARK: - Supporting Components
struct RecentlyHighlightedArticleCard: View {
    let highlightedArticle: HomeDataManager.HighlightedArticle
    @State private var isPressed = false
    var body: some View {
        VStack(spacing: 0) {
            // Article thumbnail/gradient
            ZStack(alignment: .bottom) {
                // Background image or gradient
                if let imageUrl = highlightedArticle.article.image {
                    AsyncImage(url: URL(string: imageUrl)) { phase in
                        switch phase {
                        case .success(let image):
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                .frame(height: 180)
                                .clipped()
                        case .empty, .failure:
                            LinearGradient(
                                colors: [
                                    DesignSystem.Colors.primary.opacity(0.8),
                                    DesignSystem.Colors.primary.opacity(0.4)
                                ],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                            .frame(height: 180)
                        @unknown default:
                            EmptyView()
                        }
                    }
                } else {
                    LinearGradient(
                        colors: [
                            DesignSystem.Colors.primary.opacity(0.8),
                            DesignSystem.Colors.primary.opacity(0.4)
                        ],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                    .frame(height: 180)
                }
                // Overlay gradient for readability
                LinearGradient(
                    colors: [
                        Color.clear,
                        Color.black.opacity(0.7)
                    ],
                    startPoint: .center,
                    endPoint: .bottom
                )
                // Article title
                VStack(alignment: .leading, spacing: DesignSystem.Spacing.small) {
                    Text(highlightedArticle.article.title)
                        .font(.system(size: 18, weight: .bold, design: .rounded))
                        .foregroundColor(.white)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)
                    if let summary = highlightedArticle.article.summary {
                        Text(summary)
                            .font(.system(size: 14))
                            .foregroundColor(.white.opacity(0.8))
                            .lineLimit(2)
                            .multilineTextAlignment(.leading)
                    }
                }
                .padding(DesignSystem.Spacing.medium)
                .frame(maxWidth: .infinity, alignment: .leading)
            }
            .frame(height: 180)
            // Bottom metadata
            VStack(alignment: .leading, spacing: DesignSystem.Spacing.base) {
                // Author and time
                HStack(spacing: DesignSystem.Spacing.small) {
                    EnhancedAsyncProfileImage(pubkey: highlightedArticle.article.author, size: 24)
                    Text(PubkeyFormatter.formatCompact(highlightedArticle.article.author))
                        .font(.ds.caption)
                        .fontWeight(.medium)
                        .foregroundColor(DesignSystem.Colors.text)
                    Spacer()
                    Text(highlightedArticle.article.estimatedReadingTime > 0 ? "\(highlightedArticle.article.estimatedReadingTime) min read" : "Quick read")
                        .font(.ds.caption)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                }
                // Highlight count and sample
                VStack(alignment: .leading, spacing: DesignSystem.Spacing.mini) {
                    HStack(spacing: DesignSystem.Spacing.mini) {
                        Image(systemName: "highlighter")
                            .font(.system(size: 12))
                            .foregroundColor(DesignSystem.Colors.secondary)
                        Text("\(highlightedArticle.highlights.count) highlight\(highlightedArticle.highlights.count == 1 ? "" : "s")")
                            .font(.system(size: 12, weight: .medium))
                            .foregroundColor(DesignSystem.Colors.secondary)
                        Text("·")
                            .foregroundColor(DesignSystem.Colors.textTertiary)
                        Text(RelativeTimeFormatter.shortRelativeTime(from: highlightedArticle.lastHighlightTime))
                            .font(.system(size: 12))
                            .foregroundColor(DesignSystem.Colors.textTertiary)
                    }
                    // Show a preview of the most recent highlight
                    if let latestHighlight = highlightedArticle.highlights.first {
                        Text("\"\(latestHighlight.content.prefix(80))...\"")
                            .font(.system(size: 13, design: .serif))
                            .italic()
                            .foregroundColor(DesignSystem.Colors.textSecondary)
                            .lineLimit(2)
                            .padding(.horizontal, DesignSystem.Spacing.small)
                            .padding(.vertical, DesignSystem.Spacing.mini)
                            .background(
                                RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.small)
                                    .fill(DesignSystem.Colors.highlightSubtle.opacity(0.5))
                            )
                    }
                }
            }
            .padding(DesignSystem.Spacing.medium)
            .background(DesignSystem.Colors.surface)
        }
        .clipShape(RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.xl, style: .continuous))
        .shadow(color: DesignSystem.Shadow.medium.color, radius: DesignSystem.Shadow.medium.radius, x: DesignSystem.Shadow.medium.x, y: DesignSystem.Shadow.medium.y)
        .overlay(
            RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.xl, style: .continuous)
                .strokeBorder(DesignSystem.Colors.divider.opacity(0.5), lineWidth: 0.5)
        )
        .scaleEffect(isPressed ? 0.97 : 1)
        .animation(DesignSystem.Animation.springSnappy, value: isPressed)
        .onLongPressGesture(minimumDuration: 0.1, maximumDistance: .infinity, pressing: { pressing in
            isPressed = pressing
            if pressing {
                HapticManager.shared.impact(.light)
            }
        }, perform: {})
    }
}
struct ActivityRing: View {
    @State private var progress: CGFloat = 0.75
    @State private var rotation: Double = 0
    var body: some View {
        ZStack {
            Circle()
                .stroke(DesignSystem.Colors.surfaceSecondary, lineWidth: 4)
            Circle()
                .trim(from: 0, to: progress)
                .stroke(
                    LinearGradient(
                        colors: [.ds.primary, .ds.primary.opacity(0.6)],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    ),
                    style: StrokeStyle(lineWidth: 4, lineCap: .round)
                )
                .rotationEffect(.degrees(-90))
                .rotationEffect(.degrees(rotation))
                .animation(.linear(duration: 20).repeatForever(autoreverses: false), value: rotation)
            VStack(spacing: 0) {
                Text("\(Int(progress * 100))")
                    .font(.system(size: 16, weight: .bold, design: .rounded))
                    .foregroundColor(DesignSystem.Colors.primary)
                Text("%")
                    .font(.system(size: 10, weight: .medium))
                    .foregroundColor(DesignSystem.Colors.textSecondary)
            }
        }
        .onAppear {
            rotation = 360
        }
    }
}
struct InteractionButton: View {
    let icon: String
    let count: Int
    var color: Color = .ds.textSecondary
    var body: some View {
        HStack(spacing: DesignSystem.Spacing.micro) {
            Image(systemName: icon)
                .font(.system(size: 14))
            if count > 0 {
                Text(formatCount(count))
                    .font(.system(size: 12, weight: .medium))
            }
        }
        .foregroundColor(color)
    }
    private func formatCount(_ count: Int) -> String {
        if count >= 1000 {
            return "\(count / 1000)k"
        }
        return "\(count)"
    }
}
struct EngagementButton: View {
    let icon: String
    let count: Int
    var color: Color = .ds.textSecondary
    var body: some View {
        HStack(spacing: DesignSystem.Spacing.micro) {
            Image(systemName: icon)
                .font(.system(size: 12))
            if count > 0 {
                Text("\(count)")
                    .font(.system(size: 11, weight: .medium))
            }
        }
        .foregroundColor(color)
    }
}
struct MetricPill: View {
    let icon: String
    let value: String
    var body: some View {
        HStack(spacing: DesignSystem.Spacing.micro) {
            Image(systemName: icon)
                .font(.system(size: 12))
            Text(value)
                .font(.system(size: 12, weight: .medium))
        }
        .foregroundColor(DesignSystem.Colors.textSecondary)
        .padding(.horizontal, 8)
        .padding(.vertical, 4)
        .background(
            Capsule()
                .fill(DesignSystem.Colors.surfaceSecondary)
        )
    }
}
// MARK: - Custom Components
struct FloatingAmbientView: View {
    @State private var particles: [FloatingParticle] = []
    var body: some View {
        GeometryReader { geometry in
            ForEach(particles) { particle in
                Circle()
                    .fill(
                        RadialGradient(
                            colors: [
                                DesignSystem.Colors.primary.opacity(particle.opacity),
                                DesignSystem.Colors.primary.opacity(0)
                            ],
                            center: .center,
                            startRadius: 0,
                            endRadius: particle.size / 2
                        )
                    )
                    .frame(width: particle.size, height: particle.size)
                    .position(x: particle.x, y: particle.y)
                    .blur(radius: particle.blur)
                    .animation(
                        .linear(duration: particle.duration).repeatForever(autoreverses: false),
                        value: particle.y
                    )
            }
        }
        .onAppear {
            generateParticles()
        }
    }
    private func generateParticles() {
        particles = (0..<8).map { _ in
            FloatingParticle(
                size: CGFloat.random(in: 40...120),
                opacity: Double.random(in: 0.05...0.15),
                blur: CGFloat.random(in: 5...15),
                duration: Double.random(in: 20...40)
            )
        }
    }
}
struct FloatingParticle: Identifiable {
    let id = UUID()
    let size: CGFloat
    let opacity: Double
    let blur: CGFloat
    let duration: Double
    var x: CGFloat = CGFloat.random(in: 0...UIScreen.main.bounds.width)
    var y: CGFloat = CGFloat.random(in: 0...UIScreen.main.bounds.height)
}
struct RefreshIndicatorView: View {
    let progress: CGFloat
    let isRefreshing: Bool
    @State private var rotation: Double = 0
    var body: some View {
        ZStack {
            // Background circle
            Circle()
                .stroke(DesignSystem.Colors.primary.opacity(0.2), lineWidth: 3)
                .frame(width: 40, height: 40)
            // Progress circle
            Circle()
                .trim(from: 0, to: isRefreshing ? 0.8 : progress)
                .stroke(
                    LinearGradient(
                        colors: [DesignSystem.Colors.primary, DesignSystem.Colors.secondary],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    ),
                    style: StrokeStyle(lineWidth: 3, lineCap: .round)
                )
                .frame(width: 40, height: 40)
                .rotationEffect(.degrees(rotation))
                .animation(isRefreshing ? .linear(duration: 1).repeatForever(autoreverses: false) : .spring(), value: rotation)
            // Center icon
            Image(systemName: "arrow.clockwise")
                .font(.system(size: 16, weight: .semibold))
                .foregroundColor(DesignSystem.Colors.primary)
                .rotationEffect(.degrees(isRefreshing ? rotation : 0))
                .scaleEffect(isRefreshing ? 1.1 : 1.0)
                .animation(.spring(response: 0.5, dampingFraction: 0.6), value: isRefreshing)
        }
        .scaleEffect(0.8 + (progress * 0.2))
        .opacity(progress > 0.1 ? 1 : 0)
        .onChange(of: isRefreshing) { _, newValue in
            if newValue {
                rotation = 360
            } else {
                rotation = 0
            }
        }
    }
}
struct SkeletonHighlightCard: View {
    @State private var shimmerOffset: CGFloat = -200
    @State private var pulseOpacity: Double = 0.5
    var body: some View {
        ZStack {
            // Elegant base with subtle gradient
            RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.xl, style: .continuous)
                .fill(
                    LinearGradient(
                        colors: [
                            DesignSystem.Colors.surfaceSecondary,
                            DesignSystem.Colors.surfaceSecondary.opacity(0.95)
                        ],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .overlay(
                    RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.xl, style: .continuous)
                        .strokeBorder(
                            DesignSystem.Colors.divider.opacity(0.1),
                            lineWidth: 1
                        )
                )
            VStack(alignment: .leading, spacing: DesignSystem.Spacing.medium) {
                // Elegant header placeholder with varied widths
                HStack(spacing: DesignSystem.Spacing.small) {
                    Circle()
                        .fill(DesignSystem.Colors.textTertiary.opacity(0.12))
                        .frame(width: 32, height: 32)
                    VStack(alignment: .leading, spacing: 4) {
                        Capsule()
                            .fill(DesignSystem.Colors.textTertiary.opacity(0.15))
                            .frame(width: 100, height: 12)
                        Capsule()
                            .fill(DesignSystem.Colors.textTertiary.opacity(0.1))
                            .frame(width: 60, height: 10)
                    }
                    Spacer()
                }
                // Content placeholder with natural text flow
                VStack(alignment: .leading, spacing: DesignSystem.Spacing.small) {
                    ForEach(0..<3) { index in
                        Capsule()
                            .fill(DesignSystem.Colors.textTertiary.opacity(0.12 - Double(index) * 0.02))
                            .frame(height: 14)
                            .frame(maxWidth: index == 2 ? 180 : .infinity)
                    }
                }
                .padding(.vertical, DesignSystem.Spacing.small)
                Spacer()
                // Elegant footer with interaction hints
                HStack {
                    HStack(spacing: 4) {
                        RoundedRectangle(cornerRadius: 4)
                            .fill(DesignSystem.Colors.textTertiary.opacity(0.1))
                            .frame(width: 16, height: 16)
                        Capsule()
                            .fill(DesignSystem.Colors.textTertiary.opacity(0.08))
                            .frame(width: 40, height: 12)
                    }
                    Spacer()
                    HStack(spacing: DesignSystem.Spacing.small) {
                        ForEach(0..<3, id: \.self) { index in
                            RoundedRectangle(cornerRadius: 6)
                                .fill(DesignSystem.Colors.textTertiary.opacity(0.1 - Double(index) * 0.02))
                                .frame(width: 24, height: 24)
                        }
                    }
                }
            }
            .padding(DesignSystem.Spacing.xl)
            // Subtle, elegant shimmer effect
            LinearGradient(
                colors: [
                    Color.clear,
                    DesignSystem.Colors.primary.opacity(0.05),
                    DesignSystem.Colors.secondary.opacity(0.05),
                    Color.clear
                ],
                startPoint: .leading,
                endPoint: .trailing
            )
            .frame(width: 150)
            .offset(x: shimmerOffset)
            .blur(radius: 8)
            .mask(
                RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.xl, style: .continuous)
            )
        }
        .opacity(pulseOpacity)
        .onAppear {
            // Elegant shimmer animation
            withAnimation(
                .easeInOut(duration: 2.5)
                .repeatForever(autoreverses: false)
            ) {
                shimmerOffset = 400
            }
            // Subtle pulse for organic feel
            withAnimation(
                .easeInOut(duration: 2)
                .repeatForever(autoreverses: true)
            ) {
                pulseOpacity = 0.8
            }
        }
    }
}
struct ShimmeringOverlay: View {
    @State private var shimmerPosition: CGFloat = -1
    var body: some View {
        GeometryReader { geometry in
            LinearGradient(
                colors: [
                    Color.clear,
                    Color.white.opacity(0.3),
                    Color.clear
                ],
                startPoint: .leading,
                endPoint: .trailing
            )
            .frame(width: geometry.size.width * 0.3)
            .offset(x: geometry.size.width * shimmerPosition)
            .onAppear {
                withAnimation(
                    .linear(duration: 2)
                    .repeatForever(autoreverses: false)
                ) {
                    shimmerPosition = 2
                }
            }
        }
        .mask(Rectangle())
    }
}
// EnhancedAsyncProfileImage is now in its own file
#Preview {
    SimplifiedHybridFeedView()
        .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Views/Import/SmartArticleImportView.swift">
import SwiftUI
import UniformTypeIdentifiers
import NDKSwift
struct SmartArticleImportView: View {
    @EnvironmentObject var appState: AppState
    @StateObject private var importManager = SmartImportManager()
    @State private var isDragging = false
    @State private var urlText = ""
    @State private var showURLError = false
    @State private var dragOffset: CGSize = .zero
    @State private var dragScale: CGFloat = 1.0
    @State private var glowIntensity: Double = 0
    @State private var particlePositions: [ImportParticle] = []
    @State private var processingProgress: Double = 0
    @State private var showSuccessAnimation = false
    @State private var selectedSuggestions: Set<String> = []
    @State private var magneticPull: CGFloat = 0
    @State private var rotationAngle: Double = 0
    @State private var floatingOffset: CGFloat = 0
    @State private var aiThinkingAnimation = false
    @State private var brainWaveAnimation: CGFloat = 0
    @State private var neuralNetworkPaths: [NeuralPath] = []
    @State private var showAdvancedOptions = false
    @State private var importQuality: ImportQuality = .balanced
    @State private var contentComplexityScore: Double = 0
    @State private var readingTimeEstimate: Int = 0
    @Environment(\.dismiss) var dismiss
    @Namespace private var animation
    enum ImportQuality: String, CaseIterable {
        case quick = "Quick"
        case balanced = "Balanced"
        case thorough = "Thorough"
        var icon: String {
            switch self {
            case .quick: return "hare"
            case .balanced: return "dial.medium"
            case .thorough: return "tortoise"
            }
        }
        var color: Color {
            switch self {
            case .quick: return .green
            case .balanced: return .orange
            case .thorough: return .purple
            }
        }
        var description: String {
            switch self {
            case .quick: return "Fast processing, basic suggestions"
            case .balanced: return "Optimal speed and quality"
            case .thorough: return "Deep analysis, best suggestions"
            }
        }
    }
    var body: some View {
        NavigationStack {
            ZStack {
                // Animated gradient background
                AnimatedGradientBackground()
                // Neural network visualization
                NeuralNetworkVisualization(
                    paths: neuralNetworkPaths,
                    isActive: importManager.isProcessing
                )
                .opacity(0.3)
                .blur(radius: 2)
                // Floating particles
                ForEach(particlePositions) { particle in
                    ImportParticleView(particle: particle)
                }
                ScrollView {
                    VStack(spacing: .ds.sectionSpacing) {
                        // Hero section with animated brain
                        heroSection
                            .padding(.top, .ds.large)
                        // Main import area
                        if !importManager.isProcessing && importManager.processedArticle == nil {
                            importSection
                                .transition(.asymmetric(
                                    insertion: .scale(scale: 0.8).combined(with: .opacity),
                                    removal: .scale(scale: 1.1).combined(with: .opacity)
                                ))
                        }
                        // Processing animation
                        if importManager.isProcessing {
                            processingSection
                                .transition(.scale.combined(with: .opacity))
                        }
                        // Results section
                        if let article = importManager.processedArticle {
                            resultsSection(article: article)
                                .transition(.push(from: .bottom).combined(with: .opacity))
                        }
                    }
                    .padding(.horizontal, .ds.screenPadding)
                    .padding(.bottom, 100)
                }
            }
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        HapticManager.shared.impact(.light)
                        dismiss()
                    }
                    .font(.ds.body)
                    .foregroundColor(.ds.textSecondary)
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    if importManager.processedArticle != nil {
                        Button("Import") {
                            performImport()
                        }
                        .font(.ds.bodyMedium)
                        .foregroundColor(.ds.primary)
                        .disabled(selectedSuggestions.isEmpty)
                    }
                }
            }
        }
        .onAppear {
            startAnimations()
            generateNeuralPaths()
        }
        .alert("Invalid URL", isPresented: $showURLError) {
            Button("OK", role: .cancel) {}
        } message: {
            Text("Please enter a valid URL starting with http:// or https://")
        }
    }
    // MARK: - Hero Section
    @ViewBuilder
    private var heroSection: some View {
        VStack(spacing: .ds.medium) {
            // Animated AI brain icon
            ZStack {
                // Outer glow
                Circle()
                    .fill(
                        RadialGradient(
                            colors: [
                                Color.purple.opacity(0.3),
                                Color.purple.opacity(0.1),
                                Color.clear
                            ],
                            center: .center,
                            startRadius: 0,
                            endRadius: 60
                        )
                    )
                    .frame(width: 120, height: 120)
                    .scaleEffect(1 + brainWaveAnimation * 0.2)
                    .blur(radius: 10)
                // Brain icon with neural connections
                Image(systemName: "brain")
                    .font(.system(size: 56, weight: .light))
                    .foregroundStyle(
                        LinearGradient(
                            colors: [.purple, .orange],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .symbolEffect(.pulse, options: .repeating, value: aiThinkingAnimation)
                    .scaleEffect(1 + floatingOffset / 100)
                    .rotationEffect(.degrees(Foundation.sin(brainWaveAnimation * .pi) * 5))
                // Neural sparkles
                ForEach(0..<6) { index in
                    Circle()
                        .fill(Color.orange)
                        .frame(width: 4, height: 4)
                        .offset(x: 35)
                        .rotationEffect(.degrees(Double(index) * 60 + rotationAngle))
                        .opacity(importManager.isProcessing ? 1 : 0.3)
                        .scaleEffect(importManager.isProcessing ? 1.2 : 1)
                }
            }
            .offset(y: floatingOffset)
            VStack(spacing: .ds.small) {
                Text("Smart Article Import")
                    .font(.ds.largeTitle)
                    .foregroundColor(.ds.text)
                Text("AI-powered highlight suggestions")
                    .font(.ds.body)
                    .foregroundColor(.ds.textSecondary)
            }
        }
    }
    // MARK: - Import Section
    @ViewBuilder
    private var importSection: some View {
        VStack(spacing: .ds.large) {
            // Quality selector
            qualitySelector
                .premiumEntrance(delay: 0.1)
            // Drop zone
            dropZone
                .premiumEntrance(delay: 0.2)
            // URL input
            urlInput
                .premiumEntrance(delay: 0.3)
            // Advanced options
            if showAdvancedOptions {
                advancedOptionsSection
                    .transition(.asymmetric(
                        insertion: .push(from: .top).combined(with: .opacity),
                        removal: .push(from: .bottom).combined(with: .opacity)
                    ))
            }
        }
    }
    @ViewBuilder
    private var qualitySelector: some View {
        VStack(spacing: .ds.base) {
            Text("Processing Quality")
                .font(.ds.footnoteMedium)
                .foregroundColor(.ds.textSecondary)
            HStack(spacing: .ds.base) {
                ForEach(ImportQuality.allCases, id: \.self) { quality in
                    QualityOptionCard(
                        quality: quality,
                        isSelected: importQuality == quality,
                        action: {
                            selectQuality(quality)
                        }
                    )
                }
            }
        }
    }
    @ViewBuilder
    private var dropZone: some View {
        ZStack {
            // Background with animated gradient
            RoundedRectangle(cornerRadius: .ds.large, style: .continuous)
                .fill(
                    LinearGradient(
                        colors: [
                            isDragging ? Color.purple.opacity(0.1) : Color.ds.surfaceSecondary,
                            isDragging ? Color.orange.opacity(0.1) : Color.ds.surfaceSecondary
                        ],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .overlay(
                    RoundedRectangle(cornerRadius: .ds.large, style: .continuous)
                        .strokeBorder(
                            style: StrokeStyle(
                                lineWidth: 2,
                                dash: isDragging ? [10, 5] : [15, 10]
                            )
                        )
                        .foregroundColor(
                            isDragging ? .ds.primary : .ds.textTertiary.opacity(0.5)
                        )
                        .animation(.easeInOut(duration: 0.3), value: isDragging)
                )
            // Magnetic effect overlay
            if isDragging {
                RadialGradient(
                    colors: [
                        Color.purple.opacity(0.2 * magneticPull),
                        Color.clear
                    ],
                    center: .center,
                    startRadius: 0,
                    endRadius: 150
                )
                .clipShape(RoundedRectangle(cornerRadius: .ds.large, style: .continuous))
                .blur(radius: 20)
            }
            // Content
            VStack(spacing: .ds.medium) {
                Image(systemName: "doc.text.magnifyingglass")
                    .font(.system(size: 48, weight: .light))
                    .foregroundStyle(
                        LinearGradient(
                            colors: isDragging ? [.purple, .orange] : [.ds.textTertiary],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                    .scaleEffect(dragScale)
                    .offset(dragOffset)
                    .symbolEffect(.bounce, value: isDragging)
                VStack(spacing: .ds.small) {
                    Text("Drop Article Here")
                        .font(.ds.headline)
                        .foregroundColor(isDragging ? .ds.primary : .ds.text)
                    Text("PDF, TXT, MD, or any text file")
                        .font(.ds.footnote)
                        .foregroundColor(.ds.textSecondary)
                }
                .opacity(isDragging ? 0.5 : 1)
            }
            .padding(.vertical, 60)
            .frame(maxWidth: .infinity)
        }
        .frame(height: 200)
        .scaleEffect(1 + magneticPull * 0.05)
        .rotation3DEffect(
            .degrees(isDragging ? 5 : 0),
            axis: (x: 0, y: 1, z: 0),
            perspective: 1
        )
        .onDrop(of: [.text, .pdf, .plainText], isTargeted: $isDragging) { providers in
            handleDrop(providers)
            return true
        }
    }
    @ViewBuilder
    private var urlInput: some View {
        VStack(alignment: .leading, spacing: .ds.small) {
            Text("Or paste a URL")
                .font(.ds.footnoteMedium)
                .foregroundColor(.ds.textSecondary)
            HStack(spacing: .ds.base) {
                HStack {
                    Image(systemName: "link")
                        .font(.system(size: 16))
                        .foregroundColor(.ds.textTertiary)
                    TextField("https://stratechery.com/2024/article-title", text: $urlText)
                        .font(.ds.body)
                        .foregroundColor(.ds.text)
                        .textFieldStyle(.plain)
                        .submitLabel(.go)
                        .onSubmit {
                            importFromURL()
                        }
                }
                .padding(.horizontal, .ds.base)
                .padding(.vertical, .ds.small)
                .background(DesignSystem.Colors.surfaceSecondary)
                .clipShape(RoundedRectangle(cornerRadius: .ds.medium, style: .continuous))
                Button(action: importFromURL) {
                    Image(systemName: "arrow.right.circle.fill")
                        .font(.system(size: 24))
                        .foregroundStyle(
                            urlText.isEmpty ? AnyShapeStyle(Color.ds.textTertiary) :
                                AnyShapeStyle(LinearGradient(
                                    colors: [.purple, .orange],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                ))
                        )
                }
                .disabled(urlText.isEmpty)
                .magneticHover()
            }
        }
    }
    @ViewBuilder
    private var advancedOptionsSection: some View {
        VStack(alignment: .leading, spacing: .ds.medium) {
            Toggle(isOn: $importManager.includeImages) {
                Label("Extract Images", systemImage: "photo")
                    .font(.ds.callout)
            }
            .tint(.ds.primary)
            Toggle(isOn: $importManager.preserveFormatting) {
                Label("Preserve Formatting", systemImage: "textformat")
                    .font(.ds.callout)
            }
            .tint(.ds.primary)
            Toggle(isOn: $importManager.detectQuotes) {
                Label("Auto-detect Quotes", systemImage: "quote.bubble")
                    .font(.ds.callout)
            }
            .tint(.ds.primary)
        }
        .padding(.ds.medium)
        .background(DesignSystem.Colors.surfaceSecondary)
        .clipShape(RoundedRectangle(cornerRadius: .ds.medium, style: .continuous))
    }
    // MARK: - Processing Section
    @ViewBuilder
    private var processingSection: some View {
        VStack(spacing: .ds.large) {
            // AI thinking animation
            AIThinkingAnimation(progress: processingProgress)
            VStack(spacing: .ds.base) {
                Text("Analyzing Content")
                    .font(.ds.title2)
                    .foregroundColor(.ds.text)
                Text(importManager.processingStatus)
                    .font(.ds.body)
                    .foregroundColor(.ds.textSecondary)
                    .multilineTextAlignment(.center)
            }
            // Progress bar with glow effect
            GeometryReader { geometry in
                ZStack(alignment: .leading) {
                    // Background
                    Capsule()
                        .fill(DesignSystem.Colors.surfaceSecondary)
                        .frame(height: 8)
                    // Progress
                    Capsule()
                        .fill(
                            LinearGradient(
                                colors: [.purple, .orange],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .frame(width: geometry.size.width * processingProgress, height: 8)
                    // Glow
                    Capsule()
                        .fill(
                            LinearGradient(
                                colors: [.purple.opacity(0.6), .orange.opacity(0.6)],
                                startPoint: .leading,
                                endPoint: .trailing
                            )
                        )
                        .frame(width: geometry.size.width * processingProgress, height: 8)
                        .blur(radius: 8)
                }
            }
            .frame(height: 8)
            .padding(.horizontal, .ds.large)
        }
        .padding(.vertical, 60)
        .onAppear {
            simulateProcessing()
        }
    }
    // MARK: - Results Section
    @ViewBuilder
    private func resultsSection(article: ProcessedArticle) -> some View {
        GeometryReader { geometry in
            HStack(spacing: 0) {
                // Left side - Article preview with live highlights
                ScrollView {
                    VStack(alignment: .leading, spacing: .ds.large) {
                        // Article header
                        VStack(alignment: .leading, spacing: .ds.small) {
                            Text(article.title)
                                .font(.ds.largeTitle)
                                .foregroundColor(.ds.text)
                            if let author = article.author {
                                Text("by \(author)")
                                    .font(.ds.body)
                                    .foregroundColor(.ds.textSecondary)
                            }
                        }
                        .padding(.horizontal, .ds.screenPadding)
                        .padding(.top, .ds.large)
                        // Live preview with highlights
                        LiveArticlePreview(
                            article: article,
                            selectedSuggestions: selectedSuggestions,
                            onHighlightTap: { suggestionId in
                                toggleSuggestion(suggestionId)
                            }
                        )
                        .padding(.horizontal, .ds.screenPadding)
                    }
                    .padding(.bottom, 100)
                }
                .frame(width: geometry.size.width * 0.6)
                .background(DesignSystem.Colors.background)
                // Divider
                Rectangle()
                    .fill(DesignSystem.Colors.divider)
                    .frame(width: 1)
                // Right side - AI suggestions panel
                ScrollView {
                    VStack(spacing: .ds.large) {
                        // Article metrics
                        ArticleMetricsCard(
                            article: article,
                            complexityScore: contentComplexityScore,
                            readingTime: readingTimeEstimate,
                            selectedCount: selectedSuggestions.count
                        )
                        .premiumEntrance(delay: 0.1)
                        .padding(.top, .ds.large)
                        // AI suggestions header
                        HStack {
                            Label("AI Analysis", systemImage: "brain")
                                .font(.ds.headline)
                                .foregroundColor(.ds.text)
                            Spacer()
                            // Select all/none buttons
                            HStack(spacing: .ds.small) {
                                Button("All") {
                                    selectAllSuggestions(article)
                                }
                                .font(.ds.footnoteMedium)
                                .foregroundColor(.ds.primary)
                                Text("/")
                                    .font(.ds.footnote)
                                    .foregroundColor(.ds.textTertiary)
                                Button("None") {
                                    selectedSuggestions.removeAll()
                                }
                                .font(.ds.footnoteMedium)
                                .foregroundColor(.ds.primary)
                            }
                        }
                        .premiumEntrance(delay: 0.2)
                        // Suggested highlights with enhanced UI
                        VStack(spacing: .ds.base) {
                            ForEach(Array(article.suggestedHighlights.enumerated()), id: \.element.id) { index, suggestion in
                                EnhancedSuggestionCard(
                                    suggestion: suggestion,
                                    isSelected: selectedSuggestions.contains(suggestion.id),
                                    index: index,
                                    action: {
                                        toggleSuggestion(suggestion.id)
                                    }
                                )
                                .premiumEntrance(delay: 0.3 + Double(index) * 0.05)
                            }
                        }
                    }
                    .padding(.horizontal, .ds.screenPadding)
                    .padding(.bottom, 100)
                }
                .frame(width: geometry.size.width * 0.4)
                .background(DesignSystem.Colors.surfaceSecondary.opacity(0.3))
            }
        }
    }
    // MARK: - Actions
    private func handleDrop(_ providers: [NSItemProvider]) {
        guard let provider = providers.first else { return }
        HapticManager.shared.impact(.medium)
        generateImportParticles()
        // Magnetic effect
        withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {
            magneticPull = 1.0
            dragScale = 0.8
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
            withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                magneticPull = 0
                dragScale = 1.0
            }
            // Process the dropped file
            if provider.hasItemConformingToTypeIdentifier(UTType.pdf.identifier) {
                provider.loadItem(forTypeIdentifier: UTType.pdf.identifier, options: nil) { (url, error) in
                    if let url = url as? URL {
                        DispatchQueue.main.async {
                            importManager.importFromFile(url)
                        }
                    }
                }
            } else if provider.hasItemConformingToTypeIdentifier(UTType.plainText.identifier) {
                provider.loadItem(forTypeIdentifier: UTType.plainText.identifier, options: nil) { (text, error) in
                    if let text = text as? String {
                        DispatchQueue.main.async {
                            importManager.importFromText(text)
                        }
                    }
                }
            }
        }
    }
    private func importFromURL() {
        guard !urlText.isEmpty else { return }
        if urlText.hasPrefix("http://") || urlText.hasPrefix("https://") {
            HapticManager.shared.impact(.medium)
            importManager.importFromURL(urlText)
        } else {
            showURLError = true
            HapticManager.shared.notification(.error)
        }
    }
    private func selectQuality(_ quality: ImportQuality) {
        HapticManager.shared.impact(.light)
        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
            importQuality = quality
            importManager.processingQuality = quality
        }
    }
    private func toggleSuggestion(_ id: String) {
        HapticManager.shared.impact(.light)
        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
            if selectedSuggestions.contains(id) {
                selectedSuggestions.remove(id)
            } else {
                selectedSuggestions.insert(id)
            }
        }
    }
    private func selectAllSuggestions(_ article: ProcessedArticle) {
        HapticManager.shared.impact(.light)
        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
            selectedSuggestions = Set(article.suggestedHighlights.map { $0.id })
        }
    }
    private func performImport() {
        guard let article = importManager.processedArticle else { return }
        HapticManager.shared.notification(.success)
        withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
            showSuccessAnimation = true
        }
        // Create highlights from selected suggestions
        let selectedHighlights = article.suggestedHighlights.filter { selectedSuggestions.contains($0.id) }
        Task {
            do {
                // First, create and publish the article if it doesn't exist
                _ = await createArticleEvent(from: article)
                // Then create highlights for selected suggestions
                for suggestion in selectedHighlights {
                    let highlight = HighlightEvent(
                        content: suggestion.text,
                        context: suggestion.hasContext ? suggestion.text : nil,
                        comment: suggestion.reason
                    )
                    try await PublishingService.shared.publishHighlight(highlight)
                }
                // Dismiss after successful import
                await MainActor.run {
                    dismiss()
                }
            } catch {
                // Show error if publishing fails
                await MainActor.run {
                    // Could show an alert here, but for now just dismiss
                    dismiss()
                }
            }
        }
    }
    private func createArticleEvent(from article: ProcessedArticle) async -> NDKEvent? {
        guard let ndk = appState.ndk,
              let signer = appState.activeSigner else { return nil }
        // Create article event if needed
        var tags: [[String]] = []
        // Add title tag
        tags.append(["title", article.title])
        // Add author tag if available
        if let author = article.author {
            tags.append(["author", author])
        }
        // Add bookstr tag
        tags.append(["t", "bookstr"])
        do {
            let event = try await NDKEventBuilder(ndk: ndk)
                .kind(30023) // Long-form content
                .content(article.preview)
                .tags(tags)
                .build(signer: signer)
            _ = try await ndk.publish(event)
            return event
        } catch {
            return nil
        }
    }
    // MARK: - Animations
    private func startAnimations() {
        // Brain wave animation
        withAnimation(.easeInOut(duration: 3).repeatForever(autoreverses: true)) {
            brainWaveAnimation = 1
        }
        // Floating animation
        withAnimation(.easeInOut(duration: 2).repeatForever(autoreverses: true)) {
            floatingOffset = -10
        }
        // Rotation animation
        withAnimation(.linear(duration: 20).repeatForever(autoreverses: false)) {
            rotationAngle = 360
        }
        // Glow animation
        withAnimation(.easeInOut(duration: 1.5).repeatForever(autoreverses: true)) {
            glowIntensity = 1
        }
        // Generate initial particles
        generateParticles()
    }
    private func generateParticles() {
        for _ in 0..<15 {
            let particle = ImportParticle(
                x: .random(in: -50...UIScreen.main.bounds.width + 50),
                y: .random(in: -50...UIScreen.main.bounds.height + 50),
                size: .random(in: 4...12),
                color: Bool.random() ? .purple : .orange,
                speed: .random(in: 20...60)
            )
            particlePositions.append(particle)
        }
    }
    private func generateImportParticles() {
        for _ in 0..<20 {
            let particle = ImportParticle(
                x: UIScreen.main.bounds.width / 2,
                y: UIScreen.main.bounds.height / 2,
                size: .random(in: 6...16),
                color: .orange,
                speed: .random(in: 40...100)
            )
            particlePositions.append(particle)
        }
    }
    private func generateNeuralPaths() {
        for _ in 0..<8 {
            let path = NeuralPath(
                startX: .random(in: 0...UIScreen.main.bounds.width),
                startY: .random(in: 0...UIScreen.main.bounds.height),
                endX: .random(in: 0...UIScreen.main.bounds.width),
                endY: .random(in: 0...UIScreen.main.bounds.height),
                delay: .random(in: 0...2)
            )
            neuralNetworkPaths.append(path)
        }
    }
    private func simulateProcessing() {
        // Simulate processing stages
        let stages = [
            "Extracting text content...",
            "Analyzing document structure...",
            "Identifying key concepts...",
            "Running AI analysis...",
            "Generating suggestions...",
            "Ranking by importance...",
            "Finalizing recommendations..."
        ]
        for (index, stage) in stages.enumerated() {
            DispatchQueue.main.asyncAfter(deadline: .now() + Double(index) * 0.5) {
                withAnimation(.easeOut(duration: 0.3)) {
                    importManager.processingStatus = stage
                    processingProgress = Double(index + 1) / Double(stages.count)
                }
                if index == stages.count - 1 {
                    // Processing complete
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                        contentComplexityScore = Double.random(in: 0.6...0.9)
                        readingTimeEstimate = Int.random(in: 5...15)
                        // completeProcessing is now handled by the async AI analysis
                    }
                }
            }
        }
    }
}
// MARK: - Supporting Views
struct QualityOptionCard: View {
    let quality: SmartArticleImportView.ImportQuality
    let isSelected: Bool
    let action: () -> Void
    @State private var isPressed = false
    var body: some View {
        Button(action: action) {
            VStack(spacing: .ds.small) {
                ZStack {
                    Circle()
                        .fill(
                            isSelected ?
                                AnyShapeStyle(LinearGradient(
                                    colors: [quality.color, quality.color.opacity(0.7)],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )) :
                                AnyShapeStyle(DesignSystem.Colors.surfaceSecondary)
                        )
                        .frame(width: 56, height: 56)
                        .overlay(
                            Circle()
                                .stroke(
                                    isSelected ? quality.color.opacity(0.3) : Color.clear,
                                    lineWidth: 2
                                )
                        )
                        .shadow(
                            color: isSelected ? quality.color.opacity(0.3) : .clear,
                            radius: 10,
                            x: 0,
                            y: 5
                        )
                    Image(systemName: quality.icon)
                        .font(.system(size: 24, weight: .medium))
                        .foregroundColor(isSelected ? .white : .ds.textSecondary)
                        .symbolEffect(.bounce, value: isSelected)
                }
                .scaleEffect(isPressed ? 0.9 : 1)
                Text(quality.rawValue)
                    .font(.ds.footnoteMedium)
                    .foregroundColor(isSelected ? quality.color : .ds.text)
            }
            .frame(maxWidth: .infinity)
        }
        .buttonStyle(PlainButtonStyle())
        .onTapGesture {
            isPressed = true
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                isPressed = false
            }
            action()
        }
    }
}
struct ArticleInfoCard: View {
    let article: ProcessedArticle
    let complexityScore: Double
    let readingTime: Int
    @State private var showDetails = false
    var body: some View {
        VStack(alignment: .leading, spacing: .ds.medium) {
            // Title and source
            VStack(alignment: .leading, spacing: .ds.small) {
                Text(article.title)
                    .font(.ds.title3)
                    .foregroundColor(.ds.text)
                    .lineLimit(2)
                if let author = article.author {
                    Text("by \(author)")
                        .font(.ds.footnote)
                        .foregroundColor(.ds.textSecondary)
                }
            }
            // Metrics
            HStack(spacing: .ds.large) {
                MetricBadge(
                    icon: "clock",
                    value: "\(readingTime) min",
                    color: .blue
                )
                MetricBadge(
                    icon: "brain",
                    value: "Score \(Int(complexityScore * 100))",
                    color: .purple
                )
                MetricBadge(
                    icon: "highlighter",
                    value: "\(article.suggestedHighlights.count) found",
                    color: .orange
                )
            }
            // Preview
            if showDetails {
                Text(article.preview)
                    .font(.ds.callout)
                    .foregroundColor(.ds.textSecondary)
                    .lineLimit(4)
                    .transition(.move(edge: .top).combined(with: .opacity))
            }
            // Expand button
            Button(action: {
                withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                    showDetails.toggle()
                }
                HapticManager.shared.impact(.light)
            }) {
                HStack {
                    Text(showDetails ? "Show Less" : "Show Preview")
                        .font(.ds.footnoteMedium)
                        .foregroundColor(.ds.primary)
                    Image(systemName: "chevron.down")
                        .font(.system(size: 12, weight: .medium))
                        .foregroundColor(.ds.primary)
                        .rotationEffect(.degrees(showDetails ? 180 : 0))
                }
            }
        }
        .padding(.ds.medium)
        .background(
            RoundedRectangle(cornerRadius: .ds.large, style: .continuous)
                .fill(DesignSystem.Colors.surfaceSecondary)
                .overlay(
                    RoundedRectangle(cornerRadius: .ds.large, style: .continuous)
                        .stroke(
                            LinearGradient(
                                colors: [
                                    Color.purple.opacity(0.2),
                                    Color.orange.opacity(0.2)
                                ],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ),
                            lineWidth: 1
                        )
                )
        )
    }
}
struct MetricBadge: View {
    let icon: String
    let value: String
    let color: Color
    var body: some View {
        HStack(spacing: .ds.micro) {
            Image(systemName: icon)
                .font(.system(size: 14, weight: .medium))
                .foregroundColor(color)
            Text(value)
                .font(.ds.footnoteMedium)
                .foregroundColor(.ds.text)
        }
        .padding(.horizontal, .ds.small)
        .padding(.vertical, .ds.micro)
        .background(
            Capsule()
                .fill(color.opacity(0.1))
        )
    }
}
struct SuggestedHighlightCard: View {
    let suggestion: ArticleSuggestedHighlight
    let isSelected: Bool
    let action: () -> Void
    @State private var isHovered = false
    @State private var sparkleAnimation = false
    var body: some View {
        Button(action: action) {
            HStack(alignment: .top, spacing: .ds.base) {
                // Selection indicator
                ZStack {
                    Circle()
                        .fill(
                            isSelected ?
                                AnyShapeStyle(LinearGradient(
                                    colors: [.orange, .orange.opacity(0.7)],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )) :
                                AnyShapeStyle(DesignSystem.Colors.surfaceSecondary)
                        )
                        .frame(width: 24, height: 24)
                        .overlay(
                            Circle()
                                .stroke(
                                    isSelected ? Color.orange.opacity(0.3) : Color.ds.textTertiary.opacity(0.3),
                                    lineWidth: 1
                                )
                        )
                    if isSelected {
                        Image(systemName: "checkmark")
                            .font(.system(size: 12, weight: .bold))
                            .foregroundColor(.white)
                            .transition(.scale.combined(with: .opacity))
                    }
                }
                .scaleEffect(isHovered ? 1.1 : 1)
                // Content
                VStack(alignment: .leading, spacing: .ds.small) {
                    // Highlight text
                    Text("\"\(suggestion.text)\"")
                        .font(.ds.callout)
                        .foregroundColor(.ds.text)
                        .italic()
                        .lineLimit(3)
                        .multilineTextAlignment(.leading)
                    // Metadata
                    HStack(spacing: .ds.base) {
                        // Confidence score
                        HStack(spacing: .ds.micro) {
                            Image(systemName: "sparkles")
                                .font(.system(size: 12))
                                .foregroundColor(.orange)
                                .symbolEffect(.pulse, value: sparkleAnimation)
                            Text("\(Int(suggestion.confidence * 100))% confidence")
                                .font(.ds.caption)
                                .foregroundColor(.ds.textSecondary)
                        }
                        // Reason
                        if let reason = suggestion.reason {
                            Text("• \(reason)")
                                .font(.ds.caption)
                                .foregroundColor(.ds.textSecondary)
                                .lineLimit(1)
                        }
                    }
                }
                Spacer(minLength: 0)
                // Context indicator
                if suggestion.hasContext {
                    Image(systemName: "doc.text")
                        .font(.system(size: 14))
                        .foregroundColor(.ds.textTertiary)
                }
            }
            .padding(.ds.base)
            .background(
                RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                    .fill(
                        isSelected ?
                            AnyShapeStyle(Color.orange.opacity(0.05)) :
                            AnyShapeStyle(DesignSystem.Colors.surfaceSecondary)
                    )
                    .overlay(
                        RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                            .stroke(
                                isSelected ? Color.orange.opacity(0.3) : Color.clear,
                                lineWidth: 1
                            )
                    )
            )
            .scaleEffect(isHovered ? 1.02 : 1)
        }
        .buttonStyle(PlainButtonStyle())
        .onHover { hovering in
            withAnimation(.easeInOut(duration: 0.2)) {
                isHovered = hovering
            }
            if hovering {
                sparkleAnimation.toggle()
            }
        }
    }
}
struct AIThinkingAnimation: View {
    let progress: Double
    @State private var nodeAnimations: [Bool] = Array(repeating: false, count: 6)
    @State private var connectionOpacity: Double = 0
    var body: some View {
        ZStack {
            // Neural network connections
            ForEach(0..<5) { i in
                Path { path in
                    let angle1 = Double(i) * 72 * .pi / 180
                    let angle2 = Double(i + 1) * 72 * .pi / 180
                    let radius: CGFloat = 60
                    let x1 = cos(angle1) * radius
                    let y1 = sin(angle1) * radius
                    let x2 = cos(angle2) * radius
                    let y2 = sin(angle2) * radius
                    path.move(to: CGPoint(x: x1, y: y1))
                    path.addLine(to: CGPoint(x: x2, y: y2))
                }
                .stroke(
                    LinearGradient(
                        colors: [.purple.opacity(0.6), .orange.opacity(0.6)],
                        startPoint: .leading,
                        endPoint: .trailing
                    ),
                    lineWidth: 2
                )
                .opacity(connectionOpacity)
                .blur(radius: 1)
            }
            // Neural nodes
            ForEach(0..<6) { i in
                let angle = Double(i) * 60 * .pi / 180
                let radius: CGFloat = 60
                let x = cos(angle) * radius
                let y = sin(angle) * radius
                Circle()
                    .fill(
                        RadialGradient(
                            colors: [
                                i % 2 == 0 ? Color.purple : Color.orange,
                                i % 2 == 0 ? Color.purple.opacity(0.3) : Color.orange.opacity(0.3)
                            ],
                            center: .center,
                            startRadius: 0,
                            endRadius: 15
                        )
                    )
                    .frame(width: 30, height: 30)
                    .overlay(
                        Circle()
                            .stroke(Color.white.opacity(0.8), lineWidth: 2)
                    )
                    .position(x: x, y: y)
                    .scaleEffect(nodeAnimations[i] ? 1.3 : 1)
                    .opacity(nodeAnimations[i] ? 1 : 0.6)
            }
            // Center brain
            Image(systemName: "brain")
                .font(.system(size: 32, weight: .medium))
                .foregroundStyle(
                    LinearGradient(
                        colors: [.purple, .orange],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .symbolEffect(.pulse.wholeSymbol, options: .repeating, value: progress)
        }
        .frame(width: 120, height: 120)
        .onAppear {
            animateNodes()
            withAnimation(.easeInOut(duration: 1).repeatForever(autoreverses: true)) {
                connectionOpacity = 0.8
            }
        }
    }
    private func animateNodes() {
        for i in 0..<6 {
            withAnimation(
                .easeInOut(duration: 0.6)
                .repeatForever(autoreverses: true)
                .delay(Double(i) * 0.1)
            ) {
                nodeAnimations[i] = true
            }
        }
    }
}
// MARK: - Supporting Models
struct ImportParticle: Identifiable {
    let id = UUID()
    var x: CGFloat
    var y: CGFloat
    let size: CGFloat
    let color: Color
    let speed: CGFloat
    let isBurst: Bool = false
}
struct ImportParticleView: View {
    let particle: ImportParticle
    @State private var offset: CGSize = .zero
    @State private var opacity: Double = 1
    @State private var scale: CGFloat = 1
    var body: some View {
        Circle()
            .fill(
                RadialGradient(
                    colors: [
                        particle.color,
                        particle.color.opacity(0)
                    ],
                    center: .center,
                    startRadius: 0,
                    endRadius: particle.size
                )
            )
            .frame(width: particle.size * 2, height: particle.size * 2)
            .position(x: particle.x + offset.width, y: particle.y + offset.height)
            .opacity(opacity)
            .scaleEffect(scale)
            .onAppear {
                if particle.isBurst {
                    // Burst animation
                    let angle = Double.random(in: 0...360) * .pi / 180
                    let distance = particle.speed
                    withAnimation(.easeOut(duration: 1)) {
                        offset = CGSize(
                            width: cos(angle) * distance,
                            height: sin(angle) * distance
                        )
                        opacity = 0
                        scale = 0.5
                    }
                } else {
                    // Floating animation
                    withAnimation(
                        .easeInOut(duration: Double.random(in: 3...6))
                        .repeatForever(autoreverses: true)
                    ) {
                        offset = CGSize(
                            width: .random(in: -30...30),
                            height: .random(in: -50...50)
                        )
                    }
                }
            }
    }
}
struct NeuralPath: Identifiable {
    let id = UUID()
    let startX: CGFloat
    let startY: CGFloat
    let endX: CGFloat
    let endY: CGFloat
    let delay: Double
}
struct NeuralNetworkVisualization: View {
    let paths: [NeuralPath]
    let isActive: Bool
    @State private var pathAnimation: CGFloat = 0
    var body: some View {
        ZStack {
            ForEach(paths) { path in
                Path { p in
                    p.move(to: CGPoint(x: path.startX, y: path.startY))
                    p.addQuadCurve(
                        to: CGPoint(x: path.endX, y: path.endY),
                        control: CGPoint(
                            x: (path.startX + path.endX) / 2 + .random(in: -50...50),
                            y: (path.startY + path.endY) / 2 + .random(in: -50...50)
                        )
                    )
                }
                .trim(from: 0, to: isActive ? pathAnimation : 0)
                .stroke(
                    LinearGradient(
                        colors: [.purple.opacity(0.3), .orange.opacity(0.3)],
                        startPoint: .leading,
                        endPoint: .trailing
                    ),
                    style: StrokeStyle(lineWidth: 1, lineCap: .round)
                )
                .animation(
                    .easeInOut(duration: 2)
                    .repeatForever(autoreverses: true)
                    .delay(path.delay),
                    value: isActive
                )
            }
        }
        .onAppear {
            if isActive {
                withAnimation {
                    pathAnimation = 1
                }
            }
        }
        .onChange(of: isActive) { _, newValue in
            withAnimation {
                pathAnimation = newValue ? 1 : 0
            }
        }
    }
}
struct AnimatedGradientBackground: View {
    @State private var animationAmount: CGFloat = 0
    var body: some View {
        LinearGradient(
            colors: [
                DesignSystem.Colors.background,
                Color.purple.opacity(0.05),
                Color.orange.opacity(0.05),
                DesignSystem.Colors.background
            ],
            startPoint: .topLeading,
            endPoint: UnitPoint(x: 1 + animationAmount, y: 1 + animationAmount)
        )
        .ignoresSafeArea()
        .onAppear {
            withAnimation(.linear(duration: 10).repeatForever(autoreverses: true)) {
                animationAmount = 1
            }
        }
    }
}
// MARK: - Import Manager
class SmartImportManager: ObservableObject {
    @Published var isProcessing = false
    @Published var processingStatus = ""
    @Published var processedArticle: ProcessedArticle?
    @Published var includeImages = true
    @Published var preserveFormatting = true
    @Published var detectQuotes = true
    @Published var processingQuality: SmartArticleImportView.ImportQuality = .balanced
    private let aiEngine = AIHighlightEngine()
    var currentContent: ImportedContent?
    struct ImportedContent {
        let text: String
        let title: String?
        let author: String?
        let url: String?
    }
    func importFromURL(_ urlString: String) {
        isProcessing = true
        processingStatus = "Fetching article..."
        Task {
            do {
                // Fetch content from URL
                guard let url = URL(string: urlString) else {
                    throw ImportError.invalidURL
                }
                processingStatus = "Downloading content..."
                let (data, _) = try await URLSession.shared.data(from: url)
                if let htmlString = String(data: data, encoding: .utf8) {
                    // Extract text content from HTML
                    let text = extractTextFromHTML(htmlString)
                    let title = extractTitleFromHTML(htmlString)
                    currentContent = ImportedContent(
                        text: text,
                        title: title,
                        author: nil,
                        url: urlString
                    )
                    await MainActor.run {
                        self.processContent()
                    }
                } else {
                    throw ImportError.invalidContent
                }
            } catch {
                await MainActor.run {
                    self.processingStatus = "Failed to fetch article"
                    self.isProcessing = false
                }
            }
        }
    }
    func importFromFile(_ url: URL) {
        isProcessing = true
        processingStatus = "Reading file..."
        Task {
            do {
                let data = try Data(contentsOf: url)
                if url.pathExtension.lowercased() == "pdf" {
                    // Handle PDF files - would need PDFKit import
                    processingStatus = "Extracting text from PDF..."
                    // For now, just show error
                    throw ImportError.unsupportedFormat("PDF extraction not yet implemented")
                } else if let text = String(data: data, encoding: .utf8) {
                    // Plain text or markdown file
                    let title = url.deletingPathExtension().lastPathComponent
                    currentContent = ImportedContent(
                        text: text,
                        title: title,
                        author: nil,
                        url: url.absoluteString
                    )
                    await MainActor.run {
                        self.processContent()
                    }
                } else {
                    throw ImportError.invalidContent
                }
            } catch {
                await MainActor.run {
                    self.processingStatus = "Failed to read file: \(error.localizedDescription)"
                    self.isProcessing = false
                }
            }
        }
    }
    func importFromText(_ text: String) {
        isProcessing = true
        processingStatus = "Processing text..."
        currentContent = ImportedContent(
            text: text,
            title: nil,
            author: nil,
            url: nil
        )
        processContent()
    }
    private func processContent() {
        Task { @MainActor in
            await performAIAnalysis()
        }
    }
    @MainActor
    private func performAIAnalysis() async {
        // Use the actual content provided to the import manager
        guard let content = currentContent else {
            processingStatus = "No content to analyze"
            isProcessing = false
            return
        }
        do {
            // Map quality to analysis mode
            let analysisMode: AIHighlightEngine.AnalysisMode
            switch processingQuality {
            case .quick:
                analysisMode = .quick
            case .balanced:
                analysisMode = .balanced
            case .thorough:
                analysisMode = .thorough
            }
            // Perform AI analysis on actual content
            let result = try await aiEngine.analyzeText(content.text, mode: analysisMode)
            // Convert AI suggestions to article highlights
            let suggestions = result.suggestions.map { suggestion in
                ArticleSuggestedHighlight(
                    text: suggestion.text,
                    confidence: suggestion.confidence,
                    reason: suggestion.reason,
                    hasContext: suggestion.context != nil,
                    category: mapAICategory(suggestion.category)
                )
            }
            // Create processed article with real content and AI results
            processedArticle = ProcessedArticle(
                title: content.title ?? "Untitled Article",
                author: content.author,
                preview: String(content.text.prefix(200)) + "...",
                fullText: content.text,
                suggestedHighlights: suggestions
            )
            isProcessing = false
        } catch {
            processingStatus = "Error analyzing content: \(error.localizedDescription)"
            isProcessing = false
        }
    }
    private func mapAICategory(_ category: AIHighlightEngine.SuggestionCategory) -> HighlightCategory {
        switch category {
        case .thesisStatement:
            return .thesis
        case .statistic:
            return .statistic
        case .keyInsight, .novelConcept:
            return .insight
        case .quote:
            return .quote
        case .definition:
            return .definition
        default:
            return .insight
        }
    }
    func completeProcessing() {
        // This is now handled by performAIAnalysis
        // The method is kept for compatibility with the UI flow
    }
    // MARK: - Helper Methods
    private func extractTextFromHTML(_ html: String) -> String {
        // Simple HTML text extraction - in production, use a proper HTML parser
        let pattern = "<[^>]+>"
        let stripped = html.replacingOccurrences(of: pattern, with: "", options: .regularExpression)
        // Decode HTML entities
        let decoded = stripped
            .replacingOccurrences(of: "&nbsp;", with: " ")
            .replacingOccurrences(of: "&amp;", with: "&")
            .replacingOccurrences(of: "&lt;", with: "<")
            .replacingOccurrences(of: "&gt;", with: ">")
            .replacingOccurrences(of: "&quot;", with: "\"")
            .replacingOccurrences(of: "&#39;", with: "'")
            .replacingOccurrences(of: "&apos;", with: "'")
        // Clean up whitespace
        let lines = decoded.components(separatedBy: .newlines)
        let cleanedLines = lines.map { $0.trimmingCharacters(in: .whitespaces) }
        let filtered = cleanedLines.filter { !$0.isEmpty }
        return filtered.joined(separator: "\n\n")
    }
    private func extractTitleFromHTML(_ html: String) -> String? {
        // Extract title from HTML
        if let titleRange = html.range(of: "<title>.*?</title>", options: .regularExpression) {
            let titleTag = String(html[titleRange])
            return titleTag
                .replacingOccurrences(of: "<title>", with: "")
                .replacingOccurrences(of: "</title>", with: "")
                .trimmingCharacters(in: .whitespacesAndNewlines)
        }
        return nil
    }
    // MARK: - Errors
    enum ImportError: LocalizedError {
        case invalidURL
        case invalidContent
        case unsupportedFormat(String)
        case networkError(String)
        var errorDescription: String? {
            switch self {
            case .invalidURL:
                return "Invalid URL provided"
            case .invalidContent:
                return "Unable to process the content"
            case .unsupportedFormat(let format):
                return "Unsupported format: \(format)"
            case .networkError(let message):
                return "Network error: \(message)"
            }
        }
    }
}
struct ProcessedArticle {
    let id = UUID()
    let title: String
    let author: String?
    let preview: String
    let fullText: String
    let suggestedHighlights: [ArticleSuggestedHighlight]
}
struct ArticleSuggestedHighlight: Identifiable {
    let id = UUID().uuidString
    let text: String
    let confidence: Double
    let reason: String?
    let hasContext: Bool
    let startIndex: Int
    let endIndex: Int
    let category: HighlightCategory
    init(text: String, confidence: Double, reason: String?, hasContext: Bool, startIndex: Int = 0, endIndex: Int = 0, category: HighlightCategory = .insight) {
        self.text = text
        self.confidence = confidence
        self.reason = reason
        self.hasContext = hasContext
        self.startIndex = startIndex
        self.endIndex = endIndex
        self.category = category
    }
}
enum HighlightCategory: String, CaseIterable {
    case thesis = "Thesis"
    case statistic = "Statistic"
    case insight = "Insight"
    case quote = "Quote"
    case definition = "Definition"
    var color: Color {
        switch self {
        case .thesis: return .purple
        case .statistic: return .blue
        case .insight: return .orange
        case .quote: return .green
        case .definition: return .pink
        }
    }
    var icon: String {
        switch self {
        case .thesis: return "lightbulb.fill"
        case .statistic: return "chart.bar.fill"
        case .insight: return "sparkles"
        case .quote: return "quote.bubble.fill"
        case .definition: return "book.fill"
        }
    }
}
// MARK: - New Enhanced Components
struct LiveArticlePreview: View {
    let article: ProcessedArticle
    let selectedSuggestions: Set<String>
    let onHighlightTap: (String) -> Void
    @State private var hoveredHighlight: String? = nil
    @State private var scrollToHighlight: String? = nil
    @State private var highlightAnimations: [String: Bool] = [:]
    var body: some View {
        VStack(alignment: .leading, spacing: .ds.large) {
            // Article content with inline highlights
            ScrollViewReader { proxy in
                VStack(alignment: .leading, spacing: .ds.medium) {
                    ForEach(generateContentParagraphs(), id: \.self) { paragraph in
                        HighlightedParagraph(
                            text: paragraph,
                            highlights: findHighlightsInParagraph(paragraph),
                            selectedSuggestions: selectedSuggestions,
                            hoveredHighlight: hoveredHighlight,
                            onHighlightTap: onHighlightTap,
                            onHighlightHover: { id in
                                withAnimation(.easeInOut(duration: 0.2)) {
                                    hoveredHighlight = id
                                }
                            }
                        )
                        .id(paragraph)
                    }
                }
                .onChange(of: scrollToHighlight) { _, newValue in
                    if let highlight = newValue {
                        withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
                            proxy.scrollTo(highlight, anchor: .center)
                        }
                    }
                }
            }
        }
        .padding(.vertical, .ds.large)
        .background(
            RoundedRectangle(cornerRadius: .ds.large, style: .continuous)
                .fill(DesignSystem.Colors.surface)
                .shadow(color: DesignSystem.Shadow.elevated.color, radius: DesignSystem.Shadow.elevated.radius, x: DesignSystem.Shadow.elevated.x, y: DesignSystem.Shadow.elevated.y)
        )
    }
    private func generateContentParagraphs() -> [String] {
        // Split the article's full text into paragraphs
        let paragraphs = article.fullText
            .components(separatedBy: .newlines)
            .map { $0.trimmingCharacters(in: .whitespaces) }
            .filter { !$0.isEmpty }
        return paragraphs.isEmpty ? ["No content available"] : paragraphs
    }
    private func findHighlightsInParagraph(_ paragraph: String) -> [ArticleSuggestedHighlight] {
        article.suggestedHighlights.filter { highlight in
            paragraph.contains(highlight.text)
        }
    }
}
struct HighlightedParagraph: View {
    let text: String
    let highlights: [ArticleSuggestedHighlight]
    let selectedSuggestions: Set<String>
    let hoveredHighlight: String?
    let onHighlightTap: (String) -> Void
    let onHighlightHover: (String?) -> Void
    @State private var highlightOpacities: [String: Double] = [:]
    var body: some View {
        Text(attributedText)
            .font(.ds.body)
            .lineSpacing(8)
            .onAppear {
                animateHighlights()
            }
    }
    private var attributedText: AttributedString {
        var attributed = AttributedString(text)
        for highlight in highlights {
            if let range = attributed.range(of: highlight.text) {
                let isSelected = selectedSuggestions.contains(highlight.id)
                let isHovered = hoveredHighlight == highlight.id
                attributed[range].backgroundColor = isSelected ? 
                    highlight.category.color.opacity(0.3) : 
                    highlight.category.color.opacity(0.1)
                attributed[range].underlineStyle = isHovered ? .single : .none
                attributed[range].underlineColor = UIColor(highlight.category.color)
                // Add interactive tap
                attributed[range].link = URL(string: "highlight://\(highlight.id)")
            }
        }
        return attributed
    }
    private func animateHighlights() {
        for highlight in highlights {
            withAnimation(.easeInOut(duration: 0.5).delay(Double.random(in: 0...0.3))) {
                highlightOpacities[highlight.id] = 1.0
            }
        }
    }
}
struct ArticleMetricsCard: View {
    let article: ProcessedArticle
    let complexityScore: Double
    let readingTime: Int
    let selectedCount: Int
    @State private var animateMetrics = false
    var body: some View {
        VStack(spacing: .ds.medium) {
            // Animated metrics
            HStack(spacing: .ds.medium) {
                AnimatedMetric(
                    value: readingTime,
                    unit: "min read",
                    icon: "clock.fill",
                    color: .blue,
                    animate: animateMetrics
                )
                AnimatedMetric(
                    value: Int(complexityScore * 100),
                    unit: "complexity",
                    icon: "brain",
                    color: .purple,
                    animate: animateMetrics
                )
                AnimatedMetric(
                    value: selectedCount,
                    unit: "selected",
                    icon: "checkmark.circle.fill",
                    color: .green,
                    animate: animateMetrics
                )
            }
            // Visual complexity indicator
            ComplexityVisualization(score: complexityScore)
                .frame(height: 40)
        }
        .padding(.ds.medium)
        .background(
            RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                .fill(DesignSystem.Colors.surface)
                .shadow(color: DesignSystem.Shadow.medium.color, radius: DesignSystem.Shadow.medium.radius, x: DesignSystem.Shadow.medium.x, y: DesignSystem.Shadow.medium.y)
        )
        .onAppear {
            withAnimation(.spring(response: 0.5, dampingFraction: 0.8).delay(0.2)) {
                animateMetrics = true
            }
        }
    }
}
struct AnimatedMetric: View {
    let value: Int
    let unit: String
    let icon: String
    let color: Color
    let animate: Bool
    @State private var displayValue: Int = 0
    var body: some View {
        VStack(spacing: .ds.micro) {
            Image(systemName: icon)
                .font(.system(size: 24))
                .foregroundColor(color)
                .symbolEffect(.bounce, value: animate)
            Text("\(displayValue)")
                .font(.ds.title2.monospacedDigit())
                .foregroundColor(.ds.text)
            Text(unit)
                .font(.ds.caption)
                .foregroundColor(.ds.textSecondary)
        }
        .frame(maxWidth: .infinity)
        .onAppear {
            if animate {
                animateValue()
            }
        }
        .onChange(of: animate) { _, newValue in
            if newValue {
                animateValue()
            }
        }
    }
    private func animateValue() {
        let steps = 20
        let stepDuration = 0.5 / Double(steps)
        for i in 0...steps {
            DispatchQueue.main.asyncAfter(deadline: .now() + Double(i) * stepDuration) {
                displayValue = Int(Double(value) * (Double(i) / Double(steps)))
            }
        }
    }
}
struct ComplexityVisualization: View {
    let score: Double
    @State private var animatedScore: Double = 0
    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                // Background gradient
                LinearGradient(
                    colors: [.green, .yellow, .orange, .red],
                    startPoint: .leading,
                    endPoint: .trailing
                )
                .clipShape(Capsule())
                .opacity(0.3)
                // Filled portion
                LinearGradient(
                    colors: [.green, .yellow, .orange, .red],
                    startPoint: .leading,
                    endPoint: .trailing
                )
                .clipShape(Capsule())
                .frame(width: geometry.size.width * animatedScore)
                // Indicator
                Circle()
                    .fill(.white)
                    .frame(width: 20, height: 20)
                    .overlay(
                        Circle()
                            .stroke(Color.black.opacity(0.2), lineWidth: 2)
                    )
                    .offset(x: geometry.size.width * animatedScore - 10)
            }
        }
        .onAppear {
            withAnimation(.spring(response: 0.8, dampingFraction: 0.8)) {
                animatedScore = score
            }
        }
    }
}
struct EnhancedSuggestionCard: View {
    let suggestion: ArticleSuggestedHighlight
    let isSelected: Bool
    let index: Int
    let action: () -> Void
    @State private var isPressed = false
    @State private var showInsight = false
    @State private var glowAnimation = false
    var body: some View {
        Button(action: action) {
            VStack(alignment: .leading, spacing: .ds.base) {
                // Header with category badge
                HStack {
                    CategoryBadge(category: suggestion.category)
                    Spacer()
                    // Confidence indicator
                    ConfidenceIndicator(
                        confidence: suggestion.confidence,
                        isAnimating: glowAnimation
                    )
                }
                // Highlight text with enhanced styling
                Text("\"\(suggestion.text)\"")
                    .font(.ds.callout)
                    .foregroundColor(.ds.text)
                    .italic()
                    .lineLimit(showInsight ? nil : 3)
                    .fixedSize(horizontal: false, vertical: true)
                    .frame(maxWidth: .infinity, alignment: .leading)
                // AI reasoning with animation
                if let reason = suggestion.reason {
                    HStack(spacing: .ds.small) {
                        Image(systemName: "cpu")
                            .font(.system(size: 12))
                            .foregroundColor(.purple)
                            .symbolEffect(.pulse, value: isSelected)
                        Text(reason)
                            .font(.ds.caption)
                            .foregroundColor(.ds.textSecondary)
                            .transition(.push(from: .bottom).combined(with: .opacity))
                    }
                }
                // Selection indicator with animation
                HStack {
                    ZStack {
                        RoundedRectangle(cornerRadius: .ds.small, style: .continuous)
                            .fill(
                                isSelected ?
                                    AnyShapeStyle(LinearGradient(
                                        colors: [suggestion.category.color, suggestion.category.color.opacity(0.7)],
                                        startPoint: .leading,
                                        endPoint: .trailing
                                    )) :
                                    AnyShapeStyle(DesignSystem.Colors.surfaceSecondary)
                            )
                            .frame(width: 40, height: 24)
                        Circle()
                            .fill(.white)
                            .frame(width: 18, height: 18)
                            .offset(x: isSelected ? 8 : -8)
                            .shadow(color: DesignSystem.Shadow.subtle.color, radius: DesignSystem.Shadow.subtle.radius, x: DesignSystem.Shadow.subtle.x, y: DesignSystem.Shadow.subtle.y)
                    }
                    Text(isSelected ? "Selected" : "Select")
                        .font(.ds.footnoteMedium)
                        .foregroundColor(isSelected ? suggestion.category.color : .ds.textSecondary)
                    Spacer()
                    // Expand button
                    Button(action: {
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                            showInsight.toggle()
                        }
                    }) {
                        Image(systemName: "chevron.down")
                            .font(.system(size: 12, weight: .medium))
                            .foregroundColor(.ds.textSecondary)
                            .rotationEffect(.degrees(showInsight ? 180 : 0))
                    }
                }
            }
            .padding(.ds.medium)
            .background(
                ZStack {
                    // Base background
                    RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                        .fill(
                            isSelected ?
                                AnyShapeStyle(suggestion.category.color.opacity(0.1)) :
                                AnyShapeStyle(DesignSystem.Colors.surface)
                        )
                    // Glow effect for selected state
                    if isSelected {
                        RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                            .stroke(
                                LinearGradient(
                                    colors: [
                                        suggestion.category.color.opacity(0.5),
                                        suggestion.category.color.opacity(0.2)
                                    ],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                ),
                                lineWidth: 2
                            )
                            .blur(radius: glowAnimation ? 3 : 1)
                    }
                }
            )
            .scaleEffect(isPressed ? 0.98 : 1)
            .shadow(
                color: isSelected ? suggestion.category.color.opacity(0.2) : .black.opacity(0.05),
                radius: isSelected ? 15 : 10,
                x: 0,
                y: 5
            )
        }
        .buttonStyle(PlainButtonStyle())
        .onAppear {
            withAnimation(.easeInOut(duration: 1.5).repeatForever(autoreverses: true)) {
                glowAnimation = true
            }
        }
        .onLongPressGesture(minimumDuration: 0) {
            // Action handled by button
        } onPressingChanged: { pressing in
            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                isPressed = pressing
            }
        }
    }
}
struct CategoryBadge: View {
    let category: HighlightCategory
    @State private var pulseAnimation = false
    var body: some View {
        HStack(spacing: .ds.micro) {
            Image(systemName: category.icon)
                .font(.system(size: 12, weight: .medium))
                .symbolEffect(.pulse, value: pulseAnimation)
            Text(category.rawValue)
                .font(.ds.caption.weight(.medium))
        }
        .foregroundColor(category.color)
        .padding(.horizontal, .ds.small)
        .padding(.vertical, .ds.micro)
        .background(
            Capsule()
                .fill(category.color.opacity(0.15))
                .overlay(
                    Capsule()
                        .stroke(category.color.opacity(0.3), lineWidth: 1)
                )
        )
        .onAppear {
            withAnimation(.easeInOut(duration: 2).repeatForever()) {
                pulseAnimation = true
            }
        }
    }
}
struct ConfidenceIndicator: View {
    let confidence: Double
    let isAnimating: Bool
    var body: some View {
        HStack(spacing: 2) {
            ForEach(0..<5) { index in
                Circle()
                    .fill(
                        Double(index) < confidence * 5 ?
                            LinearGradient(
                                colors: [.orange, .yellow],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ) :
                            LinearGradient(
                                colors: [Color.gray.opacity(0.3)],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                    )
                    .frame(width: 6, height: 6)
                    .scaleEffect(isAnimating && Double(index) < confidence * 5 ? 1.2 : 1)
                    .animation(
                        .spring(response: 0.3, dampingFraction: 0.6)
                        .delay(Double(index) * 0.05),
                        value: isAnimating
                    )
            }
        }
    }
}
</file>

<file path="Sources/Highlighter/Views/Import/SmartContentImporter.swift">
import SwiftUI
import NDKSwift
import PDFKit
import WebKit
import Vision
import NaturalLanguage
struct SmartContentImporter: View {
    @EnvironmentObject var appState: AppState
    @StateObject private var importManager = ContentImportManager()
    @State private var selectedTab = ImportTab.files
    @State private var dragOver = false
    @State private var processingAnimation = false
    @State private var particleSystem = ParticleSystem()
    @State private var showSuccessConfetti = false
    @State private var selectedSource: ImportSource?
    @Environment(\.dismiss) var dismiss
    enum ImportTab: String, CaseIterable {
        case files = "Files"
        case web = "Web"
        case camera = "Camera"
        var icon: String {
            switch self {
            case .files: return "doc.text.fill"
            case .web: return "globe"
            case .camera: return "camera.fill"
            }
        }
    }
    var body: some View {
        NavigationStack {
            ZStack {
                // Animated background
                AnimatedMeshBackground()
                    .ignoresSafeArea()
                    .opacity(0.3)
                VStack(spacing: 0) {
                    // Custom tab bar with morphing animation
                    MorphingTabBar(selectedTab: $selectedTab, tabs: ImportTab.allCases)
                        .padding(.horizontal, .ds.screenPadding)
                        .padding(.top, .ds.medium)
                    // Content area with animated transitions
                    TabView(selection: $selectedTab) {
                        FileImportView(importManager: importManager, dragOver: $dragOver)
                            .tag(ImportTab.files)
                        WebImportView(importManager: importManager)
                            .tag(ImportTab.web)
                        CameraImportView(importManager: importManager)
                            .tag(ImportTab.camera)
                    }
                    .tabViewStyle(.page(indexDisplayMode: .never))
                }
                // Processing overlay with particle effects
                if importManager.isProcessing {
                    ProcessingOverlay(
                        progress: importManager.progress,
                        currentStep: importManager.currentStep,
                        particleSystem: $particleSystem
                    )
                    .transition(.asymmetric(
                        insertion: .scale(scale: 0.8).combined(with: .opacity),
                        removal: .scale(scale: 1.1).combined(with: .opacity)
                    ))
                    .zIndex(100)
                }
                // Success confetti
                if showSuccessConfetti {
                    ConfettiView()
                        .allowsHitTesting(false)
                        .zIndex(200)
                }
            }
            .navigationTitle("Smart Import")
            .navigationBarTitleDisplayMode(.large)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    if let source = selectedSource, !importManager.isProcessing {
                        Button("Import") {
                            startImport(source: source)
                        }
                        .fontWeight(.semibold)
                        .foregroundColor(.ds.primary)
                    }
                }
            }
        }
        .sheet(item: $importManager.extractedContent) { content in
            SmartHighlightSuggestions(
                content: content,
                onComplete: { highlights in
                    saveHighlights(highlights)
                }
            )
        }
        .onChange(of: importManager.isComplete) { _, isComplete in
            if isComplete {
                showSuccessAnimation()
            }
        }
    }
    private func startImport(source: ImportSource) {
        Task {
            HapticManager.shared.impact(.medium)
            try await importManager.importContent(from: source)
        }
    }
    private func saveHighlights(_ highlights: [SuggestedHighlight]) {
        Task {
            for highlight in highlights where highlight.isSelected {
                // Create NDKEvent for each highlight
                let event = NDKEvent(
                    id: "",
                    pubkey: appState.userPubkey ?? "",
                    createdAt: Timestamp(Date().timeIntervalSince1970),
                    kind: 9802, // NIP-84 highlight
                    tags: highlight.tags,
                    content: highlight.text,
                    sig: ""
                )
                try await appState.ndk?.publish(event)
            }
            showSuccessConfetti = true
            HapticManager.shared.notification(.success)
            DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
                dismiss()
            }
        }
    }
    private func showSuccessAnimation() {
        withAnimation(.spring(response: 0.5, dampingFraction: 0.7)) {
            showSuccessConfetti = true
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
            showSuccessConfetti = false
        }
    }
}
// MARK: - File Import View
struct FileImportView: View {
    @ObservedObject var importManager: ContentImportManager
    @Binding var dragOver: Bool
    @State private var showDocumentPicker = false
    @State private var hoveredFileType: FileType?
    @State private var magneticOffset: CGSize = .zero
    enum FileType: String, CaseIterable {
        case pdf = "PDF"
        case epub = "EPUB"
        case txt = "Text"
        case markdown = "Markdown"
        var icon: String {
            switch self {
            case .pdf: return "doc.text.fill"
            case .epub: return "book.fill"
            case .txt: return "doc.plaintext.fill"
            case .markdown: return "text.quote"
            }
        }
        var gradient: [Color] {
            switch self {
            case .pdf: return [.red, .orange]
            case .epub: return [.blue, .purple]
            case .txt: return [.gray, .black]
            case .markdown: return [.green, .mint]
            }
        }
    }
    var body: some View {
        ScrollView {
            VStack(spacing: .ds.large) {
                // Drag and drop area with magnetic effect
                ZStack {
                    RoundedRectangle(cornerRadius: .ds.large, style: .continuous)
                        .fill(
                            LinearGradient(
                                colors: dragOver ? [.orange.opacity(0.1), .orange.opacity(0.05)] : [Color.ds.surfaceSecondary, Color.ds.surfaceSecondary],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .overlay(
                            RoundedRectangle(cornerRadius: .ds.large, style: .continuous)
                                .strokeBorder(
                                    style: StrokeStyle(
                                        lineWidth: 2,
                                        dash: dragOver ? [] : [10, 5]
                                    )
                                )
                                .foregroundColor(dragOver ? .orange : .ds.textTertiary)
                        )
                        .frame(height: 200)
                        .scaleEffect(dragOver ? 1.02 : 1)
                        .offset(magneticOffset)
                    VStack(spacing: .ds.medium) {
                        ZStack {
                            ForEach(0..<3) { i in
                                Image(systemName: "arrow.down.doc.fill")
                                    .font(.system(size: 50))
                                    .foregroundStyle(
                                        LinearGradient(
                                            colors: dragOver ? [.orange, .yellow] : [.gray, .gray.opacity(0.6)],
                                            startPoint: .topLeading,
                                            endPoint: .bottomTrailing
                                        )
                                    )
                                    .opacity(dragOver ? 0.3 - Double(i) * 0.1 : 0)
                                    .scaleEffect(1 + CGFloat(i) * 0.2)
                                    .rotationEffect(.degrees(dragOver ? Double(i) * 15 : 0))
                                    .animation(.spring(response: 0.5, dampingFraction: 0.7), value: dragOver)
                            }
                            Image(systemName: "arrow.down.doc.fill")
                                .font(.system(size: 50))
                                .foregroundStyle(
                                    LinearGradient(
                                        colors: dragOver ? [.orange, .yellow] : [.gray, .gray.opacity(0.6)],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                                .symbolEffect(.bounce, value: dragOver)
                        }
                        Text(dragOver ? "Drop your files here" : "Drag & drop files here")
                            .font(.ds.headline)
                            .foregroundColor(dragOver ? .orange : .ds.text)
                        Text("PDF, EPUB, TXT, or Markdown")
                            .font(.ds.caption)
                            .foregroundColor(.ds.textSecondary)
                    }
                }
                .onDrop(of: [.pdf, .epub, .plainText], isTargeted: $dragOver) { providers in
                    handleDrop(providers: providers)
                    return true
                }
                .animation(.spring(response: 0.3, dampingFraction: 0.8), value: dragOver)
                // File type grid with hover effects
                LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())], spacing: .ds.medium) {
                    ForEach(FileType.allCases, id: \.self) { fileType in
                        FileTypeCard(
                            fileType: fileType,
                            isHovered: hoveredFileType == fileType,
                            action: {
                                selectFileType(fileType)
                            }
                        )
                        .onHover { hovering in
                            withAnimation(.easeInOut(duration: 0.2)) {
                                hoveredFileType = hovering ? fileType : nil
                            }
                        }
                    }
                }
                // Or button
                HStack {
                    Rectangle()
                        .fill(Color.ds.textTertiary.opacity(0.3))
                        .frame(height: 1)
                    Text("or")
                        .font(.ds.caption)
                        .foregroundColor(.ds.textSecondary)
                        .padding(.horizontal, .ds.medium)
                    Rectangle()
                        .fill(Color.ds.textTertiary.opacity(0.3))
                        .frame(height: 1)
                }
                .padding(.vertical, .ds.small)
                // Browse button with ripple effect
                RippleButton(
                    title: "Browse Files",
                    icon: "folder",
                    action: {
                        showDocumentPicker = true
                    }
                )
            }
            .padding(.horizontal, .ds.screenPadding)
            .padding(.vertical, .ds.large)
        }
        .sheet(isPresented: $showDocumentPicker) {
            DocumentPicker(
                allowedContentTypes: [.pdf, .epub, .plainText, .text],
                onPick: { url in
                    importManager.selectedSource = .file(url)
                }
            )
        }
    }
    private func handleDrop(providers: [NSItemProvider]) {
        for provider in providers {
            if provider.hasItemConformingToTypeIdentifier("public.file-url") {
                provider.loadItem(forTypeIdentifier: "public.file-url", options: nil) { (item, error) in
                    if let data = item as? Data,
                       let url = URL(dataRepresentation: data, relativeTo: nil) {
                        DispatchQueue.main.async {
                            importManager.selectedSource = .file(url)
                        }
                    }
                }
            }
        }
    }
    private func selectFileType(_ type: FileType) {
        showDocumentPicker = true
        HapticManager.shared.impact(.light)
    }
}
// MARK: - File Type Card
struct FileTypeCard: View {
    let fileType: FileImportView.FileType
    let isHovered: Bool
    let action: () -> Void
    @State private var rippleScale: CGFloat = 0
    @State private var rippleOpacity: Double = 0
    var body: some View {
        Button(action: {
            triggerRipple()
            action()
        }) {
            ZStack {
                // Background with gradient
                RoundedRectangle(cornerRadius: .ds.large, style: .continuous)
                    .fill(
                        LinearGradient(
                            colors: isHovered ? fileType.gradient.map { $0.opacity(0.15) } : [Color.ds.surfaceSecondary],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                // Ripple effect
                Circle()
                    .fill(
                        RadialGradient(
                            colors: [
                                fileType.gradient[0].opacity(rippleOpacity),
                                fileType.gradient[0].opacity(0)
                            ],
                            center: .center,
                            startRadius: 0,
                            endRadius: 50
                        )
                    )
                    .scaleEffect(rippleScale)
                VStack(spacing: .ds.small) {
                    ZStack {
                        Circle()
                            .fill(
                                LinearGradient(
                                    colors: fileType.gradient.map { $0.opacity(0.1) },
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .frame(width: 60, height: 60)
                        Image(systemName: fileType.icon)
                            .font(.system(size: 28))
                            .foregroundStyle(
                                LinearGradient(
                                    colors: fileType.gradient,
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .scaleEffect(isHovered ? 1.1 : 1)
                    }
                    Text(fileType.rawValue)
                        .font(.ds.bodyMedium)
                        .foregroundColor(.ds.text)
                }
                .padding(.ds.medium)
            }
            .frame(height: 120)
            .scaleEffect(isHovered ? 1.02 : 1)
        }
        .buttonStyle(.plain)
        .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isHovered)
    }
    private func triggerRipple() {
        rippleScale = 0
        rippleOpacity = 0.5
        withAnimation(.easeOut(duration: 0.6)) {
            rippleScale = 2
            rippleOpacity = 0
        }
    }
}
// MARK: - Web Import View
struct WebImportView: View {
    @ObservedObject var importManager: ContentImportManager
    @State private var urlString = ""
    @State private var isValidURL = false
    @State private var showPreview = false
    @State private var previewHTML: String?
    @FocusState private var isURLFieldFocused: Bool
    var body: some View {
        ScrollView {
            VStack(spacing: .ds.large) {
                // URL Input with live validation
                VStack(alignment: .leading, spacing: .ds.small) {
                    Label("Article URL", systemImage: "link")
                        .font(.ds.footnoteMedium)
                        .foregroundColor(.ds.textSecondary)
                    HStack {
                        Image(systemName: "globe")
                            .foregroundColor(isValidURL ? .green : .ds.textTertiary)
                            .symbolEffect(.pulse, value: isValidURL)
                        TextField("https://arstechnica.com/article-title", text: $urlString)
                            .textFieldStyle(.plain)
                            .font(.ds.body)
                            .keyboardType(.URL)
                            .autocapitalization(.none)
                            .disableAutocorrection(true)
                            .focused($isURLFieldFocused)
                            .onChange(of: urlString) { _, newValue in
                                validateURL(newValue)
                            }
                        if !urlString.isEmpty {
                            Button(action: {
                                urlString = ""
                                isValidURL = false
                            }) {
                                Image(systemName: "xmark.circle.fill")
                                    .foregroundColor(.ds.textTertiary)
                            }
                        }
                    }
                    .padding(.ds.base)
                    .background(
                        RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                            .fill(Color.ds.surfaceSecondary)
                            .overlay(
                                RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                                    .strokeBorder(
                                        isURLFieldFocused ? Color.orange : Color.clear,
                                        lineWidth: 2
                                    )
                            )
                    )
                }
                // Preview button with loading state
                if isValidURL {
                    VStack(spacing: .ds.medium) {
                        Button(action: {
                            fetchPreview()
                        }) {
                            HStack {
                                Image(systemName: "eye")
                                Text("Preview Article")
                            }
                            .frame(maxWidth: .infinity)
                        }
                        .unifiedSecondaryButton()
                        if showPreview, let html = previewHTML {
                            ArticlePreview(html: html)
                                .frame(height: 300)
                                .clipShape(RoundedRectangle(cornerRadius: .ds.large, style: .continuous))
                                .overlay(
                                    RoundedRectangle(cornerRadius: .ds.large, style: .continuous)
                                        .stroke(Color.ds.textTertiary.opacity(0.2), lineWidth: 1)
                                )
                                .transition(.asymmetric(
                                    insertion: .push(from: .bottom).combined(with: .opacity),
                                    removal: .push(from: .top).combined(with: .opacity)
                                ))
                        }
                    }
                }
                // Popular sources with quick import
                VStack(alignment: .leading, spacing: .ds.medium) {
                    Label("Popular Sources", systemImage: "star.fill")
                        .font(.ds.headline)
                        .foregroundColor(.ds.text)
                    LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible())], spacing: .ds.small) {
                        ForEach(PopularSource.allCases, id: \.self) { source in
                            PopularSourceCard(source: source) { url in
                                urlString = url
                                validateURL(url)
                            }
                        }
                    }
                }
            }
            .padding(.horizontal, .ds.screenPadding)
            .padding(.vertical, .ds.large)
        }
        .animation(.spring(response: 0.3, dampingFraction: 0.8), value: showPreview)
    }
    private func validateURL(_ urlString: String) {
        if let url = URL(string: urlString),
           url.scheme == "https" || url.scheme == "http" {
            isValidURL = true
            importManager.selectedSource = .web(url)
        } else {
            isValidURL = false
        }
    }
    private func fetchPreview() {
        guard let url = URL(string: urlString) else { return }
        showPreview = true
        Task {
            // Fetch and extract article content
            let (data, _) = try await URLSession.shared.data(from: url)
            if let html = String(data: data, encoding: .utf8) {
                await MainActor.run {
                    previewHTML = html
                }
            }
        }
    }
}
// MARK: - Camera Import View
struct CameraImportView: View {
    @ObservedObject var importManager: ContentImportManager
    @State private var showCamera = false
    @State private var capturedImage: UIImage?
    @State private var recognizedText: String?
    @State private var scanAnimation = false
    var body: some View {
        ScrollView {
            VStack(spacing: .ds.large) {
                // Camera preview area
                ZStack {
                    if let image = capturedImage {
                        Image(uiImage: image)
                            .resizable()
                            .aspectRatio(contentMode: .fit)
                            .frame(maxHeight: 300)
                            .clipShape(RoundedRectangle(cornerRadius: .ds.large, style: .continuous))
                            .overlay(
                                RoundedRectangle(cornerRadius: .ds.large, style: .continuous)
                                    .stroke(Color.orange, lineWidth: 2)
                            )
                    } else {
                        RoundedRectangle(cornerRadius: .ds.large, style: .continuous)
                            .fill(Color.ds.surfaceSecondary)
                            .frame(height: 300)
                            .overlay(
                                VStack(spacing: .ds.medium) {
                                    ZStack {
                                        // Scanning animation
                                        if scanAnimation {
                                            ForEach(0..<3) { i in
                                                RoundedRectangle(cornerRadius: .ds.medium)
                                                    .stroke(Color.orange.opacity(0.3 - Double(i) * 0.1), lineWidth: 2)
                                                    .scaleEffect(1 + CGFloat(i) * 0.2)
                                                    .opacity(scanAnimation ? 0 : 1)
                                                    .animation(
                                                        .easeOut(duration: 1.5)
                                                        .repeatForever(autoreverses: false)
                                                        .delay(Double(i) * 0.2),
                                                        value: scanAnimation
                                                    )
                                            }
                                        }
                                        Image(systemName: "camera.viewfinder")
                                            .font(.system(size: 60))
                                            .foregroundColor(.orange)
                                            .symbolEffect(.pulse)
                                    }
                                    .frame(width: 100, height: 100)
                                    Text("Capture text from books or documents")
                                        .font(.ds.body)
                                        .foregroundColor(.ds.textSecondary)
                                        .multilineTextAlignment(.center)
                                }
                            )
                    }
                }
                .onAppear {
                    scanAnimation = true
                }
                // Capture button with ripple effect
                RippleButton(
                    title: capturedImage == nil ? "Open Camera" : "Retake Photo",
                    icon: "camera.fill",
                    action: {
                        showCamera = true
                    }
                )
                // OCR Results
                if let text = recognizedText {
                    VStack(alignment: .leading, spacing: .ds.small) {
                        Label("Recognized Text", systemImage: "text.viewfinder")
                            .font(.ds.headline)
                            .foregroundColor(.ds.text)
                        ScrollView {
                            Text(text)
                                .font(.ds.body)
                                .foregroundColor(.ds.text)
                                .padding()
                                .frame(maxWidth: .infinity, alignment: .leading)
                        }
                        .frame(maxHeight: 200)
                        .background(Color.ds.surfaceSecondary)
                        .clipShape(RoundedRectangle(cornerRadius: .ds.medium, style: .continuous))
                    }
                    .transition(.push(from: .bottom).combined(with: .opacity))
                }
                // Tips for better OCR
                TipsCard()
            }
            .padding(.horizontal, .ds.screenPadding)
            .padding(.vertical, .ds.large)
        }
        .sheet(isPresented: $showCamera) {
            CameraPicker(image: $capturedImage) { image in
                if let image = image {
                    performOCR(on: image)
                }
            }
        }
        .animation(.spring(response: 0.3, dampingFraction: 0.8), value: recognizedText != nil)
    }
    private func performOCR(on image: UIImage) {
        guard let cgImage = image.cgImage else { return }
        let requestHandler = VNImageRequestHandler(cgImage: cgImage)
        let request = VNRecognizeTextRequest { request, error in
            guard let observations = request.results as? [VNRecognizedTextObservation] else { return }
            let recognizedStrings = observations.compactMap { observation in
                observation.topCandidates(1).first?.string
            }
            DispatchQueue.main.async {
                recognizedText = recognizedStrings.joined(separator: "\n")
                if let text = recognizedText {
                    importManager.selectedSource = .text(text)
                }
            }
        }
        request.recognitionLevel = .accurate
        request.usesLanguageCorrection = true
        do {
            try requestHandler.perform([request])
        } catch {
        }
    }
}
// MARK: - Supporting Types
// MARK: - Content Import Manager
@MainActor
class ContentImportManager: ObservableObject {
    @Published var selectedSource: ImportSource?
    @Published var isProcessing = false
    @Published var progress: Double = 0
    @Published var currentStep = ""
    @Published var extractedContent: ExtractedContent?
    @Published var isComplete = false
    func importContent(from source: ImportSource) async throws {
        isProcessing = true
        progress = 0
        // Step 1: Extract text
        currentStep = "Extracting text..."
        progress = 0.2
        let text = try await extractText(from: source)
        // Step 2: Analyze content
        currentStep = "Analyzing content..."
        progress = 0.4
        let suggestions = await analyzeContent(text)
        // Step 3: Generate metadata
        currentStep = "Generating metadata..."
        progress = 0.6
        let metadata = extractMetadata(from: text)
        // Step 4: Prepare highlights
        currentStep = "Preparing highlights..."
        progress = 0.8
        extractedContent = ExtractedContent(
            title: metadata.title,
            author: metadata.author,
            content: text,
            source: source,
            suggestedHighlights: suggestions
        )
        progress = 1.0
        isProcessing = false
        isComplete = true
    }
    private func extractText(from source: ImportSource) async throws -> String {
        switch source {
        case .file(let url):
            return try await extractFromFile(url)
        case .web(let url):
            return try await extractFromWeb(url)
        case .text(let text):
            return text
        }
    }
    private func extractFromFile(_ url: URL) async throws -> String {
        // Simplified extraction logic
        let data = try Data(contentsOf: url)
        if url.pathExtension.lowercased() == "pdf" {
            // Extract from PDF
            if let pdf = PDFDocument(url: url) {
                var text = ""
                for i in 0..<pdf.pageCount {
                    if let page = pdf.page(at: i),
                       let pageContent = page.string {
                        text += pageContent + "\n\n"
                    }
                }
                return text
            }
        }
        // Try as plain text
        return String(data: data, encoding: .utf8) ?? ""
    }
    private func extractFromWeb(_ url: URL) async throws -> String {
        let (data, _) = try await URLSession.shared.data(from: url)
        if let html = String(data: data, encoding: .utf8) {
            // Simple HTML stripping (in production, use a proper HTML parser)
            let stripped = html
                .replacingOccurrences(of: "<[^>]+>", with: "", options: .regularExpression)
                .replacingOccurrences(of: "&[^;]+;", with: " ", options: .regularExpression)
            return stripped
        }
        return ""
    }
    private func analyzeContent(_ text: String) async -> [SuggestedHighlight] {
        // Use NaturalLanguage framework to find interesting sentences
        var suggestions: [SuggestedHighlight] = []
        let tagger = NLTagger(tagSchemes: [.sentimentScore])
        tagger.string = text
        let sentences = text.components(separatedBy: .newlines)
            .flatMap { $0.components(separatedBy: ". ") }
            .filter { !$0.isEmpty && $0.count > 20 }
        for sentence in sentences.prefix(10) {
            let confidence = Double.random(in: 0.3...1.0) // Simplified scoring
            suggestions.append(SuggestedHighlight(
                text: sentence.trimmingCharacters(in: .whitespacesAndNewlines),
                context: text,
                confidence: confidence,
                tags: []
            ))
        }
        return suggestions.sorted { $0.confidence > $1.confidence }
    }
    private func extractMetadata(from text: String) -> (title: String, author: String?) {
        // Simplified metadata extraction
        let lines = text.components(separatedBy: .newlines).filter { !$0.isEmpty }
        let title = lines.first ?? "Untitled"
        // Look for author patterns
        var author: String?
        for line in lines.prefix(10) {
            if line.lowercased().contains("by ") {
                author = line.components(separatedBy: "by ").last?.trimmingCharacters(in: .whitespaces)
                break
            }
        }
        return (title, author)
    }
}
// MARK: - Additional Components
struct MorphingTabBar: View {
    @Binding var selectedTab: SmartContentImporter.ImportTab
    let tabs: [SmartContentImporter.ImportTab]
    @Namespace private var animation
    var body: some View {
        HStack(spacing: 0) {
            ForEach(tabs, id: \.self) { tab in
                TabButton(
                    tab: tab,
                    isSelected: selectedTab == tab,
                    namespace: animation,
                    action: {
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                            selectedTab = tab
                        }
                    }
                )
            }
        }
        .padding(4)
        .background(Color.ds.surfaceSecondary)
        .clipShape(RoundedRectangle(cornerRadius: .ds.medium, style: .continuous))
    }
}
struct TabButton: View {
    let tab: SmartContentImporter.ImportTab
    let isSelected: Bool
    let namespace: Namespace.ID
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            HStack(spacing: .ds.small) {
                Image(systemName: tab.icon)
                    .font(.system(size: 16, weight: .semibold))
                    .symbolEffect(.bounce, value: isSelected)
                Text(tab.rawValue)
                    .font(.ds.footnoteMedium)
            }
            .foregroundColor(isSelected ? .white : .ds.textSecondary)
            .padding(.horizontal, .ds.base)
            .padding(.vertical, .ds.small)
            .frame(maxWidth: .infinity)
            .background(
                ZStack {
                    if isSelected {
                        RoundedRectangle(cornerRadius: .ds.small, style: .continuous)
                            .fill(Color.orange)
                            .matchedGeometryEffect(id: "tab", in: namespace)
                    }
                }
            )
        }
        .buttonStyle(.plain)
    }
}
struct ProcessingOverlay: View {
    let progress: Double
    let currentStep: String
    @Binding var particleSystem: ParticleSystem
    @State private var pulseScale: CGFloat = 1
    var body: some View {
        ZStack {
            // Blurred background
            Color.black.opacity(0.7)
                .ignoresSafeArea()
                .blur(radius: 10)
            VStack(spacing: .ds.large) {
                // Animated processing icon
                ZStack {
                    // Particle effects
                    ForEach(0..<12) { i in
                        Circle()
                            .fill(
                                LinearGradient(
                                    colors: [.orange, .yellow],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .frame(width: 8, height: 8)
                            .offset(x: 50)
                            .rotationEffect(.degrees(Double(i) * 30))
                            .rotationEffect(.degrees(progress * 360))
                            .opacity(0.6)
                    }
                    Circle()
                        .stroke(
                            LinearGradient(
                                colors: [.orange.opacity(0.3), .orange.opacity(0.1)],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ),
                            lineWidth: 3
                        )
                        .frame(width: 120, height: 120)
                        .scaleEffect(pulseScale)
                    Image(systemName: "doc.text.magnifyingglass")
                        .font(.system(size: 50))
                        .foregroundStyle(
                            LinearGradient(
                                colors: [.orange, .yellow],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .symbolEffect(.pulse)
                }
                VStack(spacing: .ds.small) {
                    Text(currentStep)
                        .font(.ds.headline)
                        .foregroundColor(.white)
                    // Custom progress bar
                    GeometryReader { geometry in
                        ZStack(alignment: .leading) {
                            RoundedRectangle(cornerRadius: .ds.small)
                                .fill(Color.white.opacity(0.2))
                            RoundedRectangle(cornerRadius: .ds.small)
                                .fill(
                                    LinearGradient(
                                        colors: [.orange, .yellow],
                                        startPoint: .leading,
                                        endPoint: .trailing
                                    )
                                )
                                .frame(width: geometry.size.width * progress)
                                .animation(.spring(response: 0.5, dampingFraction: 0.8), value: progress)
                        }
                    }
                    .frame(height: 8)
                    .frame(width: 200)
                    Text("\(Int(progress * 100))%")
                        .font(.ds.caption)
                        .foregroundColor(.white.opacity(0.8))
                        .contentTransition(.numericText())
                }
            }
            .padding(.ds.large)
            .background(
                RoundedRectangle(cornerRadius: .ds.large, style: .continuous)
                    .fill(.ultraThinMaterial)
                    .overlay(
                        RoundedRectangle(cornerRadius: .ds.large, style: .continuous)
                            .stroke(
                                LinearGradient(
                                    colors: [.orange.opacity(0.5), .orange.opacity(0.2)],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                ),
                                lineWidth: 1
                            )
                    )
            )
        }
        .onAppear {
            withAnimation(.easeInOut(duration: 1.5).repeatForever(autoreverses: true)) {
                pulseScale = 1.1
            }
        }
    }
}
// Additional supporting views would go here...
// (RippleButton, AnimatedMeshBackground, ConfettiView, SmartHighlightSuggestions, etc.)
#Preview {
    SmartContentImporter()
        .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Preview Content/PreviewData.swift">
import Foundation
/// Provides realistic preview data for SwiftUI previews
enum PreviewData {
    // MARK: - Articles
    static let articleURLs = [
        "https://example.com/article/decentralized-networks",
        "https://example.com/article/bitcoin-lightning",
        "https://example.com/article/digital-publishing",
        "https://example.com/article/ai-content-creation",
        "https://example.com/article/privacy-social-media",
        "https://example.com/article/reading-experiences",
        "https://example.com/article/information-retention"
    ]
    static let articleTitles = [
        "The Evolution of Decentralized Networks: A Deep Dive",
        "Understanding Bitcoin's Lightning Network",
        "The Future of Digital Publishing",
        "How AI is Transforming Content Creation",
        "Privacy in the Age of Social Media",
        "Building Better Reading Experiences",
        "The Science of Information Retention"
    ]
    static let articleSummaries = [
        "An in-depth exploration of how decentralized networks are reshaping the internet, examining both technical innovations and social implications.",
        "Lightning Network enables instant Bitcoin transactions with minimal fees, opening new possibilities for micropayments and everyday commerce.",
        "Digital publishing is undergoing a renaissance as new platforms emerge that prioritize reader experience and creator monetization.",
        "Artificial intelligence tools are augmenting human creativity, helping writers overcome blocks and explore new narrative possibilities.",
        "As data collection becomes ubiquitous, individuals and organizations grapple with balancing convenience and privacy protection.",
        "Modern reading apps leverage cognitive science to improve comprehension and retention through better typography and interaction design.",
        "Research reveals how our brains process and store information, leading to new techniques for effective learning and memory."
    ]
    // MARK: - Highlights
    static let highlightTexts = [
        "The most profound technologies are those that disappear. They weave themselves into the fabric of everyday life until they are indistinguishable from it.",
        "In a decentralized system, trust is not eliminated but rather distributed across the network, creating resilience through redundancy.",
        "The future of money is not just digital—it's programmable, permissionless, and fundamentally reimagines value exchange.",
        "Reading is not passive consumption but active construction of meaning, where reader and text collaborate to create understanding.",
        "Privacy is not about hiding wrongdoing; it's about maintaining the autonomy to selectively reveal oneself to the world.",
        "The best interface is no interface—technology should empower without demanding constant attention or interaction.",
        "Knowledge work is not about time spent but value created; the industrial model of productivity doesn't apply to creative endeavors."
    ]
    static let highlightContexts = [
        "From 'The Invisible Computer' discussing ubiquitous computing",
        "Analyzing Byzantine Fault Tolerance in distributed systems",
        "Exploring the implications of programmable money",
        "On the phenomenology of reading and interpretation",
        "Privacy as a fundamental human right in digital spaces",
        "Design principles for ambient computing environments",
        "Rethinking productivity in the knowledge economy"
    ]
    // MARK: - Authors
    static let authorNames = [
        "Alexandra Chen",
        "Marcus Thompson",
        "Dr. Sarah Williams",
        "James Rodriguez",
        "Emma Nakamura",
        "Prof. David Kumar",
        "Lisa Anderson"
    ]
    static let authorBios = [
        "Technology writer and researcher focusing on decentralized systems and cryptography.",
        "Senior editor at Tech Quarterly, covering emerging technologies and their societal impact.",
        "Neuroscientist studying how digital media affects cognition and learning.",
        "Financial technology expert and author of 'The Future of Money'.",
        "Privacy advocate and cybersecurity researcher at Stanford University.",
        "Interaction designer pioneering ambient computing interfaces.",
        "Organizational psychologist reimagining work in the digital age."
    ]
    // Profile pictures are now generated dynamically using initials
    // See AsyncProfileImage for implementation
    // Article images are now generated using gradient placeholders
    // See ArticleImageView for implementation
    // MARK: - Curations
    static let curationNames = [
        "essential-readings",
        "bitcoin-lightning",
        "privacy-first",
        "ai-creativity",
        "future-of-work",
        "digital-wellness",
        "decentralized-web"
    ]
    static let curationTitles = [
        "Essential Readings on Digital Philosophy",
        "Understanding Bitcoin's Lightning Network",
        "Privacy-First Technology Guide",
        "AI and Human Creativity",
        "The Future of Remote Work",
        "Digital Wellness and Mindful Tech",
        "Building the Decentralized Web"
    ]
    static let curationDescriptions = [
        "A curated collection of foundational texts exploring how technology shapes human experience and society.",
        "Deep dives into Lightning Network technology, from basic concepts to advanced implementations.",
        "Resources for maintaining privacy and security in an increasingly connected world.",
        "Exploring the intersection of artificial intelligence and human creative expression.",
        "Insights on remote work, distributed teams, and the evolution of workplace culture.",
        "Strategies for maintaining balance and wellbeing in our relationship with technology.",
        "Technical and philosophical perspectives on building a more open and resilient internet."
    ]
    // MARK: - Helper Methods
    static func randomArticleURL() -> String {
        articleURLs.randomElement() ?? articleURLs[0]
    }
    static func randomHighlight() -> String {
        highlightTexts.randomElement() ?? highlightTexts[0]
    }
    static func randomAuthorName() -> String {
        authorNames.randomElement() ?? authorNames[0]
    }
}
</file>

<file path="Sources/Highlighter/Views/Articles/ArticleListView.swift">
import SwiftUI
import NDKSwift
struct ArticleListView: View {
    @EnvironmentObject var appState: AppState
    @State private var articles: [Article] = []
    @State private var featuredArticles: [Article] = []
    @State private var selectedArticle: Article?
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(spacing: DesignSystem.Spacing.large) {
                    if articles.isEmpty {
                        emptyState
                    } else {
                        // Featured Articles Section
                        if !featuredArticles.isEmpty {
                            VStack(alignment: .leading, spacing: DesignSystem.Spacing.medium) {
                                Text("Featured")
                                    .font(DesignSystem.Typography.headline)
                                    .foregroundColor(DesignSystem.Colors.text)
                                    .padding(.horizontal)
                                ScrollView(.horizontal, showsIndicators: false) {
                                    HStack(spacing: DesignSystem.Spacing.medium) {
                                        ForEach(featuredArticles.prefix(3)) { article in
                                            ModernArticleFeaturedCard(article: article)
                                                .onTapGesture {
                                                    selectedArticle = article
                                                    HapticManager.shared.impact(.light)
                                                }
                                        }
                                    }
                                    .padding(.horizontal)
                                }
                            }
                        }
                        // Regular Articles Section
                        VStack(alignment: .leading, spacing: DesignSystem.Spacing.medium) {
                            if !featuredArticles.isEmpty {
                                Text("Recent Articles")
                                    .font(DesignSystem.Typography.headline)
                                    .foregroundColor(DesignSystem.Colors.text)
                                    .padding(.horizontal)
                            }
                            LazyVStack(spacing: DesignSystem.Spacing.medium) {
                                ForEach(articles.filter { article in
                                    !featuredArticles.contains(where: { $0.id == article.id })
                                }) { article in
                                    ModernArticleRowCard(article: article)
                                        .onTapGesture {
                                            selectedArticle = article
                                            HapticManager.shared.impact(.light)
                                        }
                                }
                            }
                            .padding(.horizontal)
                        }
                    }
                }
                .padding(.vertical)
            }
            .navigationTitle("Articles")
            .navigationBarTitleDisplayMode(.large)
            .refreshable {
                await loadArticles()
            }
            .sheet(item: $selectedArticle) { article in
                ArticleView(article: article)
            }
        }
        .task {
            await loadArticles()
        }
    }
    @ViewBuilder
    private var emptyState: some View {
        VStack(spacing: DesignSystem.Spacing.large) {
            Image(systemName: "doc.text")
                .font(.system(size: 60))
                .foregroundColor(DesignSystem.Colors.textSecondary)
            Text("No articles yet")
                .font(DesignSystem.Typography.headline)
                .foregroundColor(DesignSystem.Colors.text)
            Text("Long-form articles will appear here")
                .font(DesignSystem.Typography.body)
                .foregroundColor(DesignSystem.Colors.textSecondary)
                .multilineTextAlignment(.center)
        }
        .padding(DesignSystem.Spacing.xl)
    }
    private func loadArticles() async {
        guard let ndk = appState.ndk else { return }
        let articleSource = await ndk.outbox.observe(
            filter: NDKFilter(kinds: [30023], limit: 50),
            maxAge: 300,
            cachePolicy: .cacheWithNetwork
        )
        for await event in articleSource.events {
            if let article = try? Article(from: event) {
                await MainActor.run {
                    if !articles.contains(where: { $0.id == article.id }) {
                        articles.append(article)
                        articles.sort { $0.createdAt > $1.createdAt }
                        // Select featured articles (first 3 with images)
                        featuredArticles = articles
                            .filter { $0.image != nil }
                            .prefix(3)
                            .map { $0 }
                    }
                }
            }
        }
    }
}
#Preview {
    ArticleListView()
        .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Views/Articles/ArticleView.swift">
import SwiftUI
import NDKSwift
import NDKSwiftUI
struct ArticleView: View {
    let article: Article
    @EnvironmentObject var appState: AppState
    @State private var selectedRange: NSRange?
    @State private var showHighlightCreator = false
    @State private var highlights: [HighlightEvent] = []
    @State private var scrollOffset: CGFloat = 0
    @State private var showingSwarmOverlay = false
    @State private var selectedText = ""
    @State private var contextText = ""
    @State private var isBookmarked = false
    @State private var showShareSheet = false
    @State private var readingProgress: Double = 0
    @State private var estimatedReadTime: Int = 0
    @State private var fontScale: CGFloat = 1.0
    @State private var showReadingSettings = false
    @State private var highlightOpacity: Double = 0.3
    @State private var selectedHighlight: HighlightEvent?
    @State private var showHighlightDetail = false
    @State private var author: NDKUserProfile?
    @State private var showTextSelection = false
    @StateObject private var swarmManager = SwarmHighlightManager(ndk: NDK(relayUrls: []))
    @Environment(\.dismiss) private var dismiss
    @Environment(\.colorScheme) private var colorScheme
    private let impactMedium = UIImpactFeedbackGenerator(style: .medium)
    private let selectionFeedback = UISelectionFeedbackGenerator()
    var body: some View {
        articleViewContent
            .navigationBarHidden(true)
            .sheet(isPresented: $showHighlightCreator) {
                highlightCreatorSheet
            }
            .sheet(isPresented: $showingSwarmOverlay) {
                swarmOverlaySheet
            }
            .sheet(isPresented: $showHighlightDetail) {
                highlightDetailSheet
            }
            .sheet(isPresented: $showReadingSettings) {
                readingSettingsSheet
            }
            .sheet(isPresented: $showTextSelection) {
                textSelectionSheet
            }
            .task {
                await initializeArticle()
            }
            .onDisappear {
                // End reading session when leaving the article
                appState.readingProgressService.endReadingSession()
            }
    }
    // MARK: - Main Article View Content
    private var articleViewContent: some View {
        GeometryReader { geometry in
            ZStack(alignment: .top) {
                AmbientBackground()
                mainContent(geometry: geometry)
                enhancedFloatingNavBar(in: geometry)
            }
        }
    }
    // MARK: - Sheet Views
    private var highlightCreatorSheet: some View {
        EnhancedCreateHighlightView(
            articleId: article.id,
            articleTitle: article.title,
            selectedText: selectedText,
            contextText: contextText,
            onComplete: { highlight in
                highlights.append(highlight)
                HapticManager.shared.notification(.success)
            }
        )
    }
    private var swarmOverlaySheet: some View {
        SwarmOverlayView(
            text: article.content,
            swarmManager: swarmManager
        )
        .presentationDetents([.medium, .large])
        .presentationDragIndicator(.visible)
        .presentationBackground(.ultraThinMaterial)
    }
    @ViewBuilder
    private var highlightDetailSheet: some View {
        if let highlight = selectedHighlight {
            HighlightDetailView(highlight: highlight)
                .presentationDetents([.medium])
                .presentationDragIndicator(.visible)
                .presentationBackground(.ultraThinMaterial)
        }
    }
    private var readingSettingsSheet: some View {
        ReadingSettingsView(
            fontScale: $fontScale,
            highlightOpacity: $highlightOpacity
        )
        .presentationDetents([.height(300)])
        .presentationDragIndicator(.visible)
        .presentationBackground(.ultraThinMaterial)
    }
    private var textSelectionSheet: some View {
        TextSelectionView(
            content: article.content,
            source: article.title,
            author: author?.displayName ?? PubkeyFormatter.formatShort(article.author)
        )
    }
    // MARK: - Main Content View
    private func mainContent(geometry: GeometryProxy) -> some View {
        ScrollViewReader { scrollProxy in
            ScrollView {
                VStack(spacing: 0) {
                    heroHeader(in: geometry)
                        .id("top")
                    readingProgressBar(geometry: geometry)
                    articleContentSection()
                }
                .background(scrollTracker(geometry: geometry))
            }
            .coordinateSpace(name: "scroll")
            .onPreferenceChange(ScrollOffsetPreferenceKey.self) { value in
                scrollOffset = value
            }
        }
    }
    // MARK: - Reading Progress Bar
    private func readingProgressBar(geometry: GeometryProxy) -> some View {
        GeometryReader { geo in
            Rectangle()
                .fill(
                    LinearGradient(
                        colors: [
                            DesignSystem.Colors.secondary,
                            DesignSystem.Colors.primary
                        ],
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                )
                .frame(width: geo.size.width * readingProgress, height: 3)
                .animation(.spring(response: 0.3), value: readingProgress)
        }
        .frame(height: 3)
        .padding(.top, -3)
    }
    // MARK: - Article Content Section
    private func articleContentSection() -> some View {
        VStack(alignment: .leading, spacing: .ds.xxl) {
            titleSection()
                .padding(.horizontal, .ds.screenPadding)
                .padding(.top, .ds.large)
            Divider()
                .padding(.horizontal, .ds.screenPadding)
            articleBodyContent()
                .padding(.horizontal, .ds.screenPadding)
            if !highlights.isEmpty {
                Divider()
                    .padding(.horizontal, .ds.screenPadding)
                EnhancedCommunityHighlightsSection(
                    highlights: highlights,
                    onHighlightTap: { highlight in
                        selectedHighlight = highlight
                        showHighlightDetail = true
                    }
                )
                .padding(.horizontal, .ds.screenPadding)
            }
            EnhancedRelatedArticlesSection(currentArticle: article)
                .padding(.top, .ds.sectionSpacing)
            ArticleFooter(article: article)
                .padding(.horizontal, .ds.screenPadding)
                .padding(.bottom, 100)
        }
    }
    // MARK: - Title Section
    private func titleSection() -> some View {
        VStack(alignment: .leading, spacing: .ds.large) {
            Text(article.title)
                .font(.system(size: 34 * fontScale, weight: .bold, design: .serif))
                .foregroundColor(.ds.text)
                .fixedSize(horizontal: false, vertical: true)
                .premiumEntrance(delay: 0.1)
            if let summary = article.summary {
                Text(summary)
                    .font(.system(size: 18 * fontScale, weight: .regular))
                    .foregroundColor(.ds.textSecondary)
                    .fixedSize(horizontal: false, vertical: true)
                    .premiumEntrance(delay: 0.15)
            }
            articleMetadataRow()
        }
    }
    // MARK: - Article Metadata Row
    private func articleMetadataRow() -> some View {
        HStack(spacing: .ds.large) {
            AuthorChip(pubkey: article.author, profile: author)
                .premiumEntrance(delay: 0.2)
            HStack(spacing: .ds.small) {
                Image(systemName: "clock")
                    .font(.system(size: 12))
                Text("\(estimatedReadTime) min read")
                    .font(.ds.caption)
            }
            .foregroundColor(.ds.textTertiary)
            .premiumEntrance(delay: 0.25)
            Spacer()
            ReadingSettingsButton(showSettings: $showReadingSettings)
                .premiumEntrance(delay: 0.3)
        }
    }
    // MARK: - Article Body Content
    @ViewBuilder
    private func articleBodyContent() -> some View {
        if article.content.isEmpty {
            emptyContentView()
        } else if let ndk = appState.ndk {
            SelectableMarkdownRenderer(
                content: article.content,
                ndk: ndk,
                onTextSelected: { text, range in
                    // Extract context from the full content
                    let nsString = article.content as NSString
                    let contextRange = NSRange(
                        location: max(0, range.location - 50),
                        length: min(nsString.length - max(0, range.location - 50), range.length + 100)
                    )
                    let context = nsString.substring(with: contextRange)
                    handleTextSelection(text: text, context: context, range: range)
                }
            )
            .markdownStyle(createArticleMarkdownStyle(fontScale: fontScale))
            .onMentionTap { mention in
                // Handle mention tap if needed
            }
            .onHashtagTap { tag in
                // Handle hashtag tap if needed
            }
            .onLinkTap { url in
                // Handle link tap if needed
            }
            .frame(maxWidth: .infinity, alignment: .leading)
        } else {
            Text("NDK not initialized")
                .font(.ds.body)
                .foregroundColor(.ds.textSecondary)
                .padding()
        }
    }
    // MARK: - Empty Content View
    private func emptyContentView() -> some View {
        VStack(spacing: 16) {
            Image(systemName: "doc.text")
                .font(.system(size: 48))
                .foregroundColor(.ds.textTertiary)
            Text("No content available")
                .font(.ds.headline)
                .foregroundColor(.ds.textSecondary)
            Text("This article appears to be empty.")
                .font(.ds.body)
                .foregroundColor(.ds.textTertiary)
        }
        .padding(40)
        .frame(maxWidth: .infinity, minHeight: 300)
    }
    // MARK: - Scroll Tracker
    private func scrollTracker(geometry: GeometryProxy) -> some View {
        GeometryReader { geo in
            Color.clear
                .preference(
                    key: ScrollOffsetPreferenceKey.self,
                    value: geo.frame(in: .named("scroll")).minY
                )
                .onAppear {
                    calculateReadingProgress(geo: geo, in: geometry)
                }
                .onChange(of: geo.frame(in: .named("scroll")).minY) { _, _ in
                    calculateReadingProgress(geo: geo, in: geometry)
                }
        }
    }
    // MARK: - Initialize Article
    private func initializeArticle() async {
        // Initialize article
        await loadHighlights()
        await loadAuthor()
        estimatedReadTime = calculateReadTime()
        impactMedium.prepare()
        selectionFeedback.prepare()
        // Initialize swarm manager
        if let ndk = appState.ndk {
            swarmManager.ndk = ndk
            let articleUrl = article.tags.first(where: { $0.first == "r" })?[safe: 1]
            swarmManager.loadSwarmHighlights(
                for: articleUrl,
                articleEvent: article.identifier
            )
        }
        // Restore previous reading progress
        if let previousProgress = appState.readingProgressService.getProgress(for: article.id) {
            readingProgress = previousProgress.progress
            // Note: We could also restore scroll position here if needed
        }
        // Start reading session
        appState.readingProgressService.startReadingSession(for: article.id)
    }
    // MARK: - Enhanced Components
    private func heroHeader(in geometry: GeometryProxy) -> some View {
        ZStack(alignment: .bottom) {
            // Dynamic background with parallax and blur
            if let imageUrl = article.image {
                AsyncImage(url: URL(string: imageUrl)) { phase in
                    switch phase {
                    case .success(let image):
                        ZStack {
                            // Blurred background layer
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                .frame(width: geometry.size.width, height: 400)
                                .blur(radius: 30)
                                .scaleEffect(1.2)
                                .offset(y: scrollOffset * 0.3)
                                .opacity(0.6)
                            // Main image
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                .frame(width: geometry.size.width - 40, height: 320)
                                .clipShape(RoundedRectangle(cornerRadius: .ds.large, style: .continuous))
                                .shadow(color: .black.opacity(0.2), radius: 20, y: 10)
                                .offset(y: scrollOffset * 0.5)
                                .scaleEffect(1 + (scrollOffset > 0 ? scrollOffset * 0.0005 : 0))
                        }
                    case .empty, .failure:
                        ArticleGradientPlaceholder()
                            .frame(width: geometry.size.width, height: 400)
                    @unknown default:
                        EmptyView()
                    }
                }
            } else {
                if #available(iOS 18.0, *) {
                    ArticleAnimatedGradientBackground()
                        .frame(width: geometry.size.width, height: 400)
                } else {
                    ArticleGradientPlaceholder()
                        .frame(width: geometry.size.width, height: 400)
                }
            }
            // Enhanced gradient overlay
            VStack(spacing: 0) {
                LinearGradient(
                    colors: [
                        Color.clear,
                        DesignSystem.Colors.background.opacity(0.3),
                        DesignSystem.Colors.background.opacity(0.7),
                        DesignSystem.Colors.background.opacity(0.95),
                        DesignSystem.Colors.background
                    ],
                    startPoint: .top,
                    endPoint: .bottom
                )
                .frame(height: 200)
                DesignSystem.Colors.background
                    .frame(height: 50)
            }
        }
        .frame(height: 400)
        .clipped()
    }
    private func enhancedFloatingNavBar(in geometry: GeometryProxy) -> some View {
        let isScrolled = scrollOffset < -50
        return VStack(spacing: 0) {
            HStack {
                // Back button with dynamic styling
                Button(action: { dismiss() }) {
                    HStack(spacing: .ds.mini) {
                        Image(systemName: "arrow.left")
                            .font(.system(size: 16, weight: .semibold))
                        if isScrolled {
                            Text("Articles")
                                .font(.ds.footnoteMedium)
                                .transition(.asymmetric(
                                    insertion: .push(from: .leading),
                                    removal: .push(from: .trailing)
                                ))
                        }
                    }
                    .foregroundColor(.ds.text)
                    .padding(.horizontal, .ds.base)
                    .padding(.vertical, .ds.small)
                    .background(
                        Capsule()
                            .fill(DesignSystem.Colors.surface.opacity(isScrolled ? 0.95 : 0.8))
                            .shadow(color: .black.opacity(0.1), radius: 8, y: 4)
                    )
                }
                .magneticHover()
                Spacer()
                // Action buttons
                HStack(spacing: .ds.base) {
                    // Swarm view button with indicator
                    Button(action: { showingSwarmOverlay = true }) {
                        ZStack(alignment: .topTrailing) {
                            Image(systemName: "sparkles")
                                .font(.system(size: 18, weight: .medium))
                                .foregroundColor(.ds.primary)
                                .frame(width: 40, height: 40)
                                .background(
                                    Circle()
                                        .fill(DesignSystem.Colors.surface.opacity(isScrolled ? 0.95 : 0.8))
                                        .shadow(color: .black.opacity(0.1), radius: 8, y: 4)
                                )
                            if !highlights.isEmpty {
                                Circle()
                                    .fill(DesignSystem.Colors.secondary)
                                    .frame(width: 8, height: 8)
                                    .offset(x: -5, y: 5)
                            }
                        }
                    }
                    .magneticHover()
                    // Text selection mode
                    Button(action: { showTextSelection = true }) {
                        Image(systemName: "highlighter")
                            .font(.system(size: 18, weight: .medium))
                            .foregroundColor(.ds.secondary)
                            .frame(width: 40, height: 40)
                            .background(
                                Circle()
                                    .fill(DesignSystem.Colors.surface.opacity(isScrolled ? 0.95 : 0.8))
                                    .shadow(color: .black.opacity(0.1), radius: 8, y: 4)
                            )
                    }
                    .magneticHover()
                    // Enhanced bookmark button
                    Button(action: {
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {
                            isBookmarked.toggle()
                        }
                        if isBookmarked {
                            HapticManager.shared.notification(.success)
                        } else {
                            HapticManager.shared.impact(.light)
                        }
                    }) {
                        Image(systemName: isBookmarked ? "bookmark.fill" : "bookmark")
                            .font(.system(size: 18, weight: .medium))
                            .foregroundColor(isBookmarked ? .ds.primary : .ds.text)
                            .symbolEffect(.bounce, value: isBookmarked)
                            .frame(width: 40, height: 40)
                            .background(
                                Circle()
                                    .fill(DesignSystem.Colors.surface.opacity(isScrolled ? 0.95 : 0.8))
                                    .shadow(color: .black.opacity(0.1), radius: 8, y: 4)
                            )
                    }
                    .magneticHover()
                    // Share button
                    Button(action: { showShareSheet = true }) {
                        Image(systemName: "square.and.arrow.up")
                            .font(.system(size: 18, weight: .medium))
                            .foregroundColor(.ds.text)
                            .frame(width: 40, height: 40)
                            .background(
                                Circle()
                                    .fill(DesignSystem.Colors.surface.opacity(isScrolled ? 0.95 : 0.8))
                                    .shadow(color: .black.opacity(0.1), radius: 8, y: 4)
                            )
                    }
                    .magneticHover()
                }
            }
            .padding(.horizontal, .ds.screenPadding)
            .padding(.top, geometry.safeAreaInsets.top + 10)
            .padding(.bottom, .ds.base)
            // Article title when scrolled
            if isScrolled {
                Text(article.title)
                    .font(.ds.headline)
                    .foregroundColor(.ds.text)
                    .lineLimit(1)
                    .padding(.horizontal, .ds.screenPadding)
                    .padding(.bottom, .ds.base)
                    .transition(.asymmetric(
                        insertion: .push(from: .top).combined(with: .opacity),
                        removal: .push(from: .bottom).combined(with: .opacity)
                    ))
            }
        }
        .background(
            DesignSystem.Colors.background
                .opacity(isScrolled ? 0.95 : 0)
                .ignoresSafeArea()
                .background(.ultraThinMaterial.opacity(isScrolled ? 1 : 0))
        )
        .animation(.spring(response: 0.3), value: isScrolled)
    }
    private var enhancedSelectionToolbar: some View {
        VStack(spacing: .ds.small) {
            HStack(spacing: .ds.small) {
                // Highlight button
                Button(action: {
                    selectionFeedback.selectionChanged()
                    createHighlight()
                }) {
                    VStack(spacing: 4) {
                        Image(systemName: "highlighter")
                            .font(.system(size: 20, weight: .medium))
                        Text("Highlight")
                            .font(.system(size: 10, weight: .medium))
                    }
                    .foregroundColor(.white)
                    .frame(width: 70, height: 50)
                    .background(
                        RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                            .fill(
                                LinearGradient(
                                    colors: [
                                        DesignSystem.Colors.secondary,
                                        DesignSystem.Colors.secondaryDark
                                    ],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .shadow(color: .ds.secondary.opacity(0.3), radius: 6, y: 3)
                    )
                }
                .buttonStyle(BounceButtonStyle())
                // Copy button
                Button(action: {
                    UIPasteboard.general.string = selectedText
                    HapticManager.shared.notification(.success)
                    selectedRange = nil
                }) {
                    VStack(spacing: 4) {
                        Image(systemName: "doc.on.doc")
                            .font(.system(size: 20, weight: .medium))
                        Text("Copy")
                            .font(.system(size: 10, weight: .medium))
                    }
                    .foregroundColor(.ds.text)
                    .frame(width: 70, height: 50)
                    .background(
                        RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                            .fill(DesignSystem.Colors.surface)
                            .shadow(color: .black.opacity(0.1), radius: 6, y: 3)
                    )
                }
                .buttonStyle(BounceButtonStyle())
                // Dismiss button
                Button(action: {
                    withAnimation(.spring(response: 0.3)) {
                        selectedRange = nil
                    }
                }) {
                    Image(systemName: "xmark")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(.ds.textSecondary)
                        .frame(width: 30, height: 30)
                        .background(
                            Circle()
                                .fill(DesignSystem.Colors.surface)
                                .shadow(color: .black.opacity(0.05), radius: 4, y: 2)
                        )
                }
            }
            // Selected text preview
            Text(selectedText)
                .font(.ds.caption)
                .foregroundColor(.ds.textSecondary)
                .lineLimit(2)
                .padding(.horizontal, .ds.base)
                .padding(.vertical, .ds.small)
                .frame(maxWidth: 250)
                .background(
                    RoundedRectangle(cornerRadius: .ds.small, style: .continuous)
                        .fill(DesignSystem.Colors.surface.opacity(0.9))
                )
        }
    }
    // MARK: - Helper Methods
    private func handleTextSelection(text: String, context: String, range: NSRange) {
        selectedText = text
        contextText = context
        selectedRange = range
        selectionFeedback.selectionChanged()
    }
    private func createHighlight() {
        showHighlightCreator = true
        selectedRange = nil
    }
    private func calculateReadTime() -> Int {
        let wordsPerMinute = 200
        let wordCount = article.content.split(separator: " ").count
        return max(1, wordCount / wordsPerMinute)
    }
    private func calculateReadingProgress(geo: GeometryProxy, in containerGeo: GeometryProxy) {
        let totalHeight = geo.size.height
        let visibleHeight = containerGeo.size.height
        let currentOffset = -geo.frame(in: .named("scroll")).minY
        let progress = (currentOffset + visibleHeight) / totalHeight
        readingProgress = min(max(0, progress), 1)
        // Update reading progress in the service
        appState.readingProgressService.updateProgress(
            for: article.id,
            progress: readingProgress,
            scrollPosition: currentOffset
        )
    }
    private func createArticleMarkdownStyle(fontScale: CGFloat) -> MarkdownConfiguration {
        var config = MarkdownConfiguration()
        config.textColor = .ds.text
        config.headingColor = .ds.text
        config.linkColor = .ds.primary
        config.codeBackgroundColor = DesignSystem.Colors.surfaceSecondary
        config.blockquoteColor = .ds.textSecondary
        config.blockquoteBorderColor = .ds.primary
        config.mentionColor = .ds.primary
        config.hashtagColor = .ds.secondary
        config.nostrEntityColor = .ds.primary
        config.bodyFont = .system(size: 17 * fontScale, weight: .regular, design: .serif)
        config.h1Font = .system(size: 32 * fontScale, weight: .bold, design: .serif)
        config.h2Font = .system(size: 26 * fontScale, weight: .semibold, design: .serif)
        config.h3Font = .system(size: 22 * fontScale, weight: .medium, design: .serif)
        config.contentPadding = EdgeInsets(top: 0, leading: 0, bottom: 0, trailing: 0)
        return config
    }
    private func loadAuthor() async {
        guard let ndk = appState.ndk else { return }
        let profileDataSource = await ndk.outbox.observe(
            filter: NDKFilter(
                authors: [article.author],
                kinds: [0]
            ),
            maxAge: 3600,
            cachePolicy: .cacheWithNetwork
        )
        for await event in profileDataSource.events {
            if let fetchedProfile = JSONCoding.safeDecode(NDKUserProfile.self, from: event.content) {
                await MainActor.run {
                    self.author = fetchedProfile
                }
                break
            }
        }
    }
    private func loadHighlights() async {
        guard let ndk = appState.ndk else { return }
        // Create filter for highlights related to this article
        var tagsFilter: [String: Set<String>] = [:]
        // Add article event ID tag
        tagsFilter["e"] = [article.id]
        // Also look for highlights by the same author
        let filter = NDKFilter(
            kinds: [9802], // NIP-84 highlight kind
            limit: 50,
            tags: tagsFilter
        )
        // Fetch events using NDK's outbox
        let dataSource = await ndk.outbox.observe(
            filter: filter,
            maxAge: TimeConstants.hour,
            cachePolicy: .cacheWithNetwork
        )
        var loadedHighlights: [HighlightEvent] = []
        for await event in dataSource.events {
            // Extract context from tags (not needed here as HighlightEvent.init will extract it)
            // Create HighlightEvent from NDK event
            do {
                let highlight = try HighlightEvent(from: event)
                loadedHighlights.append(highlight)
            } catch {
                // Skip invalid highlight events
            }
        }
        // Sort by creation date, newest first and update state
        await MainActor.run {
            highlights = loadedHighlights.sorted { $0.createdAt > $1.createdAt }
        }
    }
}
// MARK: - Supporting Views
struct AmbientBackground: View {
    @State private var animationPhase = 0.0
    var body: some View {
        Canvas { context, size in
            let colors = [
                DesignSystem.Colors.primary.opacity(0.05),
                DesignSystem.Colors.secondary.opacity(0.03),
                DesignSystem.Colors.background
            ]
            let gradient = Gradient(colors: colors)
            context.fill(
                Path(CGRect(origin: .zero, size: size)),
                with: .linearGradient(
                    gradient,
                    startPoint: .zero,
                    endPoint: CGPoint(x: size.width, y: size.height)
                )
            )
        }
        .ignoresSafeArea()
        .animation(.easeInOut(duration: 10).repeatForever(autoreverses: true), value: animationPhase)
        .onAppear { animationPhase = 1 }
    }
}
struct ArticleGradientPlaceholder: View {
    var body: some View {
        Rectangle()
            .fill(
                LinearGradient(
                    colors: [
                        DesignSystem.Colors.primary.opacity(0.3),
                        DesignSystem.Colors.secondary.opacity(0.2)
                    ],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
            )
            .overlay(
                Image(systemName: "photo")
                    .font(.system(size: 48))
                    .foregroundColor(.white.opacity(0.3))
            )
    }
}
@available(iOS 18.0, *)
struct ArticleAnimatedGradientBackground: View {
    @State private var animationPhase = 0.0
    var body: some View {
        MeshGradient(
            width: 3,
            height: 3,
            points: [
                [0, 0], [0.5, 0], [1, 0],
                [0, 0.5], [Float(0.5 + sin(animationPhase) * 0.1), 0.5], [1, 0.5],
                [0, 1], [0.5, 1], [1, 1]
            ],
            colors: [
                DesignSystem.Colors.primary,
                DesignSystem.Colors.primaryLight,
                DesignSystem.Colors.secondary,
                DesignSystem.Colors.primaryDark,
                DesignSystem.Colors.primary,
                DesignSystem.Colors.secondaryLight,
                DesignSystem.Colors.secondary,
                DesignSystem.Colors.primaryLight,
                DesignSystem.Colors.primary
            ]
        )
        .ignoresSafeArea()
        .animation(.easeInOut(duration: 5).repeatForever(autoreverses: true), value: animationPhase)
        .onAppear { animationPhase = .pi * 2 }
    }
}
struct AuthorChip: View {
    let pubkey: String
    let profile: NDKUserProfile?
    var body: some View {
        HStack(spacing: .ds.small) {
            Group {
                if let picture = profile?.picture, let url = URL(string: picture) {
                    AsyncImage(url: url) { image in
                        image
                            .resizable()
                            .scaledToFill()
                    } placeholder: {
                        Circle()
                            .fill(DesignSystem.Colors.surfaceSecondary)
                            .overlay(
                                Text(displayName.prefix(1).uppercased())
                                    .font(.ds.captionMedium)
                                    .foregroundColor(.ds.text)
                            )
                    }
                } else {
                    Circle()
                        .fill(DesignSystem.Colors.surfaceSecondary)
                        .overlay(
                            Text(displayName.prefix(1).uppercased())
                                .font(.ds.captionMedium)
                                .foregroundColor(.ds.text)
                        )
                }
            }
            .frame(width: 28, height: 28)
            .clipShape(Circle())
            Text(displayName)
                .font(.ds.footnoteMedium)
                .foregroundColor(.ds.text)
        }
        .padding(.horizontal, .ds.base)
        .padding(.vertical, .ds.mini)
        .background(
            Capsule()
                .fill(DesignSystem.Colors.surfaceSecondary.opacity(0.5))
        )
    }
    private var displayName: String {
        profile?.displayName ?? PubkeyFormatter.formatCompact(pubkey)
    }
}
struct ReadingSettingsButton: View {
    @Binding var showSettings: Bool
    var body: some View {
        Button(action: { showSettings = true }) {
            Image(systemName: "textformat.size")
                .font(.system(size: 16, weight: .medium))
                .foregroundColor(.ds.text)
                .frame(width: 32, height: 32)
                .background(
                    Circle()
                        .fill(DesignSystem.Colors.surfaceSecondary.opacity(0.5))
                )
        }
    }
}
struct BounceButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.92 : 1)
            .animation(.spring(response: 0.2, dampingFraction: 0.6), value: configuration.isPressed)
    }
}
// MARK: - Enhanced Supporting Components
// Removed EnhancedSelectableMarkdownRenderer - no longer needed
struct EnhancedCommunityHighlightsSection: View {
    let highlights: [HighlightEvent]
    let onHighlightTap: (HighlightEvent) -> Void
    @EnvironmentObject var appState: AppState
    var body: some View {
        VStack(alignment: .leading, spacing: .ds.large) {
            ModernSectionHeader(title: "Community Highlights")
            VStack(spacing: .ds.base) {
                ForEach(highlights.prefix(5), id: \.id) { highlight in
                    ModernHighlightCard(highlight: highlight)
                        .environmentObject(appState)
                }
            }
        }
    }
}
// ArticleEnhancedHighlightCard removed - now using UnifiedCard system (ModernHighlightCard)
struct EnhancedRelatedArticlesSection: View {
    let currentArticle: Article
    @State private var relatedArticles: [Article] = []
    @EnvironmentObject var appState: AppState
    var body: some View {
        if !relatedArticles.isEmpty {
            VStack(alignment: .leading, spacing: .ds.large) {
                ModernSectionHeader(title: "You Might Also Like")
                    .padding(.horizontal, .ds.screenPadding)
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: .ds.medium) {
                        ForEach(relatedArticles, id: \.id) { article in
                            EnhancedRelatedArticleCard(article: article)
                                .frame(width: 300)
                        }
                    }
                    .padding(.horizontal, .ds.screenPadding)
                }
            }
        }
    }
    private func loadRelatedArticles() {
        guard let ndk = appState.ndk else { return }
        Task {
            // Create filter for articles from the same author or with similar tags
            var filters: [NDKFilter] = []
            // Articles from the same author
            filters.append(NDKFilter(
                authors: [currentArticle.author],
                kinds: [30023], // Long-form content
                limit: 10
            ))
            // Articles with similar tags
            let articleTags = currentArticle.tags.filter { $0.count > 1 && $0[0] == "t" }.map { $0[1] }
            if !articleTags.isEmpty {
                var tagsFilter: [String: Set<String>] = [:]
                tagsFilter["t"] = Set(articleTags)
                filters.append(NDKFilter(
                    kinds: [30023],
                    limit: 10,
                    tags: tagsFilter
                ))
            }
            var allRelatedArticles: [Article] = []
            for filter in filters {
                // Use NDK's outbox to fetch events
                let dataSource = await ndk.outbox.observe(
                    filter: filter,
                    maxAge: TimeConstants.hour,
                    cachePolicy: .cacheWithNetwork
                )
                for await event in dataSource.events {
                    // Skip the current article
                    if event.id == currentArticle.id { continue }
                    do {
                        let relatedArticle = try Article(from: event)
                        allRelatedArticles.append(relatedArticle)
                    } catch {
                        // Skip invalid articles
                    }
                    // Limit to prevent too many results
                    if allRelatedArticles.count >= 20 { break }
                }
            }
            // Remove duplicates based on article ID and limit to 6 articles
            var uniqueArticleIds = Set<String>()
            let uniqueArticles = allRelatedArticles.filter { article in
                if uniqueArticleIds.contains(article.id) {
                    return false
                }
                uniqueArticleIds.insert(article.id)
                return true
            }.prefix(6)
            await MainActor.run {
                relatedArticles = Array(uniqueArticles)
            }
        }
    }
}
struct EnhancedRelatedArticleCard: View {
    let article: Article
    var body: some View {
        NavigationLink(destination: ArticleView(article: article)) {
            VStack(alignment: .leading, spacing: .ds.base) {
                if let imageUrl = article.image {
                    AsyncImage(url: URL(string: imageUrl)) { phase in
                        switch phase {
                        case .success(let image):
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                .frame(height: 160)
                                .clipped()
                                .clipShape(RoundedRectangle(cornerRadius: .ds.medium, style: .continuous))
                        case .empty, .failure:
                            RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                                .fill(DesignSystem.Colors.surfaceSecondary)
                                .frame(height: 160)
                                .overlay(
                                    Image(systemName: "photo")
                                        .font(.system(size: 24))
                                        .foregroundColor(.ds.textTertiary)
                                )
                        @unknown default:
                            EmptyView()
                        }
                    }
                }
                VStack(alignment: .leading, spacing: .ds.small) {
                    Text(article.title)
                        .font(.ds.headline)
                        .foregroundColor(.ds.text)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)
                    if let summary = article.summary {
                        Text(summary)
                            .font(.ds.callout)
                            .foregroundColor(.ds.textSecondary)
                            .lineLimit(2)
                            .multilineTextAlignment(.leading)
                    }
                    HStack {
                        Text(PubkeyFormatter.formatShort(article.author))
                            .font(.ds.caption)
                            .foregroundColor(.ds.textTertiary)
                        Spacer()
                        Label("\(article.estimatedReadingTime) min", systemImage: "clock")
                            .font(.ds.caption)
                            .foregroundColor(.ds.textTertiary)
                    }
                }
                .padding(.horizontal, .ds.base)
                .padding(.bottom, .ds.base)
            }
        }
        .modernCard(noPadding: true)
    }
}
struct ArticleFooter: View {
    let article: Article
    var body: some View {
        VStack(spacing: .ds.large) {
            Divider()
            HStack {
                VStack(alignment: .leading, spacing: .ds.small) {
                    Text("Thanks for reading")
                        .font(.ds.headline)
                        .foregroundColor(.ds.text)
                    Text("Support the author")
                        .font(.ds.callout)
                        .foregroundColor(.ds.textSecondary)
                }
                Spacer()
                Button(action: {}) {
                    HStack {
                        Image(systemName: "bolt.fill")
                        Text("Zap Author")
                    }
                    .font(.ds.footnoteMedium)
                    .foregroundColor(.white)
                    .padding(.horizontal, .ds.medium)
                    .padding(.vertical, .ds.small)
                    .background(
                        Capsule()
                            .fill(
                                LinearGradient(
                                    colors: [.ds.secondary, .ds.secondaryDark],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                    )
                }
                .magneticHover()
            }
            // Tags
            if !article.hashtags.isEmpty {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: .ds.small) {
                        ForEach(article.hashtags, id: \.self) { tag in
                            Text("#\(tag)")
                                .font(.ds.caption)
                                .foregroundColor(.ds.primary)
                                .padding(.horizontal, .ds.base)
                                .padding(.vertical, .ds.micro)
                                .background(
                                    Capsule()
                                        .fill(DesignSystem.Colors.primary.opacity(0.1))
                                )
                        }
                    }
                }
            }
        }
    }
}
// MARK: - Sheet Views
struct EnhancedCreateHighlightView: View {
    let articleId: String
    let articleTitle: String
    let selectedText: String
    let contextText: String
    let onComplete: (HighlightEvent) -> Void
    @State private var comment = ""
    @State private var isPublic = true
    @State private var showSuccess = false
    @Environment(\.dismiss) private var dismiss
    @EnvironmentObject var appState: AppState
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(alignment: .leading, spacing: .ds.large) {
                    // Selected text preview
                    VStack(alignment: .leading, spacing: .ds.base) {
                        Label("Selected Text", systemImage: "text.quote")
                            .font(.ds.footnoteMedium)
                            .foregroundColor(.ds.primary)
                        Text("\"\(selectedText)\"")
                            .font(.system(size: 18, weight: .regular, design: .serif))
                            .italic()
                            .foregroundColor(.ds.text)
                            .padding()
                            .frame(maxWidth: .infinity, alignment: .leading)
                            .background(
                                RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                                    .fill(DesignSystem.Colors.highlightSubtle)
                                    .overlay(
                                        RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                                            .stroke(DesignSystem.Colors.secondary.opacity(0.3), lineWidth: 1)
                                    )
                            )
                    }
                    .premiumEntrance(delay: 0.1)
                    // Comment field
                    VStack(alignment: .leading, spacing: .ds.base) {
                        Label("Add Your Thoughts", systemImage: "bubble.left")
                            .font(.ds.footnoteMedium)
                            .foregroundColor(.ds.primary)
                        TextField("What makes this passage special?", text: $comment, axis: .vertical)
                            .textFieldStyle(PlainTextFieldStyle())
                            .font(.ds.body)
                            .lineLimit(4...8)
                            .padding()
                            .background(
                                RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                                    .fill(DesignSystem.Colors.surface)
                                    .overlay(
                                        RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                                            .stroke(DesignSystem.Colors.border, lineWidth: 1)
                                    )
                            )
                    }
                    .premiumEntrance(delay: 0.2)
                    // Privacy toggle
                    HStack {
                        Label(isPublic ? "Public Highlight" : "Private Highlight", 
                              systemImage: isPublic ? "globe" : "lock")
                            .font(.ds.footnoteMedium)
                            .foregroundColor(.ds.text)
                        Spacer()
                        Toggle("", isOn: $isPublic)
                            .tint(.ds.primary)
                    }
                    .padding()
                    .background(
                        RoundedRectangle(cornerRadius: .ds.medium, style: .continuous)
                            .fill(DesignSystem.Colors.surface)
                    )
                    .premiumEntrance(delay: 0.3)
                    Spacer()
                }
                .padding()
            }
            .navigationTitle("Create Highlight")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button(action: saveHighlight) {
                        if showSuccess {
                            Image(systemName: "checkmark.circle.fill")
                                .foregroundColor(.ds.success)
                                .transition(.scale.combined(with: .opacity))
                        } else {
                            Text("Save")
                                .fontWeight(.medium)
                        }
                    }
                    .disabled(showSuccess)
                }
            }
        }
    }
    private func saveHighlight() {
        withAnimation(.spring(response: 0.3)) {
            showSuccess = true
        }
        // For now, create highlight without author - it will be set when published
        let highlight = HighlightEvent(
            content: selectedText,
            context: contextText,
            comment: comment.isEmpty ? nil : comment
        )
        onComplete(highlight)
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            dismiss()
        }
    }
}
struct ReadingSettingsView: View {
    @Binding var fontScale: CGFloat
    @Binding var highlightOpacity: Double
    var body: some View {
        NavigationStack {
            VStack(spacing: .ds.large) {
                // Font size control
                VStack(alignment: .leading, spacing: .ds.base) {
                    Text("Text Size")
                        .font(.ds.footnoteMedium)
                        .foregroundColor(.ds.text)
                    HStack {
                        Image(systemName: "textformat.size.smaller")
                            .foregroundColor(.ds.textSecondary)
                        Slider(value: $fontScale, in: 0.8...1.5)
                            .tint(.ds.primary)
                        Image(systemName: "textformat.size.larger")
                            .foregroundColor(.ds.textSecondary)
                    }
                    Text("The quick brown fox jumps over the lazy dog")
                        .font(.system(size: 16 * fontScale))
                        .foregroundColor(.ds.textSecondary)
                        .padding()
                        .frame(maxWidth: .infinity)
                        .background(
                            RoundedRectangle(cornerRadius: .ds.small, style: .continuous)
                                .fill(DesignSystem.Colors.surfaceSecondary)
                        )
                }
                // Highlight opacity control
                VStack(alignment: .leading, spacing: .ds.base) {
                    Text("Highlight Visibility")
                        .font(.ds.footnoteMedium)
                        .foregroundColor(.ds.text)
                    HStack {
                        Image(systemName: "circle")
                            .foregroundColor(.ds.textSecondary)
                        Slider(value: $highlightOpacity, in: 0.1...0.5)
                            .tint(.ds.secondary)
                        Image(systemName: "circle.fill")
                            .foregroundColor(.ds.textSecondary)
                    }
                }
                Spacer()
            }
            .padding()
            .navigationTitle("Reading Settings")
            .navigationBarTitleDisplayMode(.inline)
        }
    }
}
struct ArticleHighlightDetailView: View {
    let highlight: HighlightEvent
    var body: some View {
        NavigationStack {
            VStack(alignment: .leading, spacing: .ds.large) {
                // Highlight content
                Text("\"\(highlight.content)\"")
                    .font(.system(size: 20, weight: .regular, design: .serif))
                    .italic()
                    .foregroundColor(.ds.text)
                    .padding()
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .background(
                        RoundedRectangle(cornerRadius: .ds.large, style: .continuous)
                            .fill(DesignSystem.Colors.highlightSubtle)
                    )
                if let comment = highlight.comment {
                    VStack(alignment: .leading, spacing: .ds.small) {
                        Text("Comment")
                            .font(.ds.footnoteMedium)
                            .foregroundColor(.ds.textSecondary)
                        Text(comment)
                            .font(.ds.body)
                            .foregroundColor(.ds.text)
                    }
                }
                // Author info
                HStack {
                    Circle()
                        .fill(DesignSystem.Colors.surfaceSecondary)
                        .frame(width: 40, height: 40)
                        .overlay(
                            Text(PubkeyFormatter.formatForAvatar(highlight.author))
                                .font(.ds.footnoteMedium)
                                .foregroundColor(.ds.text)
                        )
                    VStack(alignment: .leading) {
                        Text(PubkeyFormatter.formatCompact(highlight.author))
                            .font(.ds.footnoteMedium)
                            .foregroundColor(.ds.text)
                        Text(RelativeTimeFormatter.relativeTime(from: highlight.createdAt))
                            .font(.ds.caption)
                            .foregroundColor(.ds.textTertiary)
                    }
                    Spacer()
                    Button(action: {}) {
                        HStack {
                            Image(systemName: "bolt.fill")
                            Text("21")
                        }
                        .font(.ds.footnoteMedium)
                        .foregroundColor(.white)
                        .padding(.horizontal, .ds.base)
                        .padding(.vertical, .ds.small)
                        .background(
                            Capsule()
                                .fill(Color.ds.secondary)
                        )
                    }
                }
                Spacer()
            }
            .padding()
            .navigationTitle("Highlight")
            .navigationBarTitleDisplayMode(.inline)
        }
    }
}
// Add this extension if not already present
extension Array {
    subscript(safe index: Index) -> Element? {
        return indices.contains(index) ? self[index] : nil
    }
}
#Preview {
    ArticleView(article: Article(
        id: "test",
        identifier: "test-article",
        title: "The Future of Knowledge Sharing",
        summary: "Exploring how decentralized protocols are reshaping the way we share and preserve human knowledge.",
        content: """
        # The Future of Knowledge Sharing
        In an age where information flows freely yet centralized platforms control the narrative, we stand at a crossroads. The question isn't whether we need change, but how quickly we can adapt to a new paradigm.
        ## The Current Landscape
        Today's knowledge ecosystem is dominated by gatekeepers. Social media algorithms decide what we see, search engines filter our queries, and content platforms monetize our creations while retaining ownership.
        This model has served its purpose, but the cracks are showing. Censorship, data breaches, and the loss of digital sovereignty have become commonplace. We've traded convenience for control, and the price is becoming too high to bear.
        ## Enter Decentralization
        Imagine a world where your thoughts, insights, and creations belong to you. Where no single entity can silence your voice or erase your contributions. This isn't a utopian dream—it's the promise of decentralized protocols like Nostr.
        By distributing data across multiple relays and using cryptographic signatures for verification, we create a system that's both resilient and trustworthy. Your content lives on, regardless of any single point of failure.
        ## The Power of Collective Intelligence
        But decentralization is just the foundation. The real magic happens when we layer collective intelligence on top. Picture millions of minds collaborating, highlighting the best insights, and building upon each other's work.
        This is swarm intelligence in action. When readers highlight passages, they're not just bookmarking for themselves—they're signaling value to the entire network. The most resonant ideas naturally rise to the surface, creating a meritocracy of thought.
        ## Looking Ahead
        The tools we build today will shape how future generations learn, think, and create. By embracing open protocols and collective curation, we're not just preserving knowledge—we're accelerating its evolution.
        The future of knowledge sharing isn't about any single platform or technology. It's about creating systems that amplify human potential while respecting individual sovereignty. And that future is being written right now, one highlight at a time.
        """,
        author: "npub1example",
        publishedAt: Date(),
        image: "https://picsum.photos/800/400",
        hashtags: ["knowledge", "decentralization", "nostr", "future"],
        createdAt: Timestamp.now
    ))
    .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Views/Highlights/HighlightDetailView.swift">
import SwiftUI
import NDKSwift
struct HighlightDetailView: View {
    let highlight: HighlightEvent
    var body: some View {
        ImmersiveHighlightDetailView(highlight: highlight)
    }
}
struct RelatedHighlightPlaceholder: View {
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            RoundedRectangle(cornerRadius: 8)
                .fill(Color.gray.opacity(0.2))
                .frame(height: 60)
                .shimmer()
            RoundedRectangle(cornerRadius: 8)
                .fill(Color.gray.opacity(0.2))
                .frame(height: 20)
                .shimmer()
        }
        .padding()
        .background(DesignSystem.Colors.surface)
        .cornerRadius(DesignSystem.CornerRadius.medium)
    }
}
struct CompactRelatedHighlightCard: View {
    let highlight: HighlightEvent
    @EnvironmentObject var appState: AppState
    @State private var author: NDKUserProfile?
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Highlight content
            Text("\"\(String(highlight.content.prefix(100)))...\"")
                .font(DesignSystem.Typography.body)
                .foregroundColor(DesignSystem.Colors.text)
                .lineLimit(3)
                .multilineTextAlignment(.leading)
            Spacer()
            // Author info
            HStack(spacing: 8) {
                // Author avatar
                Group {
                    if let profileImage = author?.picture,
                       let url = URL(string: profileImage) {
                        AsyncImage(url: url) { image in
                            image
                                .resizable()
                                .scaledToFill()
                        } placeholder: {
                            Circle()
                                .fill(DesignSystem.Colors.primary.opacity(0.1))
                                .overlay(
                                    Image(systemName: "person.fill")
                                        .foregroundColor(DesignSystem.Colors.primary.opacity(0.5))
                                )
                        }
                    } else {
                        Circle()
                            .fill(DesignSystem.Colors.primary.opacity(0.1))
                            .overlay(
                                Image(systemName: "person.fill")
                                    .foregroundColor(DesignSystem.Colors.primary.opacity(0.5))
                            )
                    }
                }
                .frame(width: 24, height: 24)
                .clipShape(Circle())
                VStack(alignment: .leading, spacing: 2) {
                    Text(author?.name ?? author?.displayName ?? "Anonymous")
                        .font(DesignSystem.Typography.caption)
                        .fontWeight(.medium)
                        .foregroundColor(DesignSystem.Colors.text)
                        .lineLimit(1)
                    Text(RelativeTimeFormatter.shortRelativeTime(from: highlight.createdAt))
                        .font(.caption2)
                        .foregroundColor(DesignSystem.Colors.textSecondary)
                }
                Spacer()
            }
        }
        .padding()
        .frame(height: 140)
        .background(DesignSystem.Colors.surface)
        .cornerRadius(DesignSystem.CornerRadius.medium)
        .overlay(
            RoundedRectangle(cornerRadius: DesignSystem.CornerRadius.medium)
                .stroke(DesignSystem.Colors.border, lineWidth: 0.5)
        )
        .shadow(color: DesignSystem.Shadow.subtle.color, radius: DesignSystem.Shadow.subtle.radius)
        .task {
            await loadAuthorProfile()
        }
    }
    private func loadAuthorProfile() async {
        guard let ndk = appState.ndk else { return }
        for await profile in await ndk.profileManager.observe(for: highlight.author, maxAge: TimeConstants.hour) {
            await MainActor.run {
                self.author = profile
            }
            break
        }
    }
}
struct ReplyComposerView: View {
    let highlight: HighlightEvent
    @Binding var replyText: String
    @Environment(\.dismiss) var dismiss
    @EnvironmentObject var appState: AppState
    @State private var isPublishing = false
    var body: some View {
        NavigationStack {
            VStack(spacing: 16) {
                // Quote preview
                Text("\"\(String(highlight.content.prefix(100)))...\"")
                    .font(DesignSystem.Typography.caption)
                    .foregroundColor(DesignSystem.Colors.textSecondary)
                    .padding()
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .background(DesignSystem.Colors.surface)
                    .cornerRadius(8)
                    .padding(.horizontal)
                // Reply input
                TextEditor(text: $replyText)
                    .font(DesignSystem.Typography.body)
                    .padding(8)
                    .background(DesignSystem.Colors.surface)
                    .cornerRadius(8)
                    .padding(.horizontal)
                Spacer()
            }
            .padding(.top)
            .navigationTitle("Reply")
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarLeading) {
                    Button("Cancel") {
                        dismiss()
                    }
                }
                ToolbarItem(placement: .navigationBarTrailing) {
                    Button("Send") {
                        sendReply()
                    }
                    .disabled(replyText.isEmpty || isPublishing)
                }
            }
        }
    }
    private func sendReply() {
        isPublishing = true
        HapticManager.shared.impact(.light)
        // Note: Reply functionality would create a new event referencing this highlight
        // This demo focuses on core highlight features
        dismiss()
    }
}
struct ShareSheet: UIViewControllerRepresentable {
    let items: [Any]
    func makeUIViewController(context: Context) -> UIActivityViewController {
        UIActivityViewController(activityItems: items, applicationActivities: nil)
    }
    func updateUIViewController(_ uiViewController: UIActivityViewController, context: Context) {}
}
#Preview {
    HighlightDetailView(
        highlight: HighlightEvent(
            id: "1",
            event: NDKEvent(id: "", pubkey: "", createdAt: 0, kind: 9802, tags: [], content: "", sig: ""),
            content: PreviewData.highlightTexts[2],
            author: "npub1sg6plzptd64u62a878hep2kev88swjh3tw00gjsfl8f237lmu63q0uf63m",
            createdAt: Date(),
            context: PreviewData.highlightContexts[2],
            url: PreviewData.articleURLs[2],
            referencedEvent: nil,
            attributedAuthors: [],
            comment: "The future of value exchange is fascinating"
        )
    )
    .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Views/Library/LibraryView.swift">
import SwiftUI
import NDKSwift
struct LibraryView: View {
    @EnvironmentObject var appState: AppState
    @State private var showCreateCuration = false
    @State private var selectedCuration: ArticleCuration?
    @State private var selectedFollowPack: FollowPack?
    @State private var showCurationManagement = false
    @State private var selectedFilter = FilterTab.all
    @State private var searchText = ""
    @State private var showStats = true
    @State private var animateGradient = false
    enum FilterTab: String, CaseIterable {
        case all = "All"
        case highlights = "Highlights"
        case curations = "Collections"
        case articles = "Articles"
        var icon: String {
            switch self {
            case .all: return "square.grid.2x2"
            case .highlights: return "highlighter"
            case .curations: return "folder.fill"
            case .articles: return "doc.text.fill"
            }
        }
    }
    var body: some View {
        NavigationStack {
            ZStack {
                // Animated gradient background
                LinearGradient(
                    colors: [
                        Color.ds.primary.opacity(0.05),
                        Color.ds.secondary.opacity(0.03),
                        Color.clear
                    ],
                    startPoint: animateGradient ? .topLeading : .bottomTrailing,
                    endPoint: animateGradient ? .bottomTrailing : .topLeading
                )
                .ignoresSafeArea()
                .animation(.easeInOut(duration: 10).repeatForever(autoreverses: true), value: animateGradient)
                ScrollView {
                    VStack(spacing: 0) {
                        // Stats header
                        if showStats {
                            LibraryStatsCard()
                                .padding(.horizontal)
                                .padding(.top)
                                .transition(.asymmetric(
                                    insertion: .push(from: .top).combined(with: .opacity),
                                    removal: .push(from: .bottom).combined(with: .opacity)
                                ))
                        }
                        // Filter tabs
                        ScrollView(.horizontal, showsIndicators: false) {
                            HStack(spacing: DesignSystem.Spacing.base) {
                                ForEach(FilterTab.allCases, id: \.self) { tab in
                                    LibraryFilterChip(
                                        title: tab.rawValue,
                                        icon: tab.icon,
                                        isSelected: selectedFilter == tab
                                    ) {
                                        withAnimation(.spring(response: 0.3, dampingFraction: 0.7)) {
                                            selectedFilter = tab
                                            HapticManager.shared.impact(.light)
                                        }
                                    }
                                }
                            }
                            .padding(.horizontal)
                        }
                        .padding(.vertical)
                        // Content based on filter
                        VStack(spacing: DesignSystem.Spacing.xxl) {
                            switch selectedFilter {
                            case .all:
                                allContentView
                            case .highlights:
                                EnhancedSavedHighlightsSection()
                            case .curations:
                                EnhancedYourCurationsSection(
                                    curations: appState.userCurations,
                                    showCreateCuration: $showCreateCuration,
                                    selectedCuration: $selectedCuration,
                                    showCurationManagement: $showCurationManagement
                                )
                            case .articles:
                                SavedArticlesSection()
                            }
                        }
                        .padding(.bottom, DesignSystem.Spacing.xxl)
                    }
                }
                .refreshable {
                    await refreshLibrary()
                }
            }
            .navigationTitle("Library")
            .navigationBarTitleDisplayMode(.large)
            .searchable(text: $searchText, prompt: "Search your library")
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Menu {
                        Button(action: { 
                            withAnimation {
                                showStats.toggle()
                            }
                        }) {
                            Label(showStats ? "Hide Stats" : "Show Stats", systemImage: "chart.bar")
                        }
                        Button(action: { 
                            // Sort feature removed for now - needs implementation
                        }) {
                            Label("Sort by Date", systemImage: "arrow.up.arrow.down")
                        }
                        .disabled(true)
                        Button(action: { 
                            // Export feature removed for now - needs implementation
                        }) {
                            Label("Export Library", systemImage: "square.and.arrow.up")
                        }
                        .disabled(true)
                    } label: {
                        Image(systemName: "ellipsis.circle")
                            .font(.system(size: 18))
                            .foregroundColor(.ds.text)
                            .frame(width: 44, height: 44)
                    }
                }
            }
        }
        .onAppear {
            animateGradient = true
        }
        .sheet(isPresented: $showCreateCuration) {
            CreateCurationView()
                .environmentObject(appState)
        }
        .sheet(item: $selectedCuration) { curation in
            CurationDetailView(curation: curation)
                .environmentObject(appState)
        }
        .sheet(item: $selectedFollowPack) { followPack in
            FollowPackDetailView(followPack: followPack)
                .environmentObject(appState)
        }
        .sheet(isPresented: $showCurationManagement) {
            CurationManagementView()
                .environmentObject(appState)
        }
    }
    private func refreshLibrary() async {
        // Haptic feedback for pull-to-refresh
        await MainActor.run {
            HapticManager.shared.impact(.medium)
        }
        // Reload highlights from network
        await loadHighlights()
        // Refresh other content types
        await loadCurations()
        await loadArticles()
        // Update activity feed
        await loadActivity()
        await MainActor.run {
            // Force UI update after refresh
            showStats = false
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                withAnimation(.spring(response: 0.5, dampingFraction: 0.8)) {
                    self.showStats = true
                }
            }
        }
    }
    private func loadHighlights() async {
        guard let ndk = appState.ndk,
              let signer = appState.activeSigner else { return }
        do {
            let pubkey = try await signer.pubkey
            let filter = NDKFilter(
                authors: [pubkey],
                kinds: [9802], // NIP-84 highlights
                limit: 100
            )
            let dataSource = await ndk.outbox.observe(
                filter: filter,
                maxAge: 300 // 5 minute cache
            )
            var highlights: [HighlightEvent] = []
            for await event in dataSource.events {
                if let highlight = try? HighlightEvent(from: event) {
                    highlights.append(highlight)
                }
            }
            await MainActor.run {
                appState.highlights = highlights.sorted { $0.createdAt > $1.createdAt }
            }
        } catch {
        }
    }
    private func loadCurations() async {
        guard let ndk = appState.ndk,
              let signer = appState.activeSigner else { return }
        do {
            let pubkey = try await signer.pubkey
            let filter = NDKFilter(
                authors: [pubkey],
                kinds: [30004], // Article curations
                limit: 50
            )
            let dataSource = await ndk.outbox.observe(
                filter: filter,
                maxAge: 300 // 5 minute cache
            )
            var curations: [ArticleCuration] = []
            for await event in dataSource.events {
                if let curation = try? ArticleCuration(from: event) {
                    curations.append(curation)
                }
            }
            await MainActor.run {
                appState.userCurations = curations.sorted { $0.createdAt > $1.createdAt }
            }
        } catch {
        }
    }
    private func loadArticles() async {
        guard let ndk = appState.ndk,
              let signer = appState.activeSigner else { return }
        do {
            let pubkey = try await signer.pubkey
            let filter = NDKFilter(
                authors: [pubkey],
                kinds: [30023], // Long-form articles
                limit: 50
            )
            let dataSource = await ndk.outbox.observe(
                filter: filter,
                maxAge: 300 // 5 minute cache
            )
            var articles: [Article] = []
            for await event in dataSource.events {
                if let article = try? Article(from: event) {
                    articles.append(article)
                }
            }
            await MainActor.run {
                appState.savedArticles = articles.sorted { $0.createdAt > $1.createdAt }
            }
        } catch {
        }
    }
    private func loadActivity() async {
        // Activity is loaded in RecentActivitySection component
        // This method can be used for additional activity loading if needed
    }
    @ViewBuilder
    private var allContentView: some View {
        VStack(spacing: DesignSystem.Spacing.xxl) {
            // Recent Activity
            RecentActivitySection()
            // Saved highlights
            EnhancedSavedHighlightsSection()
            // Your curations
            EnhancedYourCurationsSection(
                curations: appState.userCurations,
                showCreateCuration: $showCreateCuration,
                selectedCuration: $selectedCuration,
                showCurationManagement: $showCurationManagement
            )
            // Follow packs
            EnhancedFollowPacksSection(
                followPacks: appState.followPacks,
                selectedFollowPack: $selectedFollowPack
            )
        }
    }
}
// MARK: - New Components
struct LibraryStatsCard: View {
    @EnvironmentObject var appState: AppState
    @State private var animateStats = false
    var body: some View {
        VStack(spacing: DesignSystem.Spacing.large) {
            HStack {
                Text("Your Library")
                    .font(.system(size: 28, weight: .bold, design: .rounded))
                    .foregroundColor(.ds.text)
                Spacer()
                // Activity indicator - removed hardcoded streak
                if appState.highlights.count > 0 {
                    HStack(spacing: DesignSystem.Spacing.mini) {
                        Image(systemName: "sparkles")
                            .font(.system(size: 16))
                            .foregroundColor(.ds.primary)
                        Text("Active")
                            .font(.system(size: 14, weight: .medium))
                            .foregroundColor(.ds.primary)
                    }
                    .padding(.horizontal, DesignSystem.Spacing.base)
                    .padding(.vertical, DesignSystem.Spacing.mini)
                    .background(
                        Capsule()
                            .fill(Color.ds.primary.opacity(0.15))
                    )
                    .transition(.scale.combined(with: .opacity))
                }
            }
            // Stats grid
            LazyVGrid(columns: [GridItem(.flexible()), GridItem(.flexible()), GridItem(.flexible())], spacing: 16) {
                LibraryStatCard(
                    value: "\(appState.highlights.count)",
                    label: "Highlights",
                    icon: "highlighter",
                    color: .ds.primary,
                    animate: $animateStats
                )
                LibraryStatCard(
                    value: "\(appState.curations.count)",
                    label: "Collections",
                    icon: "folder.fill",
                    color: .purple,
                    animate: $animateStats
                )
                LibraryStatCard(
                    value: "\(appState.savedArticles.count)",
                    label: "Articles",
                    icon: "doc.text.fill",
                    color: .blue,
                    animate: $animateStats
                )
            }
        }
        .padding(DesignSystem.Spacing.xl)
        .background(
            RoundedRectangle(cornerRadius: 24, style: .continuous)
                .fill(
                    LinearGradient(
                        colors: [
                            Color.ds.surfaceSecondary,
                            Color.ds.surface
                        ],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .shadow(color: Color.black.opacity(0.05), radius: 20, y: 10)
        )
        .onAppear {
            withAnimation(.spring(response: 0.6, dampingFraction: 0.8).delay(0.2)) {
                animateStats = true
            }
        }
    }
}
struct LibraryStatCard: View {
    let value: String
    let label: String
    let icon: String
    let color: Color
    @Binding var animate: Bool
    var body: some View {
        VStack(spacing: 12) {
            ZStack {
                Circle()
                    .fill(color.opacity(0.15))
                    .frame(width: 56, height: 56)
                Image(systemName: icon)
                    .font(.system(size: 24, weight: .semibold))
                    .foregroundColor(color)
                    .scaleEffect(animate ? 1 : 0.5)
                    .opacity(animate ? 1 : 0)
            }
            VStack(spacing: 4) {
                Text(value)
                    .font(.system(size: 24, weight: .bold, design: .rounded))
                    .foregroundColor(.ds.text)
                Text(label)
                    .font(.system(size: 12, weight: .medium))
                    .foregroundColor(.ds.textSecondary)
            }
        }
        .frame(maxWidth: .infinity)
    }
}
struct LibraryFilterChip: View {
    let title: String
    let icon: String
    let isSelected: Bool
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            HStack(spacing: DesignSystem.Spacing.small) {
                Image(systemName: icon)
                    .font(.system(size: 16, weight: .medium))
                Text(title)
                    .font(.system(size: 15, weight: .medium))
            }
            .foregroundColor(isSelected ? .white : .ds.text)
            .padding(.horizontal, DesignSystem.Spacing.medium)
            .padding(.vertical, DesignSystem.Spacing.small + DesignSystem.Spacing.nano)
            .background(
                Capsule()
                    .fill(isSelected ? Color.ds.primary : Color.ds.surfaceSecondary)
            )
            .overlay(
                Capsule()
                    .strokeBorder(isSelected ? Color.clear : Color.ds.divider, lineWidth: 1)
            )
        }
        .scaleEffect(isSelected ? 1.05 : 1)
        .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isSelected)
    }
}
struct RecentActivitySection: View {
    @EnvironmentObject var appState: AppState
    @State private var activities: [ActivityItem] = []
    struct ActivityItem: Identifiable {
        let id = UUID()
        let type: ActivityType
        let title: String
        let time: Date
        enum ActivityType {
            case highlight, curation, article, zap
            var icon: String {
                switch self {
                case .highlight: return "highlighter"
                case .curation: return "folder.badge.plus"
                case .article: return "doc.text"
                case .zap: return "bolt.fill"
                }
            }
            var color: Color {
                switch self {
                case .highlight: return .ds.primary
                case .curation: return .purple
                case .article: return .blue
                case .zap: return .orange
                }
            }
        }
    }
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            HStack {
                Label("Recent Activity", systemImage: "clock.arrow.circlepath")
                    .font(.system(size: 20, weight: .bold, design: .rounded))
                    .foregroundColor(.ds.text)
                Spacer()
                Button(action: {}) {
                    Text("View All")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(.ds.primary)
                }
            }
            .padding(.horizontal)
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: DesignSystem.Spacing.medium) {
                    ForEach(activities) { activity in
                        ActivityCard(activity: activity)
                    }
                }
                .padding(.horizontal)
            }
        }
        .onAppear {
            loadRecentActivities()
        }
    }
    private func loadRecentActivities() {
        Task {
            guard let ndk = appState.ndk,
                  let signer = appState.activeSigner else { return }
            do {
                let pubkey = try await signer.pubkey
                let since = Date().addingTimeInterval(-24 * 60 * 60) // Last 24 hours
                // Fetch recent activities from the user
                let filter = NDKFilter(
                    authors: [pubkey],
                    kinds: [7, 9735, 9802, 30004, 30023], // reactions, zaps, highlights, curations, articles
                    since: Int64(since.timeIntervalSince1970),
                    limit: 20
                )
                let dataSource = await ndk.outbox.observe(filter: filter)
                var events: [NDKEvent] = []
                for await event in dataSource.events {
                    events.append(event)
                }
                var newActivities: [ActivityItem] = []
                for event in events.sorted(by: { $0.createdAt > $1.createdAt }).prefix(10) {
                    switch event.kind {
                    case 7: // Reaction
                        newActivities.append(ActivityItem(
                            type: .zap,
                            title: "Reacted to content",
                            time: Date(timeIntervalSince1970: TimeInterval(event.createdAt))
                        ))
                    case 9735: // Zap
                        let amount = extractZapAmount(from: event) ?? 0
                        newActivities.append(ActivityItem(
                            type: .zap,
                            title: "Zapped \(amount) sats",
                            time: Date(timeIntervalSince1970: TimeInterval(event.createdAt))
                        ))
                    case 9802: // Highlight
                        let preview = String(event.content.prefix(50))
                        newActivities.append(ActivityItem(
                            type: .highlight,
                            title: "Highlighted: \"\(preview)...\"",
                            time: Date(timeIntervalSince1970: TimeInterval(event.createdAt))
                        ))
                    case 30004: // Curation
                        if let name = event.tags.first(where: { $0.first == "name" })?.dropFirst().first {
                            newActivities.append(ActivityItem(
                                type: .curation,
                                title: "Created '\(name)'",
                                time: Date(timeIntervalSince1970: TimeInterval(event.createdAt))
                            ))
                        }
                    case 30023: // Article
                        if let title = event.tags.first(where: { $0.first == "title" })?.dropFirst().first {
                            newActivities.append(ActivityItem(
                                type: .article,
                                title: "Saved '\(title)'",
                                time: Date(timeIntervalSince1970: TimeInterval(event.createdAt))
                            ))
                        }
                    default:
                        break
                    }
                }
                await MainActor.run {
                    activities = newActivities
                }
            } catch {
                // Keep empty activities on error
            }
        }
    }
    private func extractZapAmount(from event: NDKEvent) -> Int? {
        // Extract zap amount from bolt11 tag
        if let bolt11Tag = event.tags.first(where: { $0.first == "bolt11" && $0.count > 1 }),
           bolt11Tag.count > 1 {
            let bolt11 = bolt11Tag[1]
            // Simple extraction - in production, use proper Lightning invoice parsing
            if let range = bolt11.range(of: "lnbc"),
               let endRange = bolt11.range(of: "1p", range: range.upperBound..<bolt11.endIndex) {
                let amountString = String(bolt11[range.upperBound..<endRange.lowerBound])
                if let amount = Int(amountString) {
                    return amount / 1000 // Convert millisats to sats
                }
            }
        }
        return nil
    }
}
struct ActivityCard: View {
    let activity: RecentActivitySection.ActivityItem
    var body: some View {
        HStack(spacing: DesignSystem.Spacing.base) {
            ZStack {
                Circle()
                    .fill(activity.type.color.opacity(0.15))
                    .frame(width: 44, height: 44)
                Image(systemName: activity.type.icon)
                    .font(.system(size: 20, weight: .medium))
                    .foregroundColor(activity.type.color)
            }
            VStack(alignment: .leading, spacing: 4) {
                Text(activity.title)
                    .font(.system(size: 14, weight: .medium))
                    .foregroundColor(.ds.text)
                    .lineLimit(1)
                Text(RelativeTimeFormatter.shortRelativeTime(from: activity.time))
                    .font(.system(size: 12))
                    .foregroundColor(.ds.textSecondary)
            }
        }
        .padding(DesignSystem.Spacing.medium)
        .frame(width: 260)
        .background(
            RoundedRectangle(cornerRadius: 16, style: .continuous)
                .fill(Color.ds.surfaceSecondary)
        )
    }
}
struct EnhancedSavedHighlightsSection: View {
    @EnvironmentObject var appState: AppState
    @State private var showAllHighlights = false
    @State private var selectedSortOption = SortOption.recent
    enum SortOption: String, CaseIterable {
        case recent = "Recent"
        case popular = "Popular"
        case alphabetical = "A-Z"
    }
    var body: some View {
        VStack(alignment: .leading, spacing: 20) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text("Your Highlights")
                        .font(.system(size: 24, weight: .bold, design: .rounded))
                        .foregroundColor(.ds.text)
                    Text("\(appState.highlights.count) highlights saved")
                        .font(.system(size: 14))
                        .foregroundColor(.ds.textSecondary)
                }
                Spacer()
                Menu {
                    ForEach(SortOption.allCases, id: \.self) { option in
                        Button(action: { selectedSortOption = option }) {
                            Label(option.rawValue, systemImage: selectedSortOption == option ? "checkmark" : "")
                        }
                    }
                } label: {
                    HStack(spacing: DesignSystem.Spacing.mini) {
                        Text(selectedSortOption.rawValue)
                            .font(.system(size: 14, weight: .medium))
                        Image(systemName: "chevron.down")
                            .font(.system(size: 12))
                    }
                    .foregroundColor(.ds.primary)
                    .padding(.horizontal, DesignSystem.Spacing.base)
                    .padding(.vertical, DesignSystem.Spacing.mini)
                    .background(
                        Capsule()
                            .fill(Color.ds.primary.opacity(0.1))
                    )
                }
            }
            .padding(.horizontal)
            if appState.highlights.isEmpty {
                ModernEmptyState(
                    icon: "highlighter",
                    title: "No highlights yet",
                    message: "Start highlighting content to build your collection",
                    action: {},
                    actionTitle: "Create Highlight"
                )
                .padding(.horizontal)
            } else {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: DesignSystem.Spacing.medium) {
                        ForEach(appState.highlights.prefix(10)) { highlight in
                            LibraryHighlightCard(highlight: highlight)
                        }
                        if appState.highlights.count > 10 {
                            ViewAllCard(count: appState.highlights.count - 10) {
                                showAllHighlights = true
                            }
                        }
                    }
                    .padding(.horizontal)
                }
            }
        }
    }
}
struct LibraryHighlightCard: View {
    let highlight: HighlightEvent
    @State private var showDetail = false
    @State private var isBookmarked = false
    var body: some View {
        Button(action: { showDetail = true }) {
            VStack(alignment: .leading, spacing: 12) {
                // Header with source
                if let url = highlight.url {
                    HStack(spacing: DesignSystem.Spacing.small) {
                        Image(systemName: "link.circle.fill")
                            .font(.system(size: 14))
                            .foregroundColor(.ds.primary)
                        Text(ContentFormatter.extractDomain(from: url))
                            .font(.system(size: 12, weight: .medium))
                            .foregroundColor(.ds.primary)
                        Spacer()
                        Button(action: {
                            isBookmarked.toggle()
                            HapticManager.shared.impact(.light)
                        }) {
                            Image(systemName: isBookmarked ? "bookmark.fill" : "bookmark")
                                .font(.system(size: 14))
                                .foregroundColor(isBookmarked ? .ds.primary : .ds.textTertiary)
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                }
                // Quote
                Text("\"\(highlight.content)\"")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(.ds.text)
                    .lineLimit(4)
                    .multilineTextAlignment(.leading)
                Spacer()
                // Footer
                HStack {
                    Text(RelativeTimeFormatter.relativeTime(from: highlight.createdAt))
                        .font(.system(size: 12))
                        .foregroundColor(.ds.textSecondary)
                    Spacer()
                    HStack(spacing: DesignSystem.Spacing.micro) {
                        Image(systemName: "arrow.right.circle")
                            .font(.system(size: 16))
                        Text("View")
                            .font(.system(size: 12, weight: .medium))
                    }
                    .foregroundColor(.ds.primary)
                }
            }
            .padding(DesignSystem.Spacing.large)
            .frame(width: 280, height: 180)
            .background(
                RoundedRectangle(cornerRadius: 20, style: .continuous)
                    .fill(
                        LinearGradient(
                            colors: [
                                Color.ds.surface,
                                Color.ds.surfaceSecondary
                            ],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
            )
            .overlay(
                RoundedRectangle(cornerRadius: 20, style: .continuous)
                    .strokeBorder(Color.ds.divider, lineWidth: 1)
            )
            .shadow(color: Color.black.opacity(0.05), radius: 10, y: 5)
        }
        .buttonStyle(PlainButtonStyle())
        .sheet(isPresented: $showDetail) {
            HighlightDetailView(highlight: highlight)
        }
    }
}
struct ViewAllCard: View {
    let count: Int
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            VStack(spacing: DesignSystem.Spacing.medium) {
                ZStack {
                    Circle()
                        .fill(Color.ds.primary.opacity(0.1))
                        .frame(width: 64, height: 64)
                    Image(systemName: "arrow.right.circle.fill")
                        .font(.system(size: 32))
                        .foregroundColor(.ds.primary)
                }
                VStack(spacing: 4) {
                    Text("View All")
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundColor(.ds.text)
                    Text("+\(count) more")
                        .font(.system(size: 14))
                        .foregroundColor(.ds.textSecondary)
                }
            }
            .frame(width: 140, height: 180)
            .background(
                RoundedRectangle(cornerRadius: 20, style: .continuous)
                    .fill(Color.ds.surfaceSecondary)
                    .overlay(
                        RoundedRectangle(cornerRadius: 20, style: .continuous)
                            .strokeBorder(
                                style: StrokeStyle(lineWidth: 2, dash: [8])
                            )
                            .foregroundColor(.ds.primary.opacity(0.3))
                    )
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}
struct SavedArticlesSection: View {
    @EnvironmentObject var appState: AppState
    @State private var highlightCounts: [String: Int] = [:]
    var body: some View {
        VStack(alignment: .leading, spacing: 20) {
            Text("Saved Articles")
                .font(.system(size: 24, weight: .bold, design: .rounded))
                .foregroundColor(.ds.text)
                .padding(.horizontal)
            if appState.savedArticles.isEmpty {
                ModernEmptyState(
                    icon: "doc.text.fill",
                    title: "No saved articles yet",
                    message: "Save articles to read them later",
                    action: {},
                    actionTitle: "Discover Articles"
                )
                .padding(.horizontal)
            } else {
                LazyVStack(spacing: DesignSystem.Spacing.medium) {
                    ForEach(appState.savedArticles) { article in
                        ArticleRow(
                            article: article,
                            highlightCount: highlightCounts[article.id] ?? 0
                        )
                    }
                }
                .padding(.horizontal)
            }
        }
        .onAppear {
            loadHighlightCounts()
        }
    }
    private func loadHighlightCounts() {
        Task {
            guard let ndk = appState.ndk else { return }
            for article in appState.savedArticles {
                let filter = NDKFilter(
                    kinds: [9802],
                    limit: 100,
                    tags: ["a": ["30023:\(article.author):\(article.identifier)"]]
                )
                let dataSource = await ndk.outbox.observe(
                    filter: filter,
                    maxAge: 300,
                    cachePolicy: .cacheOnly
                )
                var count = 0
                for await _ in dataSource.events {
                    count += 1
                }
                await MainActor.run {
                    highlightCounts[article.id] = count
                }
            }
        }
    }
}
struct ArticleRow: View {
    let article: Article
    let highlightCount: Int
    @State private var showArticleDetail = false
    @EnvironmentObject var appState: AppState
    private var readingProgress: ReadingProgressService.ArticleProgress? {
        appState.readingProgressService.getProgress(for: article.id)
    }
    var body: some View {
        Button(action: { showArticleDetail = true }) {
            HStack(spacing: DesignSystem.Spacing.medium) {
                // Article image or gradient
                Group {
                    if let imageUrl = article.image, let url = URL(string: imageUrl) {
                        AsyncImage(url: url) { image in
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                        } placeholder: {
                            ArticleImagePlaceholder()
                        }
                        .frame(width: 80, height: 80)
                        .clipped()
                        .cornerRadius(12)
                    } else {
                        ArticleImagePlaceholder()
                            .frame(width: 80, height: 80)
                            .cornerRadius(12)
                    }
                }
                VStack(alignment: .leading, spacing: 8) {
                    Text(article.title)
                        .font(.system(size: 16, weight: .semibold))
                        .foregroundColor(.ds.text)
                        .lineLimit(2)
                        .multilineTextAlignment(.leading)
                    if let summary = article.summary {
                        Text(summary)
                            .font(.system(size: 14))
                            .foregroundColor(.ds.textSecondary)
                            .lineLimit(1)
                    }
                    HStack(spacing: DesignSystem.Spacing.medium) {
                        if let readingTime = ArticleTimeEstimator.estimateReadingTime(for: article.content) {
                            Label("\(readingTime) min read", systemImage: "clock")
                                .font(.system(size: 12))
                                .foregroundColor(.ds.textTertiary)
                        }
                        // Reading progress
                        if let progress = readingProgress, progress.progress > 0 {
                            HStack(spacing: 4) {
                                Image(systemName: progress.progress >= 1.0 ? "checkmark.circle.fill" : "book.fill")
                                    .font(.system(size: 11))
                                    .foregroundColor(progress.progress >= 1.0 ? .green : .ds.primary)
                                Text(progress.progress >= 1.0 ? "Completed" : "\(Int(progress.progress * 100))%")
                                    .font(.system(size: 12, weight: .medium))
                                    .foregroundColor(progress.progress >= 1.0 ? .green : .ds.primary)
                            }
                        }
                        Label(highlightCount > 0 ? "\(highlightCount) highlights" : "No highlights", 
                              systemImage: "highlighter")
                            .font(.system(size: 12))
                            .foregroundColor(highlightCount > 0 ? .ds.primary : .ds.textTertiary)
                    }
                }
                Spacer()
            }
            .padding(DesignSystem.Spacing.medium)
            .background(
                RoundedRectangle(cornerRadius: 16, style: .continuous)
                    .fill(Color.ds.surface)
            )
            .overlay(
                RoundedRectangle(cornerRadius: 16, style: .continuous)
                    .strokeBorder(Color.ds.divider, lineWidth: 1)
            )
            .overlay(
                // Reading progress bar at the bottom
                GeometryReader { geometry in
                    if let progress = readingProgress, progress.progress > 0 && progress.progress < 1.0 {
                        VStack {
                            Spacer()
                            RoundedRectangle(cornerRadius: 8)
                                .fill(
                                    LinearGradient(
                                        colors: [DesignSystem.Colors.primary, DesignSystem.Colors.secondary],
                                        startPoint: .leading,
                                        endPoint: .trailing
                                    )
                                )
                                .frame(width: geometry.size.width * progress.progress, height: 3)
                                .frame(maxWidth: .infinity, alignment: .leading)
                                .animation(.spring(response: 0.3), value: progress.progress)
                        }
                        .padding(.horizontal, 16)
                        .padding(.bottom, 2)
                    }
                }
                .allowsHitTesting(false)
            )
        }
        .buttonStyle(PlainButtonStyle())
        .sheet(isPresented: $showArticleDetail) {
            ArticleView(article: article)
        }
    }
}
struct ArticleImagePlaceholder: View {
    var body: some View {
        LinearGradient(
            colors: [
                Color.blue.opacity(0.3),
                Color.purple.opacity(0.3)
            ],
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
    }
}
struct EnhancedYourCurationsSection: View {
    let curations: [ArticleCuration]
    @Binding var showCreateCuration: Bool
    @Binding var selectedCuration: ArticleCuration?
    @Binding var showCurationManagement: Bool
    @State private var animateCards = false
    var body: some View {
        VStack(alignment: .leading, spacing: 20) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text("Your Collections")
                        .font(.system(size: 24, weight: .bold, design: .rounded))
                        .foregroundColor(.ds.text)
                    Text("\(curations.count) curated collections")
                        .font(.system(size: 14))
                        .foregroundColor(.ds.textSecondary)
                }
                Spacer()
                HStack(spacing: DesignSystem.Spacing.base) {
                    if !curations.isEmpty {
                        Button(action: { showCurationManagement = true }) {
                            Image(systemName: "folder.badge.gearshape")
                                .font(.system(size: 16))
                                .foregroundColor(.purple)
                                .frame(width: 36, height: 36)
                                .background(
                                    Circle()
                                        .fill(Color.purple.opacity(0.1))
                                )
                        }
                        .transition(.scale.combined(with: .opacity))
                    }
                    Button(action: { showCreateCuration = true }) {
                        Image(systemName: "plus.circle.fill")
                            .font(.system(size: 32))
                            .foregroundStyle(
                                LinearGradient(
                                    colors: [.purple, .purple.opacity(0.8)],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .background(
                                Circle()
                                    .fill(Color.white)
                                    .frame(width: 28, height: 28)
                            )
                            .symbolEffect(.bounce, value: showCreateCuration)
                    }
                }
            }
            .padding(.horizontal)
            .animation(.spring(response: 0.3, dampingFraction: 0.7), value: curations.isEmpty)
            if curations.isEmpty {
                ModernEmptyState(
                    icon: "folder.badge.plus",
                    title: "No collections yet",
                    message: "Create curated collections of your favorite articles",
                    action: { showCreateCuration = true },
                    actionTitle: "Create First Collection"
                )
                .padding(.horizontal)
            } else {
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack(spacing: DesignSystem.Spacing.medium) {
                        ForEach(Array(curations.enumerated()), id: \.element.id) { index, curation in
                            EnhancedCurationCard(curation: curation)
                                .onTapGesture {
                                    selectedCuration = curation
                                    HapticManager.shared.impact(.light)
                                }
                                .scaleEffect(animateCards ? 1 : 0.8)
                                .opacity(animateCards ? 1 : 0)
                                .animation(
                                    .spring(response: 0.4, dampingFraction: 0.8)
                                    .delay(Double(index) * 0.1),
                                    value: animateCards
                                )
                        }
                        CreateCurationCard {
                            showCreateCuration = true
                        }
                    }
                    .padding(.horizontal)
                }
                .onAppear {
                    animateCards = true
                }
            }
        }
    }
}
struct EnhancedCurationCard: View {
    let curation: ArticleCuration
    @State private var isPressed = false
    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Image or gradient header
            ZStack(alignment: .topTrailing) {
                if let imageUrl = curation.image, let url = URL(string: imageUrl) {
                    AsyncImage(url: url) { image in
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                    } placeholder: {
                        GradientPlaceholder()
                    }
                    .frame(height: 140)
                    .clipped()
                } else {
                    GradientPlaceholder()
                        .frame(height: 140)
                }
                // Article count badge
                HStack(spacing: DesignSystem.Spacing.micro) {
                    Image(systemName: "doc.stack.fill")
                        .font(.system(size: 12))
                    Text("\(curation.articles.count)")
                        .font(.system(size: 14, weight: .bold))
                }
                .foregroundColor(.white)
                .padding(.horizontal, DesignSystem.Spacing.base)
                .padding(.vertical, DesignSystem.Spacing.mini)
                .background(
                    Capsule()
                        .fill(Color.black.opacity(0.6))
                        .background(.ultraThinMaterial)
                )
                .padding(12)
            }
            VStack(alignment: .leading, spacing: 8) {
                Text(curation.title)
                    .font(.system(size: 18, weight: .bold))
                    .foregroundColor(.ds.text)
                    .lineLimit(1)
                if let description = curation.description {
                    Text(description)
                        .font(.system(size: 14))
                        .foregroundColor(.ds.textSecondary)
                        .lineLimit(2)
                } else {
                    Text("A curated collection")
                        .font(.system(size: 14))
                        .foregroundColor(.ds.textSecondary)
                        .italic()
                }
                // Tags or metadata
                HStack(spacing: DesignSystem.Spacing.small) {
                    ForEach(["Featured", "Tech", "Insights"], id: \.self) { tag in
                        Text(tag)
                            .font(.system(size: 11, weight: .medium))
                            .foregroundColor(.purple)
                            .padding(.horizontal, 8)
                            .padding(.vertical, 4)
                            .background(
                                Capsule()
                                    .fill(Color.purple.opacity(0.1))
                            )
                    }
                }
                .padding(.top, 4)
            }
            .padding(DesignSystem.Spacing.medium)
        }
        .frame(width: 260)
        .background(
            RoundedRectangle(cornerRadius: 20, style: .continuous)
                .fill(Color.ds.surface)
        )
        .overlay(
            RoundedRectangle(cornerRadius: 20, style: .continuous)
                .strokeBorder(Color.ds.divider, lineWidth: 1)
        )
        .shadow(color: Color.black.opacity(0.08), radius: 12, y: 6)
        .scaleEffect(isPressed ? 0.95 : 1)
        .animation(.spring(response: 0.3, dampingFraction: 0.7), value: isPressed)
        .onLongPressGesture(minimumDuration: 0.1, maximumDistance: .infinity, pressing: { pressing in
            isPressed = pressing
        }, perform: {})
    }
}
struct CreateCurationCard: View {
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            VStack(spacing: DesignSystem.Spacing.medium) {
                ZStack {
                    Circle()
                        .strokeBorder(
                            style: StrokeStyle(lineWidth: 2, dash: [8])
                        )
                        .foregroundColor(.purple.opacity(0.5))
                        .frame(width: 64, height: 64)
                    Image(systemName: "plus")
                        .font(.system(size: 28, weight: .medium))
                        .foregroundColor(.purple)
                }
                Text("New Collection")
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundColor(.ds.text)
            }
            .frame(width: 160, height: 240)
            .background(
                RoundedRectangle(cornerRadius: 20, style: .continuous)
                    .fill(Color.purple.opacity(0.05))
                    .overlay(
                        RoundedRectangle(cornerRadius: 20, style: .continuous)
                            .strokeBorder(
                                style: StrokeStyle(lineWidth: 2, dash: [8])
                            )
                            .foregroundColor(.purple.opacity(0.3))
                    )
            )
        }
        .buttonStyle(PlainButtonStyle())
    }
}
struct GradientPlaceholder: View {
    @State private var animateGradient = false
    var body: some View {
        LinearGradient(
            colors: [
                Color.purple.opacity(0.6),
                Color.blue.opacity(0.4),
                Color.purple.opacity(0.6)
            ],
            startPoint: animateGradient ? .topLeading : .bottomTrailing,
            endPoint: animateGradient ? .bottomTrailing : .topLeading
        )
        .animation(.easeInOut(duration: 3).repeatForever(autoreverses: true), value: animateGradient)
        .onAppear { animateGradient = true }
    }
}
struct EnhancedFollowPacksSection: View {
    let followPacks: [FollowPack]
    @Binding var selectedFollowPack: FollowPack?
    @State private var showDiscoverMore = false
    var body: some View {
        VStack(alignment: .leading, spacing: 20) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text("Follow Packs")
                        .font(.system(size: 24, weight: .bold, design: .rounded))
                        .foregroundColor(.ds.text)
                    Text("Curated lists of people to follow")
                        .font(.system(size: 14))
                        .foregroundColor(.ds.textSecondary)
                }
                Spacer()
                Button(action: { showDiscoverMore = true }) {
                    Text("Discover")
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(.ds.primary)
                        .padding(.horizontal, DesignSystem.Spacing.medium)
                        .padding(.vertical, 8)
                        .background(
                            Capsule()
                                .fill(Color.ds.primary.opacity(0.1))
                        )
                }
            }
            .padding(.horizontal)
            if followPacks.isEmpty {
                ModernEmptyState(
                    icon: "person.3.sequence",
                    title: "No follow packs yet",
                    message: "Discover curated lists of interesting people to follow",
                    action: { showDiscoverMore = true },
                    actionTitle: "Explore Packs"
                )
                .padding(.horizontal)
            } else {
                LazyVStack(spacing: 12) {
                    ForEach(followPacks) { pack in
                        EnhancedFollowPackRow(followPack: pack)
                            .onTapGesture {
                                selectedFollowPack = pack
                                HapticManager.shared.impact(.light)
                            }
                    }
                }
                .padding(.horizontal)
            }
        }
    }
}
struct EnhancedFollowPackRow: View {
    let followPack: FollowPack
    @State private var profileImages: [String] = []
    var body: some View {
        HStack(spacing: DesignSystem.Spacing.medium) {
            // Profile stack
            ZStack {
                ForEach(0..<min(3, followPack.profiles.count), id: \.self) { index in
                    Circle()
                        .fill(
                            LinearGradient(
                                colors: [
                                    Color.ds.primary.opacity(0.6),
                                    Color.ds.secondary.opacity(0.6)
                                ],
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            )
                        )
                        .frame(width: 40, height: 40)
                        .overlay(
                            Text(String(followPack.profiles[index].prefix(1)))
                                .font(.system(size: 16, weight: .bold))
                                .foregroundColor(.white)
                        )
                        .offset(x: CGFloat(index * 15))
                }
                if followPack.profiles.count > 3 {
                    Circle()
                        .fill(Color.ds.surfaceSecondary)
                        .frame(width: 40, height: 40)
                        .overlay(
                            Text("+\(followPack.profiles.count - 3)")
                                .font(.system(size: 14, weight: .bold))
                                .foregroundColor(.ds.text)
                        )
                        .offset(x: 45)
                }
            }
            .frame(width: 100, alignment: .leading)
            VStack(alignment: .leading, spacing: 6) {
                Text(followPack.title)
                    .font(.system(size: 16, weight: .semibold))
                    .foregroundColor(.ds.text)
                HStack(spacing: DesignSystem.Spacing.medium) {
                    Label("\(followPack.profiles.count) people", systemImage: "person.2")
                        .font(.system(size: 13))
                        .foregroundColor(.ds.textSecondary)
                    if let description = followPack.description {
                        Text(description)
                            .font(.system(size: 13))
                            .foregroundColor(.ds.textSecondary)
                            .lineLimit(1)
                    }
                }
            }
            Spacer()
            Image(systemName: "chevron.right")
                .font(.system(size: 14))
                .foregroundColor(.ds.textTertiary)
        }
        .padding(DesignSystem.Spacing.large)
        .background(
            RoundedRectangle(cornerRadius: 20, style: .continuous)
                .fill(Color.ds.surface)
        )
        .overlay(
            RoundedRectangle(cornerRadius: 20, style: .continuous)
                .strokeBorder(Color.ds.divider, lineWidth: 1)
        )
        .shadow(color: Color.black.opacity(0.05), radius: 8, y: 4)
    }
}
// Add purple color extension if not already defined
#Preview {
    LibraryView()
        .environmentObject(AppState())
}
</file>

<file path="Sources/Highlighter/Views/ContentView.swift">
import SwiftUI
import NDKSwift
struct ContentView: View {
    @EnvironmentObject var appState: AppState
    @State private var authManager = NDKAuthManager.shared
    @State private var selectedTab = Tab.home
    @State private var tabBarVisible = true
    @State private var tabTransition: AnyTransition = .identity
    @State private var contentOffset: CGFloat = 0
    @State private var dragOffset: CGFloat = 0
    @State private var showTabSwitchAnimation = false
    @State private var tabSwitchProgress: CGFloat = 0
    @State private var activeTabGlow: CGFloat = 0
    @State private var navigationHapticTriggered = false
    @State private var contentAppeared = false
    @AppStorage("hasCompletedOnboarding") private var hasCompletedOnboarding = false
    enum Tab: CaseIterable {
        case home, feed, discover, library, profile
    }
    var body: some View {
        if !hasCompletedOnboarding || !authManager.isAuthenticated {
            OnboardingView(hasCompletedOnboarding: $hasCompletedOnboarding)
                .transition(.asymmetric(
                    insertion: .opacity,
                    removal: .move(edge: .leading).combined(with: .opacity)
                ))
        } else {
            ZStack(alignment: .bottom) {
                // Content with custom transitions
                ZStack {
                    ForEach(Tab.allCases, id: \.self) { tab in
                        Group {
                            switch tab {
                            case .home:
                                HybridFeedView()
                            case .feed:
                                HighlightsFeedView(tabBarVisible: $tabBarVisible)
                            case .discover:
                                AdvancedSearchView()
                            case .library:
                                LibraryView()
                            case .profile:
                                EnhancedProfileView()
                            }
                        }
                        .opacity(selectedTab == tab ? 1 : 0)
                        .scaleEffect(selectedTab == tab ? 1 : 0.92)
                        .offset(x: offsetForTab(tab), y: selectedTab == tab ? 0 : 10)
                        .blur(radius: selectedTab == tab ? 0 : 3)
                        .rotation3DEffect(
                            .degrees(selectedTab == tab ? 0 : 5),
                            axis: (x: 1, y: 0, z: 0),
                            perspective: 0.5
                        )
                        .allowsHitTesting(selectedTab == tab)
                        .transition(transitionForTab(tab))
                        .zIndex(selectedTab == tab ? 1 : 0)
                    }
                }
                .animation(
                    .interactiveSpring(
                        response: 0.45,
                        dampingFraction: 0.75,
                        blendDuration: 0.25
                    ),
                    value: selectedTab
                )
                // Add padding to prevent content from going under tab bar
                .padding(.bottom, tabBarVisible ? 72 : 0)
                .background(
                    // Ambient glow effect
                    Circle()
                        .fill(
                            RadialGradient(
                                colors: [
                                    DesignSystem.Colors.primary.opacity(0.3 * activeTabGlow),
                                    DesignSystem.Colors.secondary.opacity(0.2 * activeTabGlow),
                                    Color.clear
                                ],
                                center: .center,
                                startRadius: 50,
                                endRadius: 200
                            )
                        )
                        .frame(width: 400, height: 400)
                        .blur(radius: 50)
                        .offset(y: -100)
                        .allowsHitTesting(false)
                )
                .onAppear {
                    withAnimation(
                        .easeInOut(duration: 4)
                        .repeatForever(autoreverses: true)
                    ) {
                        activeTabGlow = 1
                    }
                }
                .gesture(
                    DragGesture()
                        .onChanged { value in
                            dragOffset = value.translation.width
                        }
                        .onEnded { value in
                            let threshold: CGFloat = 50
                            if abs(value.translation.width) > threshold {
                                withAnimation(.spring(response: 0.4, dampingFraction: 0.8)) {
                                    if value.translation.width > 0 {
                                        // Swipe right - go to previous tab
                                        switchToPreviousTab()
                                    } else {
                                        // Swipe left - go to next tab
                                        switchToNextTab()
                                    }
                                }
                            }
                            dragOffset = 0
                        }
                )
                if tabBarVisible {
                    VStack(spacing: 0) {
                        EnhancedTabBar(selectedTab: $selectedTab)
                    }
                    .transition(.move(edge: .bottom).combined(with: .opacity))
                    .animation(DesignSystem.Animation.springSnappy, value: tabBarVisible)
                }
            }
            .background(DesignSystem.Colors.background)
        }
    }
    // MARK: - Helper Functions
    private func offsetForTab(_ tab: Tab) -> CGFloat {
        guard selectedTab != tab else { return 0 }
        let currentIndex = Tab.allCases.firstIndex(of: selectedTab) ?? 0
        let tabIndex = Tab.allCases.firstIndex(of: tab) ?? 0
        let indexDifference = tabIndex - currentIndex
        return CGFloat(indexDifference) * 20 + dragOffset * 0.3
    }
    private func transitionForTab(_ tab: Tab) -> AnyTransition {
        let currentIndex = Tab.allCases.firstIndex(of: selectedTab) ?? 0
        let tabIndex = Tab.allCases.firstIndex(of: tab) ?? 0
        if tabIndex < currentIndex {
            return .asymmetric(
                insertion: .move(edge: .leading).combined(with: .opacity),
                removal: .move(edge: .trailing).combined(with: .opacity)
            )
        } else {
            return .asymmetric(
                insertion: .move(edge: .trailing).combined(with: .opacity),
                removal: .move(edge: .leading).combined(with: .opacity)
            )
        }
    }
    private func switchToNextTab() {
        let currentIndex = Tab.allCases.firstIndex(of: selectedTab) ?? 0
        let nextIndex = (currentIndex + 1) % Tab.allCases.count
        // Trigger advanced transition
        withAnimation(.spring(response: 0.4, dampingFraction: 0.75)) {
            tabSwitchProgress = 1
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            selectedTab = Tab.allCases[nextIndex]
            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                tabSwitchProgress = 0
            }
        }
        if !navigationHapticTriggered {
            HapticManager.shared.impact(.light)
            navigationHapticTriggered = true
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
                navigationHapticTriggered = false
            }
        }
    }
    private func switchToPreviousTab() {
        let currentIndex = Tab.allCases.firstIndex(of: selectedTab) ?? 0
        let previousIndex = currentIndex > 0 ? currentIndex - 1 : Tab.allCases.count - 1
        // Trigger advanced transition
        withAnimation(.spring(response: 0.4, dampingFraction: 0.75)) {
            tabSwitchProgress = -1
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            selectedTab = Tab.allCases[previousIndex]
            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                tabSwitchProgress = 0
            }
        }
        if !navigationHapticTriggered {
            HapticManager.shared.impact(.light)
            navigationHapticTriggered = true
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
                navigationHapticTriggered = false
            }
        }
    }
}
// MARK: - Tab Extensions
extension ContentView.Tab {
    var icon: String {
        switch self {
        case .home: return "house"
        case .feed: return "play.rectangle"
        case .discover: return "magnifyingglass"
        case .library: return "books.vertical"
        case .profile: return "person"
        }
    }
    var filledIcon: String {
        switch self {
        case .home: return "house.fill"
        case .feed: return "play.rectangle.fill"
        case .discover: return "magnifyingglass"
        case .library: return "books.vertical.fill"
        case .profile: return "person.fill"
        }
    }
    var title: String {
        switch self {
        case .home: return "Home"
        case .feed: return "Feed"
        case .discover: return "Discover"
        case .library: return "Library"
        case .profile: return "Profile"
        }
    }
}
#Preview {
    ContentView()
        .environmentObject(AppState())
        .preferredColorScheme(.dark)
}
</file>

<file path="Sources/Highlighter/Models/AppState.swift">
import Foundation
import NDKSwift
import Combine
@MainActor
class AppState: ObservableObject {
    // NDK Core
    @Published private(set) var ndk: NDK?
    // Auth Manager
    @Published private var authManager = NDKAuthManager.shared
    // Service Dependencies
    @Published private(set) var dataStreamManager = DataStreamManager()
    @Published private(set) var profileManager = ProfileManager()
    @Published private(set) var publishingService = PublishingService()
    @Published private(set) var bookmarkService = BookmarkService()
    @Published private(set) var commentService = CommentService()
    @Published private(set) var engagementService = EngagementService()
    @Published private(set) var lightningService = LightningService()
    @Published private(set) var readingProgressService = ReadingProgressService()
    // Content State - these need to be @Published for UI updates
    @Published var highlights: [HighlightEvent] = []
    @Published var curations: [ArticleCuration] = []
    @Published var userCurations: [ArticleCuration] = []
    @Published var followPacks: [FollowPack] = []
    @Published var articles: [Article] = []
    @Published var savedArticles: [Article] = []
    var currentUserProfile: NDKUserProfile? { profileManager.currentUserProfile }
    // App-level state
    @Published private(set) var following: Set<String> = []
    @Published var selectedTab = 0
    @Published var errorMessage: String?
    var isAuthenticated: Bool {
        authManager.isAuthenticated
    }
    var activeSigner: NDKSigner? {
        authManager.activeSigner
    }
    @Published var userPubkey: String?
    private var cancellables = Set<AnyCancellable>()
    init() {
        setupBindings()
    }
    private func setupBindings() {
        // Sync DataStreamManager content with AppState
        dataStreamManager.$highlights
            .receive(on: DispatchQueue.main)
            .assign(to: &$highlights)
        dataStreamManager.$curations
            .receive(on: DispatchQueue.main)
            .assign(to: &$curations)
        dataStreamManager.$followPacks
            .receive(on: DispatchQueue.main)
            .assign(to: &$followPacks)
        dataStreamManager.$articles
            .receive(on: DispatchQueue.main)
            .assign(to: &$articles)
        // User curations will be filtered based on current user
        dataStreamManager.$curations
            .receive(on: DispatchQueue.main)
            .sink { [weak self] allCurations in
                guard let self = self, let userPubkey = self.userPubkey else {
                    self?.userCurations = []
                    return
                }
                self.userCurations = allCurations.filter { $0.author == userPubkey }
            }
            .store(in: &cancellables)
    }
    private func configureServices(ndk: NDK, signer: NDKSigner?) {
        dataStreamManager.configure(with: ndk)
        profileManager.configure(with: ndk)
        publishingService.configure(with: ndk, signer: signer)
        bookmarkService.configure(with: ndk, signer: signer)
        commentService.configure(with: ndk, signer: signer)
        engagementService.configure(with: ndk, signer: signer)
    }
    func initialize() async {
        do {
            // Setup NDK with cache
            let cache = try await NDKSQLiteCache(path: nil)
            ndk = NDK(
                relayUrls: RelayConstants.extendedRelays.dropLast(),
                cache: cache
            )
            // Configure services with NDK instance
            guard let ndk = ndk else { return }
            configureServices(ndk: ndk, signer: authManager.activeSigner)
            // Connect to relays asynchronously
            Task {
                await ndk.connect()
            }
            // Set NDK instance in auth manager
            authManager.setNDK(ndk)
            // Initialize auth manager (restores sessions automatically)
            // await authManager.initialize()
            // Set user pubkey if authenticated
            if let signer = activeSigner {
                userPubkey = try? await signer.pubkey
            }
            // Start NIP-77 sync in background
            Task {
                await syncHighlights()
            }
            // If authenticated after restore, start services immediately
            if authManager.isAuthenticated {
                // Start streaming data
                await dataStreamManager.startAllStreams()
                // Load user profile in background
                if let signer = authManager.activeSigner {
                    Task {
                        await profileManager.loadCurrentUserProfile(for: signer)
                    }
                }
                // Load following list
                Task {
                    try? await loadFollowingList()
                }
            }
        } catch {
            errorMessage = "Failed to initialize: \(error.localizedDescription)"
        }
    }
    func createAccount() async throws {
        guard let ndk = ndk else { throw AuthError.noSigner }
        let signer = try NDKPrivateKeySigner.generate()
        // Start NDK session first
        try await ndk.startSession(
            signer: signer,
            config: NDKSessionConfiguration(
                dataRequirements: [.followList, .muteList],
                preloadStrategy: .progressive
            )
        )
        // Create persistent auth session
        let session = try await authManager.createSession(
            with: signer,
            requiresBiometric: true
        )
        try await authManager.switchToSession(session)
        // Update services with new signer
        configureServices(ndk: ndk, signer: signer)
        // Set user pubkey
        userPubkey = try? await signer.pubkey
        // Start streaming data
        await dataStreamManager.startAllStreams()
        // Following list will be empty for new accounts
    }
    func importAccount(nsec: String) async throws {
        guard let ndk = ndk else { throw AuthError.noSigner }
        let signer = try NDKPrivateKeySigner(nsec: nsec)
        // Start NDK session first
        try await ndk.startSession(
            signer: signer,
            config: NDKSessionConfiguration(
                dataRequirements: [.followList, .muteList],
                preloadStrategy: .progressive
            )
        )
        // Create persistent auth session
        let session = try await authManager.createSession(
            with: signer,
            requiresBiometric: true
        )
        try await authManager.switchToSession(session)
        // Update services with new signer
        configureServices(ndk: ndk, signer: signer)
        // Set user pubkey
        userPubkey = try? await signer.pubkey
        // Start streaming data
        await dataStreamManager.startAllStreams()
        // Load user profile
        await profileManager.loadCurrentUserProfile(for: signer)
        // Load following list
        try? await loadFollowingList()
    }
    func logout() async {
        // Stop all services
        dataStreamManager.stopAllStreams()
        profileManager.stopAllTasks()
        // Clear service state
        await dataStreamManager.refresh()
        profileManager.clearCache()
        following = []
        // Proper logout implementation - clear cache and delete sessions from keychain
        Task {
            // Clear cache data
            if let cache = ndk?.cache {
                try? await cache.clear()
            }
            // Delete ALL sessions from keychain - this is critical!
            for session in authManager.availableSessions {
                try? await authManager.deleteSession(session)
            }
        }
        // Clear memory state
        authManager.logout()
    }
    // MARK: - Private Methods
    private func syncHighlights() async {
        guard let ndk = ndk else { return }
        do {
            // Create filter for kind 9802 (highlights)
            let highlightFilter = NDKFilter(kinds: [9802])
            // Starting NIP-77 sync for highlights from relay.damus.io
            // Perform NIP-77 sync with relay.damus.io
            _ = try await ndk.syncEvents(
                filter: highlightFilter,
                relay: "wss://relay.damus.io",
                direction: .receive // Only download, don't upload
            )
            // NIP-77 sync completed successfully
            // Let the DataStreamManager handle the highlights after sync
            await dataStreamManager.refresh()
        } catch {
            // NIP-77 sync failed - continuing with normal operation
            // Don't show error to user, continue with normal operation
        }
    }
    // MARK: - Publishing Methods (delegated to PublishingService)
    func publishHighlight(_ highlight: HighlightEvent) async throws {
        try await publishingService.publishHighlight(highlight)
    }
    func createCuration(name: String, title: String, description: String?, image: String?) async throws {
        try await publishingService.createCuration(name: name, title: title, description: description, image: image)
    }
    // MARK: - Follow Management (NIP-02)
    /// Follow a user by adding them to the contact list
    func followUser(_ pubkey: String) async throws {
        guard let ndk = ndk else {
            throw AuthError.noSigner
        }
        let userToFollow = NDKUser(pubkey: pubkey)
        // Use NDK's built-in follow method
        try await ndk.follow(userToFollow)
        // Update local following set
        following.insert(pubkey)
    }
    /// Unfollow a user by removing them from the contact list
    func unfollowUser(_ pubkey: String) async throws {
        guard let ndk = ndk else {
            throw AuthError.noSigner
        }
        let userToUnfollow = NDKUser(pubkey: pubkey)
        // Use NDK's built-in unfollow method
        try await ndk.unfollow(userToUnfollow)
        // Update local following set
        following.remove(pubkey)
    }
    /// Check if the current user is following a specific user
    func isFollowing(_ pubkey: String) async throws -> Bool {
        // First check local cache
        if following.contains(pubkey) {
            return true
        }
        guard let ndk = ndk else {
            throw AuthError.noSigner
        }
        // Get contact list
        guard let contactList = try await ndk.fetchContactList() else {
            return false
        }
        // Check if following
        let isFollowing = contactList.isFollowing(pubkey)
        // Update local cache
        if isFollowing {
            following.insert(pubkey)
        }
        return isFollowing
    }
    /// Load the current user's following list
    func loadFollowingList() async throws {
        guard let ndk = ndk else {
            throw AuthError.noSigner
        }
        // Get contact list
        guard let contactList = try await ndk.fetchContactList() else {
            following = []
            return
        }
        // Update local following set
        following = Set(contactList.contactPubkeys)
    }
}
enum AuthError: LocalizedError {
    case invalidPrivateKey
    case noSigner
    var errorDescription: String? {
        switch self {
        case .invalidPrivateKey:
            return "Invalid private key format"
        case .noSigner:
            return "No signer configured"
        }
    }
}
</file>

<file path="Sources/Highlighter/Views/Profile/UserProfileView.swift">
import SwiftUI
import NDKSwift
struct UserProfileView: View {
    let pubkey: String
    @EnvironmentObject var appState: AppState
    @State private var profile: NDKUserProfile?
    @State private var highlights: [HighlightEvent] = []
    @State private var articles: [Article] = []
    @State private var comments: [NDKEvent] = []
    @State private var collections: [ArticleCuration] = []
    @State private var stats = ProfileStats()
    @State private var selectedTab = ProfileTab.highlights
    @State private var showingFollowConfirmation = false
    @State private var isFollowing = false
    private func formatNpub(_ pubkey: String) -> String {
        // Convert hex pubkey to npub using proper bech32 encoding
        let user = NDKUser(pubkey: pubkey)
        return user.npub
    }
    struct ProfileStats {
        var highlightCount = 0
        var articleCount = 0
        var followerCount = 0
        var followingCount = 0
    }
    enum ProfileTab: String, CaseIterable {
        case highlights = "Highlights"
        case articles = "Articles"
        case comments = "Comments"
        case collections = "Collections"
        var icon: String {
            switch self {
            case .highlights: return "highlighter"
            case .articles: return "doc.richtext"
            case .comments: return "bubble.left.and.bubble.right"
            case .collections: return "folder"
            }
        }
    }
    var body: some View {
        NavigationStack {
            ScrollView {
                VStack(spacing: 0) {
                    // Profile Header
                    profileHeader
                        .padding(.horizontal, 20)
                        .padding(.vertical, 24)
                    // Stats Bar
                    statsBar
                        .padding(.horizontal, 20)
                        .padding(.bottom, 20)
                    // Tab Selection
                    tabSelector
                        .padding(.horizontal, 20)
                        .padding(.bottom, 16)
                    // Content based on selected tab
                    tabContent
                        .padding(.horizontal, 20)
                }
            }
            .background(Color.ds.background)
            .navigationBarTitleDisplayMode(.inline)
            .toolbar {
                ToolbarItem(placement: .navigationBarTrailing) {
                    Menu {
                        Button(action: { shareProfile() }) {
                            Label("Share Profile", systemImage: "square.and.arrow.up")
                        }
                        Button(action: { copyNpub() }) {
                            Label("Copy npub", systemImage: "doc.on.doc")
                        }
                        if isFollowing {
                            Button(role: .destructive, action: { toggleFollow() }) {
                                Label("Unfollow", systemImage: "person.badge.minus")
                            }
                        }
                    } label: {
                        Image(systemName: "ellipsis.circle")
                            .font(.ds.body)
                            .foregroundColor(.ds.primary)
                    }
                }
            }
        }
        .task {
            // Start streaming profile updates
            appState.profileManager.streamProfile(for: pubkey)
            // Load profile data
            await loadProfileData()
            checkFollowStatus()
        }
        .onChange(of: pubkey) { _, newPubkey in
            Task {
                // Start streaming profile updates for new pubkey
                appState.profileManager.streamProfile(for: newPubkey)
                await loadProfileData()
                checkFollowStatus()
            }
        }
        .onReceive(appState.profileManager.$cachedProfiles) { profiles in
            // Update profile when it changes in the cache
            if let updatedProfile = profiles[pubkey] {
                self.profile = updatedProfile
            }
        }
    }
    // MARK: - Profile Header
    @ViewBuilder
    private var profileHeader: some View {
        VStack(spacing: 16) {
            // Avatar
            if let picture = profile?.picture, let url = URL(string: picture) {
                AsyncImage(url: url) { phase in
                    switch phase {
                    case .success(let image):
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                            .frame(width: 100, height: 100)
                            .clipShape(Circle())
                    case .failure(_), .empty:
                        avatarPlaceholder
                    @unknown default:
                        avatarPlaceholder
                    }
                }
            } else {
                avatarPlaceholder
            }
            // Name and username
            VStack(spacing: 8) {
                if let name = profile?.name {
                    Text(name)
                        .font(.ds.title2)
                        .fontWeight(.bold)
                        .foregroundColor(.ds.text)
                }
                Text(formatNpub(pubkey))
                    .font(.ds.caption)
                    .foregroundColor(.ds.textSecondary)
                    .textSelection(.enabled)
            }
            // Bio
            if let about = profile?.about {
                Text(about)
                    .font(.ds.body)
                    .foregroundColor(.ds.text)
                    .multilineTextAlignment(.center)
                    .lineLimit(4)
                    .padding(.top, 8)
            }
            // Follow/Message buttons
            HStack(spacing: 12) {
                Button(action: { toggleFollow() }) {
                    HStack {
                        Image(systemName: isFollowing ? "person.badge.minus" : "person.badge.plus")
                        Text(isFollowing ? "Following" : "Follow")
                    }
                    .font(.ds.footnoteMedium)
                    .foregroundColor(isFollowing ? .ds.text : .white)
                    .padding(.horizontal, 24)
                    .padding(.vertical, 12)
                    .background(
                        RoundedRectangle(cornerRadius: 20, style: .continuous)
                            .fill(isFollowing ? Color.ds.surfaceSecondary : Color.ds.primary)
                    )
                }
                Button(action: { /* Open DM */ }) {
                    Image(systemName: "envelope")
                        .font(.ds.body)
                        .foregroundColor(.ds.primary)
                        .padding(12)
                        .background(
                            Circle()
                                .stroke(Color.ds.primary, lineWidth: 1)
                        )
                }
            }
            .padding(.top, 12)
        }
    }
    // MARK: - Avatar Placeholder
    @ViewBuilder
    private var avatarPlaceholder: some View {
        ZStack {
            Circle()
                .fill(
                    LinearGradient(
                        colors: [.purple, .blue],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: 100, height: 100)
            Text(PubkeyFormatter.formatForAvatar(pubkey))
                .font(.system(size: 36, weight: .medium))
                .foregroundColor(.white)
        }
    }
    // MARK: - Stats Bar
    @ViewBuilder
    private var statsBar: some View {
        HStack(spacing: 0) {
            ProfileStatItem(
                value: "\(stats.highlightCount)",
                label: "Highlights",
                color: .orange
            )
            Divider()
                .frame(height: 40)
            ProfileStatItem(
                value: "\(stats.articleCount)",
                label: "Articles",
                color: .blue
            )
            Divider()
                .frame(height: 40)
            ProfileStatItem(
                value: "\(stats.followerCount)",
                label: "Followers",
                color: .purple
            )
            Divider()
                .frame(height: 40)
            ProfileStatItem(
                value: "\(stats.followingCount)",
                label: "Following",
                color: .green
            )
        }
        .padding(.vertical, 16)
        .background(
            RoundedRectangle(cornerRadius: 16, style: .continuous)
                .fill(Color.ds.surfaceSecondary)
        )
    }
    // MARK: - Tab Selector
    @ViewBuilder
    private var tabSelector: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 16) {
                ForEach(ProfileTab.allCases, id: \.self) { tab in
                    UserProfileTabButton(
                        tab: tab,
                        isSelected: selectedTab == tab,
                        count: countForTab(tab)
                    ) {
                        withAnimation(.spring(response: 0.3)) {
                            selectedTab = tab
                        }
                    }
                }
            }
        }
    }
    // MARK: - Tab Content
    @ViewBuilder
    private var tabContent: some View {
        switch selectedTab {
        case .highlights:
            HighlightsListView(highlights: highlights)
        case .articles:
            ArticlesListView(articles: articles)
        case .comments:
            CommentsListView(comments: comments)
        case .collections:
            CollectionsListView(collections: collections)
        }
    }
    // MARK: - Helper Methods
    private func countForTab(_ tab: ProfileTab) -> Int {
        switch tab {
        case .highlights: return highlights.count
        case .articles: return articles.count
        case .comments: return comments.count
        case .collections: return collections.count
        }
    }
    private func checkFollowStatus() {
        Task {
            do {
                isFollowing = try await appState.isFollowing(pubkey)
            } catch {
                // Error checking follow status
                isFollowing = false
            }
        }
    }
    private func toggleFollow() {
        Task {
            await performToggleFollow()
        }
    }
    private func performToggleFollow() async {
        let wasFollowing = isFollowing
        isFollowing.toggle()
        HapticManager.shared.impact(.light)
        do {
            if isFollowing {
                try await appState.followUser(pubkey)
                await MainActor.run {
                    stats.followerCount += 1
                }
            } else {
                try await appState.unfollowUser(pubkey)
                await MainActor.run {
                    stats.followerCount = max(0, stats.followerCount - 1)
                }
            }
        } catch {
            // Revert on error
            await MainActor.run {
                isFollowing = wasFollowing
                HapticManager.shared.notification(.error)
            }
        }
    }
    private func shareProfile() {
        // Share profile implementation
    }
    private func copyNpub() {
        let npub = formatNpub(pubkey)
        if !npub.isEmpty {
            UIPasteboard.general.string = npub
            HapticManager.shared.notification(.success)
        }
    }
    // MARK: - Data Loading
    private func loadProfileData() async {
        guard let ndk = appState.ndk else { return }
        // Get cached profile immediately if available
        if let cachedProfile = appState.profileManager.getCachedProfile(for: pubkey) {
            self.profile = cachedProfile
        }
        // Load all content in parallel
        await withTaskGroup(of: Void.self) { group in
            group.addTask { await self.loadHighlights(pubkey: pubkey, ndk: ndk) }
            group.addTask { await self.loadArticles(pubkey: pubkey, ndk: ndk) }
            group.addTask { await self.loadComments(pubkey: pubkey, ndk: ndk) }
            group.addTask { await self.loadCollections(pubkey: pubkey, ndk: ndk) }
            group.addTask { await self.loadStats(pubkey: pubkey, ndk: ndk) }
        }
    }
    private func loadHighlights(pubkey: String, ndk: NDK) async {
        let filter = NDKFilter(
            authors: [pubkey],
            kinds: [9802],
            limit: 50
        )
        var events: Set<NDKEvent> = []
        let dataSource = await ndk.outbox.observe(filter: filter)
        for await event in dataSource.events {
            events.insert(event)
            if events.count >= 50 { break }
        }
        let highlights = events.compactMap { try? HighlightEvent(from: $0) }
        await MainActor.run {
            self.highlights = highlights.sorted { $0.createdAt > $1.createdAt }
            self.stats.highlightCount = highlights.count
        }
    }
    private func loadArticles(pubkey: String, ndk: NDK) async {
        let filter = NDKFilter(
            authors: [pubkey],
            kinds: [30023],
            limit: 50
        )
        var events: Set<NDKEvent> = []
        let dataSource = await ndk.outbox.observe(filter: filter)
        for await event in dataSource.events {
            events.insert(event)
            if events.count >= 50 { break }
        }
        if !events.isEmpty {
            let articles = events.compactMap { try? Article(from: $0) }
            await MainActor.run {
                self.articles = articles.sorted { $0.publishedAt ?? $0.createdAt > $1.publishedAt ?? $1.createdAt }
                self.stats.articleCount = articles.count
            }
        }
    }
    private func loadComments(pubkey: String, ndk: NDK) async {
        // NIP-22 comments on articles
        let filter = NDKFilter(
            authors: [pubkey],
            kinds: [1111],
            tags: ["K": Set(["30023"])]
        )
        let dataSource = await ndk.outbox.observe(filter: filter)
        var collectedEvents: [NDKEvent] = []
        for await event in dataSource.events {
            collectedEvents.append(event)
        }
        if !collectedEvents.isEmpty {
            let sortedEvents = collectedEvents.sorted { $0.createdAt > $1.createdAt }
            await MainActor.run {
                self.comments = sortedEvents.prefix(50).map { $0 }
            }
        }
    }
    private func loadCollections(pubkey: String, ndk: NDK) async {
        let filter = NDKFilter(
            authors: [pubkey],
            kinds: [30004],
            limit: 50
        )
        var events: Set<NDKEvent> = []
        let dataSource = await ndk.outbox.observe(filter: filter)
        for await event in dataSource.events {
            events.insert(event)
            if events.count >= 50 { break }
        }
        if !events.isEmpty {
            let collections = events.compactMap { try? ArticleCuration(from: $0) }
            await MainActor.run {
                self.collections = collections.sorted { $0.createdAt > $1.createdAt }
            }
        }
    }
    private func loadStats(pubkey: String, ndk: NDK) async {
        // Load follow stats
        let followFilter = NDKFilter(
            kinds: [3],
            tags: ["p": Set([pubkey])]
        )
        var followerCount = 0
        let dataSource = await ndk.outbox.observe(filter: followFilter)
        for await _ in dataSource.events {
            followerCount += 1
        }
        // Load following count from contact list
        let followingFilter = NDKFilter(
            authors: [pubkey],
            kinds: [3],
            limit: 1
        )
        var followingCount = 0
        let followingDataSource = await ndk.outbox.observe(filter: followingFilter)
        for await event in followingDataSource.events {
            // Count the "p" tags in the contact list
            followingCount = event.tags.filter { $0.count >= 2 && $0[0] == "p" }.count
            break // Only need first contact list
        }
        await MainActor.run {
            self.stats.followerCount = followerCount
            self.stats.followingCount = followingCount
        }
    }
}
// MARK: - Supporting Views
struct ProfileStatItem: View {
    let value: String
    let label: String
    let color: Color
    var body: some View {
        VStack(spacing: 4) {
            Text(value)
                .font(.ds.headline)
                .fontWeight(.semibold)
                .foregroundColor(.ds.text)
            Text(label)
                .font(.ds.caption)
                .foregroundColor(.ds.textSecondary)
        }
        .frame(maxWidth: .infinity)
    }
}
struct UserProfileTabButton: View {
    let tab: UserProfileView.ProfileTab
    let isSelected: Bool
    let count: Int
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            HStack(spacing: 8) {
                Image(systemName: tab.icon)
                    .font(.ds.footnote)
                Text(tab.rawValue)
                    .font(.ds.footnoteMedium)
                if count > 0 {
                    Text("\(count)")
                        .font(.ds.caption)
                        .padding(.horizontal, 6)
                        .padding(.vertical, 2)
                        .background(
                            Capsule()
                                .fill(isSelected ? Color.ds.primary.opacity(0.2) : Color.ds.surfaceSecondary)
                        )
                }
            }
            .foregroundColor(isSelected ? .ds.primary : .ds.textSecondary)
            .padding(.horizontal, 16)
            .padding(.vertical, 10)
            .background(
                RoundedRectangle(cornerRadius: 12, style: .continuous)
                    .fill(isSelected ? Color.ds.primary.opacity(0.1) : Color.clear)
                    .overlay(
                        RoundedRectangle(cornerRadius: 12, style: .continuous)
                            .stroke(isSelected ? Color.ds.primary : Color.clear, lineWidth: 1)
                    )
            )
        }
    }
}
// MARK: - Content List Views
struct HighlightsListView: View {
    let highlights: [HighlightEvent]
    var body: some View {
        VStack(spacing: 16) {
            if highlights.isEmpty {
                UserProfileEmptyStateView(
                    icon: "highlighter",
                    title: "No highlights yet",
                    description: "This user hasn't created any highlights"
                )
                .padding(.vertical, 40)
            } else {
                ForEach(highlights, id: \.id) { highlight in
                    ModernHighlightCard(highlight: highlight)
                }
            }
        }
    }
}
struct ArticlesListView: View {
    let articles: [Article]
    var body: some View {
        VStack(spacing: 16) {
            if articles.isEmpty {
                UserProfileEmptyStateView(
                    icon: "doc.richtext",
                    title: "No articles yet",
                    description: "This user hasn't written any articles"
                )
                .padding(.vertical, 40)
            } else {
                ForEach(articles, id: \.id) { article in
                    ModernArticleRowCard(article: article)
                }
            }
        }
    }
}
struct CommentsListView: View {
    let comments: [NDKEvent]
    var body: some View {
        VStack(spacing: 16) {
            if comments.isEmpty {
                UserProfileEmptyStateView(
                    icon: "bubble.left.and.bubble.right",
                    title: "No comments yet",
                    description: "This user hasn't commented on any articles"
                )
                .padding(.vertical, 40)
            } else {
                ForEach(comments, id: \.id) { comment in
                    CommentCard(comment: comment)
                }
            }
        }
    }
}
struct CollectionsListView: View {
    let collections: [ArticleCuration]
    var body: some View {
        VStack(spacing: 16) {
            if collections.isEmpty {
                UserProfileEmptyStateView(
                    icon: "folder",
                    title: "No collections yet",
                    description: "This user hasn't created any collections"
                )
                .padding(.vertical, 40)
            } else {
                ForEach(collections, id: \.id) { collection in
                    CollectionCard(collection: collection)
                }
            }
        }
    }
}
struct CommentCard: View {
    let comment: NDKEvent
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text(comment.content)
                .font(.ds.body)
                .foregroundColor(.ds.text)
                .lineLimit(3)
            HStack {
                Text(RelativeTimeFormatter.relativeTime(from: comment.createdAt))
                    .font(.ds.caption)
                    .foregroundColor(.ds.textTertiary)
                Spacer()
                // Reference to article
                if comment.tags.first(where: { $0.count >= 2 && $0[0] == "a" }) != nil {
                    Label("View Article", systemImage: "doc.text")
                        .font(.ds.caption)
                        .foregroundColor(.ds.primary)
                }
            }
        }
        .padding(16)
        .background(
            RoundedRectangle(cornerRadius: 12, style: .continuous)
                .fill(Color.ds.surfaceSecondary)
        )
    }
}
struct CollectionCard: View {
    let collection: ArticleCuration
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                if let image = collection.image, let url = URL(string: image) {
                    AsyncImage(url: url) { phase in
                        switch phase {
                        case .success(let image):
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                .frame(width: 60, height: 60)
                                .clipShape(RoundedRectangle(cornerRadius: 8))
                        default:
                            RoundedRectangle(cornerRadius: 8)
                                .fill(Color.ds.surfaceSecondary)
                                .frame(width: 60, height: 60)
                        }
                    }
                }
                VStack(alignment: .leading, spacing: 4) {
                    Text(collection.title)
                        .font(.ds.headline)
                        .foregroundColor(.ds.text)
                        .lineLimit(1)
                    if let description = collection.description {
                        Text(description)
                            .font(.ds.caption)
                            .foregroundColor(.ds.textSecondary)
                            .lineLimit(2)
                    }
                    HStack {
                        Label("\(collection.articles.count) articles", systemImage: "doc.text")
                            .font(.ds.caption)
                            .foregroundColor(.ds.textTertiary)
                        Spacer()
                        Text(RelativeTimeFormatter.relativeTime(from: collection.updatedAt))
                            .font(.ds.caption)
                            .foregroundColor(.ds.textTertiary)
                    }
                }
                .frame(maxWidth: .infinity, alignment: .leading)
            }
        }
        .padding(16)
        .background(
            RoundedRectangle(cornerRadius: 12, style: .continuous)
                .fill(Color.ds.surfaceSecondary)
        )
    }
}
struct UserProfileEmptyStateView: View {
    let icon: String
    let title: String
    let description: String
    var body: some View {
        VStack(spacing: 12) {
            Image(systemName: icon)
                .font(.system(size: 48))
                .foregroundColor(.ds.textTertiary)
            Text(title)
                .font(.ds.headline)
                .foregroundColor(.ds.text)
            Text(description)
                .font(.ds.caption)
                .foregroundColor(.ds.textSecondary)
                .multilineTextAlignment(.center)
        }
        .padding()
    }
}
// MARK: - Preview
struct UserProfileView_Previews: PreviewProvider {
    static var previews: some View {
        UserProfileView(pubkey: "npub1sg6plzptd64u62a878hep2kev88swjh3tw00gjsfl8f237lmu63q0uf63m")
            .environmentObject(AppState())
    }
}
</file>

<file path="Sources/Highlighter/Views/Home/HybridFeedView.swift">
import SwiftUI
import NDKSwift
struct HybridFeedView: View {
    @EnvironmentObject var appState: AppState
    @StateObject private var dataManager: HomeDataManager
    @State private var scrollOffset: CGFloat = 0
    @State private var selectedSection: FeedSection = .forYou
    @State private var carouselOffsets: [String: CGFloat] = [:]
    @State private var headerVisible = false
    @State private var activeHighlight: HighlightEvent?
    @State private var showingHighlightDetail = false
    @State private var sectionVisibility: [String: Bool] = [:]
    @Namespace private var animation
    @Environment(\.colorScheme) var colorScheme
    enum FeedSection: String, CaseIterable {
        case forYou = "For You"
        case trending = "Trending"
        case recent = "Recent"
        case following = "Following"
        var icon: String {
            switch self {
            case .forYou: return "sparkles"
            case .trending: return "flame.fill"
            case .recent: return "clock.fill"
            case .following: return "person.2.fill"
            }
        }
        var color: Color {
            switch self {
            case .forYou: return .purple
            case .trending: return .orange
            case .recent: return .blue
            case .following: return .green
            }
        }
    }
    init() {
        let manager = HomeDataManager()
        self._dataManager = StateObject(wrappedValue: manager)
        // HybridFeedView initialized with dataManager
    }
    var body: some View {
        NavigationStack {
            ZStack {
                // Simple background
                Color.ds.background
                    .ignoresSafeArea()
                // Main content
                ScrollViewReader { proxy in
                    ScrollView(.vertical, showsIndicators: false) {
                        VStack(spacing: 0) {
                            // Hero header
                            heroHeader
                            // Recent articles - ALWAYS shown at the top, right after greeting
                            RecentArticlesSection(dataManager: dataManager)
                                .padding(.vertical, 16)
                            // Sticky section tabs
                            sectionTabs
                                .background(
                                    Color.ds.background
                                        .opacity(headerVisible ? 0.95 : 0)
                                        .ignoresSafeArea()
                                )
                                .overlay(alignment: .bottom) {
                                    if headerVisible {
                                        Divider()
                                    }
                                }
                            // Content sections with carousels
                            contentSections
                        }
                        .background(
                            GeometryReader { geo in
                                Color.clear.preference(
                                    key: ScrollOffsetKey.self,
                                    value: geo.frame(in: .named("scroll")).minY
                                )
                            }
                        )
                    }
                    .coordinateSpace(name: "scroll")
                    .onPreferenceChange(ScrollOffsetKey.self) { value in
                        handleScrollOffset(value)
                    }
                }
            }
            .navigationBarHidden(true)
        }
        .onAppear {
            dataManager.appState = appState
        }
        .task {
            await dataManager.startStreaming()
        }
        .sheet(isPresented: $showingHighlightDetail) {
            if let highlight = activeHighlight {
                HighlightDetailView(highlight: highlight)
                    .presentationDragIndicator(.visible)
                    .presentationDetents([.medium, .large])
            }
        }
    }
    // MARK: - Hero Header
    @ViewBuilder
    private var heroHeader: some View {
        VStack(spacing: 12) {
            // App name
            Text("Highlighter")
                .font(.system(size: 32, weight: .bold, design: .rounded))
                .foregroundStyle(
                    LinearGradient(
                        colors: [.ds.text, .ds.text.opacity(0.8)],
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                )
                .frame(maxWidth: .infinity, alignment: .leading)
        }
        .padding(.horizontal, 20)
        .padding(.vertical, 16)
    }
    // MARK: - Section Tabs
    @ViewBuilder
    private var sectionTabs: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: 24) {
                ForEach(FeedSection.allCases, id: \.self) { section in
                    SectionTab(
                        section: section,
                        isSelected: selectedSection == section,
                        namespace: animation
                    ) {
                        withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                            selectedSection = section
                            HapticManager.shared.impact(.light)
                        }
                    }
                }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
        }
    }
    // MARK: - Content Sections
    @ViewBuilder
    private var contentSections: some View {
        VStack(spacing: 24) {
            // Featured highlights carousel
            if selectedSection == .forYou || selectedSection == .trending {
                CarouselSection(
                    title: "Featured Highlights",
                    icon: "star.fill",
                    iconColor: .yellow,
                    id: "featured"
                ) {
                    ForEach(dataManager.userHighlights.prefix(10), id: \.id) { highlight in
                        Button(action: {
                            activeHighlight = highlight
                            showingHighlightDetail = true
                            HapticManager.shared.impact(.medium)
                        }) {
                            FeaturedHighlightCarouselCard(highlight: highlight)
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                }
                .revealAnimation(id: "featured", visibility: $sectionVisibility)
            }
            // Trending quotes carousel
            CarouselSection(
                title: "Trending Quotes",
                icon: "quote.bubble.fill",
                iconColor: .orange,
                id: "quotes",
                cardWidth: 280
            ) {
                ForEach(dataManager.userHighlights.filter { $0.content.count < 150 }.prefix(8), id: \.id) { highlight in
                    Button(action: {
                        activeHighlight = highlight
                        showingHighlightDetail = true
                        HapticManager.shared.impact(.medium)
                    }) {
                        QuoteCarouselCard(highlight: highlight)
                    }
                    .buttonStyle(PlainButtonStyle())
                }
            }
            .revealAnimation(id: "quotes", visibility: $sectionVisibility)
            // Active discussions - vertical list within the feed
            if !dataManager.discussions.isEmpty {
                ActiveDiscussionsInlineSection(discussions: dataManager.discussions)
                    .padding(.horizontal, 16)
                    .revealAnimation(id: "discussions", visibility: $sectionVisibility)
            }
            // Community curations carousel
            if !dataManager.curations.isEmpty {
                CarouselSection(
                    title: "Community Curations",
                    icon: "folder.fill",
                    iconColor: .blue,
                    id: "curations",
                    cardWidth: 300
                ) {
                    ForEach(dataManager.curations) { curation in
                        NavigationLink(destination: CurationDetailView(curation: curation)) {
                            CurationCarouselCard(curation: curation)
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                }
                .revealAnimation(id: "curations", visibility: $sectionVisibility)
            }
            // Recently zapped articles
            if !dataManager.zappedArticles.isEmpty {
                CarouselSection(
                    title: "Lightning Strikes",
                    icon: "bolt.fill",
                    iconColor: .yellow,
                    id: "zapped",
                    cardWidth: 320
                ) {
                    ForEach(dataManager.zappedArticles.prefix(6), id: \.id) { event in
                        Button(action: {
                            // Handle zapped article tap
                            HapticManager.shared.impact(.medium)
                        }) {
                            ZappedArticleCard(event: event)
                        }
                        .buttonStyle(PlainButtonStyle())
                    }
                }
                .revealAnimation(id: "zapped", visibility: $sectionVisibility)
            }
            // Follow recommendations carousel
            if !dataManager.suggestedUsers.isEmpty {
                CarouselSection(
                    title: "Discover People",
                    icon: "person.crop.circle.badge.plus",
                    iconColor: .green,
                    id: "people",
                    cardWidth: 160
                ) {
                    ForEach(Array(dataManager.suggestedUsers.enumerated()), id: \.offset) { index, profile in
                        PersonDiscoveryCard(
                            profile: profile, 
                            pubkey: index < dataManager.suggestedUserPubkeys.count ? dataManager.suggestedUserPubkeys[index] : ""
                        )
                    }
                }
                .revealAnimation(id: "people", visibility: $sectionVisibility)
            }
        }
        .padding(.vertical, 16)
    }
    // MARK: - Helper Methods
    private func handleScrollOffset(_ offset: CGFloat) {
        scrollOffset = offset
        headerVisible = offset < -50
    }
}
// MARK: - Supporting Components
struct CarouselSection<Content: View>: View {
    let title: String
    let icon: String
    let iconColor: Color
    let id: String
    var cardWidth: CGFloat = 240
    @ViewBuilder let content: () -> Content
    @State private var scrollOffset: CGFloat = 0
    @State private var titleScale: CGFloat = 1
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Section header
            HStack {
                Label(title, systemImage: icon)
                    .font(.ds.title3)
                    .fontWeight(.semibold)
                    .foregroundColor(.ds.text)
                    .scaleEffect(titleScale)
                Spacer()
                Button(action: {}) {
                    Text("See All")
                        .font(.ds.footnote)
                        .foregroundColor(.ds.primary)
                }
            }
            .padding(.horizontal, 16)
            // Carousel content
            ScrollView(.horizontal, showsIndicators: false) {
                LazyHStack(spacing: 16) {
                    content()
                        .frame(width: cardWidth)
                }
                .padding(.horizontal, 12)
                .scrollTargetLayout()
            }
            .scrollTargetBehavior(.viewAligned)
            .background(
                GeometryReader { geometry in
                    Color.clear
                        .preference(key: ScrollOffsetKey.self, value: -geometry.frame(in: .named("scroll")).origin.x)
                }
            )
            .onPreferenceChange(ScrollOffsetKey.self) { value in
                scrollOffset = value
                withAnimation(.spring(response: 0.3)) {
                    titleScale = 1 + (abs(scrollOffset) / 1000)
                }
            }
            .coordinateSpace(name: "scroll")
        }
    }
}
struct FeaturedHighlightCarouselCard: View {
    let highlight: HighlightEvent
    @State private var isPressed = false
    @State private var glowIntensity: Double = 0
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Content
            Text("\"\(highlight.content)\"")
                .font(.ds.headline)
                .foregroundColor(.ds.text)
                .lineLimit(4)
                .multilineTextAlignment(.leading)
            Spacer()
            // Context indicator
            if highlight.context != nil {
                Label("Has context", systemImage: "text.bubble")
                    .font(.ds.caption)
                    .foregroundColor(.ds.textSecondary)
            }
            // Footer
            HStack {
                Text(RelativeTimeFormatter.relativeTime(from: highlight.createdAt))
                    .font(.ds.caption)
                    .foregroundColor(.ds.textTertiary)
                Spacer()
                Image(systemName: "arrow.right.circle.fill")
                    .font(.title3)
                    .foregroundColor(.ds.primary)
                    .opacity(isPressed ? 1 : 0.6)
            }
        }
        .padding(16)
        .frame(height: 160)
        .background(
            ZStack {
                RoundedRectangle(cornerRadius: 20, style: .continuous)
                    .fill(
                        LinearGradient(
                            colors: [
                                Color.ds.surfaceSecondary,
                                Color.ds.surfaceSecondary.opacity(0.8)
                            ],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        )
                    )
                // Glow effect
                RoundedRectangle(cornerRadius: 20, style: .continuous)
                    .stroke(
                        LinearGradient(
                            colors: [
                                Color.orange.opacity(glowIntensity),
                                Color.orange.opacity(glowIntensity * 0.5)
                            ],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ),
                        lineWidth: 2
                    )
                    .blur(radius: 2)
            }
        )
        .shadow(color: Color.black.opacity(0.1), radius: 10, x: 0, y: 5)
        .scaleEffect(isPressed ? 0.95 : 1)
        .onLongPressGesture(minimumDuration: 0, maximumDistance: .infinity, pressing: { pressing in
            withAnimation(.spring(response: 0.3)) {
                isPressed = pressing
            }
        }, perform: {})
    }
}
struct QuoteCarouselCard: View {
    let highlight: HighlightEvent
    @State private var rotationAngle: Double = 0
    @State private var isHovered = false
    var body: some View {
        VStack(spacing: 16) {
            // Quote mark
            Image(systemName: "quote.opening")
                .font(.title)
                .foregroundColor(.orange.opacity(0.6))
                .rotationEffect(.degrees(isHovered ? 10 : 0))
            // Quote text
            Text(highlight.content)
                .font(.ds.body)
                .foregroundColor(.ds.text)
                .multilineTextAlignment(.center)
                .lineLimit(5)
                .fixedSize(horizontal: false, vertical: true)
            Spacer()
            // Attribution
            HStack {
                Image(systemName: "person.circle.fill")
                    .font(.caption)
                    .foregroundColor(.ds.textSecondary)
                Text(PubkeyFormatter.formatShort(highlight.author))
                    .font(.ds.caption)
                    .foregroundColor(.ds.textSecondary)
            }
        }
        .padding(24)
        .frame(height: 200)
        .background(
            ZStack {
                // Background gradient
                LinearGradient(
                    colors: [
                        Color.orange.opacity(0.05),
                        Color.orange.opacity(0.02)
                    ],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                // Border
                RoundedRectangle(cornerRadius: 16, style: .continuous)
                    .stroke(Color.orange.opacity(0.2), lineWidth: 1)
            }
            .clipShape(RoundedRectangle(cornerRadius: 16, style: .continuous))
        )
        .shadow(color: Color.orange.opacity(0.1), radius: 8, x: 0, y: 4)
        .rotation3DEffect(
            .degrees(rotationAngle),
            axis: (x: 0, y: 1, z: 0),
            perspective: 1
        )
        .onHover { hovering in
            withAnimation(.spring(response: 0.3)) {
                isHovered = hovering
                rotationAngle = hovering ? 5 : 0
            }
        }
    }
}
struct CurationCarouselCard: View {
    let curation: ArticleCuration
    @State private var imageOffset: CGSize = .zero
    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            // Cover image with parallax
            ZStack {
                if let imageUrl = curation.image {
                    AsyncImage(url: URL(string: imageUrl)) { image in
                        image
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                            .frame(height: 120)
                            .clipped()
                    } placeholder: {
                        gradientBackground
                    }
                } else {
                    gradientBackground
                }
            }
            .frame(height: 120)
            .clipShape(RoundedRectangle(cornerRadius: 12, style: .continuous))
            // Content
            VStack(alignment: .leading, spacing: 8) {
                Text(curation.title)
                    .font(.ds.headline)
                    .foregroundColor(.ds.text)
                    .lineLimit(1)
                if let description = curation.description {
                    Text(description)
                        .font(.ds.caption)
                        .foregroundColor(.ds.textSecondary)
                        .lineLimit(2)
                }
                // Stats
                HStack(spacing: 16) {
                    Label("\(curation.articles.count)", systemImage: "doc.text")
                    Label(PubkeyFormatter.formatCompact(curation.author), systemImage: "person.circle")
                }
                .font(.ds.caption)
                .foregroundColor(.ds.textTertiary)
            }
            .padding(.horizontal, 4)
        }
        .padding(12)
        .background(Color.ds.surfaceSecondary)
        .clipShape(RoundedRectangle(cornerRadius: 16, style: .continuous))
    }
    private var gradientBackground: some View {
        ZStack {
            LinearGradient(
                colors: [.blue, .purple],
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            .opacity(0.8)
            Image(systemName: "books.vertical.fill")
                .font(.system(size: 40))
                .foregroundColor(.white.opacity(0.3))
                .offset(imageOffset)
        }
    }
}
struct PersonDiscoveryCard: View {
    let profile: NDKUserProfile
    let pubkey: String
    @State private var isFollowing = false
    @State private var bounceScale: CGFloat = 1
    @EnvironmentObject var appState: AppState
    var displayName: String {
        profile.displayName ?? profile.name ?? PubkeyFormatter.formatCompact(pubkey)
    }
    var body: some View {
        VStack(spacing: 12) {
            // Avatar
            if let picture = profile.picture {
                AsyncImage(url: URL(string: picture)) { image in
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                        .frame(width: 80, height: 80)
                        .clipShape(Circle())
                } placeholder: {
                    avatarPlaceholder
                }
                .scaleEffect(bounceScale)
            } else {
                avatarPlaceholder
                    .scaleEffect(bounceScale)
            }
            // Name
            Text(displayName)
                .font(.ds.footnoteMedium)
                .foregroundColor(.ds.text)
                .lineLimit(1)
            // Bio snippet if available
            if let about = profile.about {
                Text(about)
                    .font(.system(size: 10))
                    .foregroundColor(.ds.textSecondary)
                    .lineLimit(2)
                    .multilineTextAlignment(.center)
                    .padding(.horizontal, 8)
            }
            // Follow button
            Button(action: {
                Task {
                    await toggleFollow()
                }
            }) {
                Text(isFollowing ? "Following" : "Follow")
                    .font(.ds.caption)
                    .fontWeight(.medium)
                    .foregroundColor(isFollowing ? .ds.text : .white)
                    .padding(.horizontal, 16)
                    .padding(.vertical, 6)
                    .background(
                        Capsule()
                            .fill(isFollowing ? Color.ds.surfaceSecondary : Color.ds.primary)
                    )
            }
        }
        .padding(.vertical, 16)
        .frame(maxWidth: .infinity)
        .background(Color.ds.surfaceSecondary)
        .clipShape(RoundedRectangle(cornerRadius: 16, style: .continuous))
        .task {
            await checkFollowStatus()
        }
    }
    private var avatarPlaceholder: some View {
        ZStack {
            Circle()
                .fill(
                    LinearGradient(
                        colors: [.purple, .blue],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
                .frame(width: 80, height: 80)
            Text(String(displayName.prefix(2)).uppercased())
                .font(.title2.bold())
                .foregroundColor(.white)
        }
    }
    private func checkFollowStatus() async {
        do {
            isFollowing = try await appState.isFollowing(pubkey)
        } catch {
            // Error checking follow status
            isFollowing = false
        }
    }
    private func toggleFollow() async {
        let wasFollowing = isFollowing
        isFollowing.toggle()
        HapticManager.shared.impact(.light)
        withAnimation(.spring(response: 0.3, dampingFraction: 0.6)) {
            bounceScale = 1.1
        }
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            withAnimation(.spring(response: 0.3)) {
                bounceScale = 1
            }
        }
        // Actually update the follow list using AppState
        do {
            if isFollowing {
                try await appState.followUser(pubkey)
            } else {
                try await appState.unfollowUser(pubkey)
            }
        } catch {
            // Revert on error
            await MainActor.run {
                isFollowing = wasFollowing
                HapticManager.shared.notification(.error)
            }
        }
    }
}
struct ZappedArticleCard: View {
    let event: NDKEvent
    @State private var lightningAnimation = false
    private var zapAmount: Int {
        // Extract amount from bolt11 tag if available
        if let bolt11Tag = event.tags.first(where: { $0.first == "bolt11" }),
           bolt11Tag.count > 1,
           let amountTag = event.tags.first(where: { $0.first == "amount" }),
           amountTag.count > 1,
           let amount = Int(amountTag[1]) {
            return amount / 1000 // Convert millisats to sats
        }
        return 0
    }
    private var zapperPubkey: String? {
        event.tags.first(where: { $0.first == "P" })?[safe: 1]
    }
    private var zappedEventId: String? {
        event.tags.first(where: { $0.first == "e" })?[safe: 1]
    }
    private var zapDescription: String {
        // Try to extract description from the event
        if let descriptionTag = event.tags.first(where: { $0.first == "description" }),
           descriptionTag.count > 1 {
            return descriptionTag[1]
        }
        return event.content
    }
    var body: some View {
        HStack(spacing: 16) {
            // Lightning icon with animation
            ZStack {
                Circle()
                    .fill(Color.yellow.opacity(0.2))
                    .frame(width: 60, height: 60)
                    .blur(radius: lightningAnimation ? 10 : 5)
                Image(systemName: "bolt.fill")
                    .font(.title)
                    .foregroundColor(.yellow)
                    .scaleEffect(lightningAnimation ? 1.2 : 1)
                    .rotationEffect(.degrees(lightningAnimation ? 10 : -10))
            }
            // Content
            VStack(alignment: .leading, spacing: 8) {
                if zapAmount > 0 {
                    Text("⚡ \(zapAmount.formatted()) sats")
                        .font(.ds.headline)
                        .foregroundColor(.ds.text)
                } else {
                    Text("Lightning payment")
                        .font(.ds.headline)
                        .foregroundColor(.ds.text)
                }
                if !zapDescription.isEmpty {
                    Text(zapDescription.prefix(100) + (zapDescription.count > 100 ? "..." : ""))
                        .font(.ds.caption)
                        .foregroundColor(.ds.textSecondary)
                        .lineLimit(2)
                }
                HStack(spacing: 4) {
                    if let zapperPubkey = zapperPubkey {
                        Text("from \(PubkeyFormatter.formatCompact(zapperPubkey))")
                            .font(.ds.caption)
                            .foregroundColor(.ds.textTertiary)
                    }
                    Text("• \(RelativeTimeFormatter.relativeTime(from: event.createdAt))")
                        .font(.ds.caption)
                        .foregroundColor(.ds.textTertiary)
                }
            }
            Spacer()
        }
        .padding(16)
        .background(
            LinearGradient(
                colors: [
                    Color.yellow.opacity(0.05),
                    Color.yellow.opacity(0.02)
                ],
                startPoint: .leading,
                endPoint: .trailing
            )
        )
        .clipShape(RoundedRectangle(cornerRadius: 16, style: .continuous))
        .overlay(
            RoundedRectangle(cornerRadius: 16, style: .continuous)
                .stroke(Color.yellow.opacity(0.2), lineWidth: 1)
        )
    }
}
struct ActiveDiscussionsInlineSection: View {
    let discussions: [NDKEvent]
    @State private var expandedDiscussion: String?
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Label("Active Discussions", systemImage: "bubble.left.and.bubble.right.fill")
                .font(.ds.title3)
                .fontWeight(.semibold)
                .foregroundColor(.ds.text)
            VStack(spacing: 0) {
                ForEach(discussions.prefix(3), id: \.id) { event in
                    DiscussionRowEnhanced(
                        event: event,
                        isExpanded: expandedDiscussion == event.id,
                        onTap: {
                            withAnimation(.spring(response: 0.3)) {
                                expandedDiscussion = expandedDiscussion == event.id ? nil : event.id
                            }
                        }
                    )
                    if event.id != discussions.prefix(3).last?.id {
                        Divider()
                            .padding(.leading, 52)
                    }
                }
            }
            .background(Color.ds.surfaceSecondary)
            .clipShape(RoundedRectangle(cornerRadius: 16, style: .continuous))
        }
    }
}
struct DiscussionRowEnhanced: View {
    let event: NDKEvent
    let isExpanded: Bool
    let onTap: () -> Void
    var body: some View {
        VStack(spacing: 12) {
            HStack(alignment: .top, spacing: 12) {
                // Avatar
                TappableAvatar(pubkey: event.pubkey, size: 40)
                VStack(alignment: .leading, spacing: 6) {
                    HStack {
                        Text(PubkeyFormatter.formatCompact(event.pubkey))
                            .font(.ds.footnoteMedium)
                            .foregroundColor(.ds.text)
                        Text("·")
                            .foregroundColor(.ds.textTertiary)
                        Text(RelativeTimeFormatter.relativeTime(from: event.createdAt))
                            .font(.ds.caption)
                            .foregroundColor(.ds.textTertiary)
                        Spacer()
                        Image(systemName: "chevron.down")
                            .font(.caption)
                            .foregroundColor(.ds.textTertiary)
                            .rotationEffect(.degrees(isExpanded ? 180 : 0))
                    }
                    Text(event.content)
                        .font(.ds.body)
                        .foregroundColor(.ds.text)
                        .lineLimit(isExpanded ? nil : 2)
                        .fixedSize(horizontal: false, vertical: true)
                    if isExpanded {
                        HStack(spacing: 20) {
                            Button(action: {}) {
                                Label("Reply", systemImage: "bubble.left")
                                    .font(.ds.caption)
                                    .foregroundColor(.ds.primary)
                            }
                            Button(action: {}) {
                                Label("12", systemImage: "bolt.fill")
                                    .font(.ds.caption)
                                    .foregroundColor(.orange)
                            }
                        }
                        .padding(.top, 8)
                    }
                }
            }
            .padding(16)
        }
        .background(Color.clear)
        .contentShape(Rectangle())
        .onTapGesture(perform: onTap)
    }
}
struct SectionTab: View {
    let section: HybridFeedView.FeedSection
    let isSelected: Bool
    let namespace: Namespace.ID
    let action: () -> Void
    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                HStack(spacing: 6) {
                    Image(systemName: section.icon)
                        .font(.system(size: 14, weight: .medium))
                        .foregroundColor(isSelected ? section.color : .ds.textTertiary)
                    Text(section.rawValue)
                        .font(.ds.footnoteMedium)
                        .foregroundColor(isSelected ? .ds.text : .ds.textSecondary)
                }
                // Animated underline
                ZStack {
                    if isSelected {
                        Capsule()
                            .fill(section.color)
                            .frame(height: 3)
                            .matchedGeometryEffect(id: "tab", in: namespace)
                    } else {
                        Capsule()
                            .fill(Color.clear)
                            .frame(height: 3)
                    }
                }
            }
        }
        .buttonStyle(PlainButtonStyle())
    }
}
struct StatPill: View {
    let icon: String
    let value: String
    let label: String
    let color: Color
    @State private var animateValue = false
    var body: some View {
        HStack(spacing: 8) {
            Image(systemName: icon)
                .font(.system(size: 14, weight: .medium))
                .foregroundColor(color)
                .scaleEffect(animateValue ? 1.1 : 1)
            VStack(alignment: .leading, spacing: 2) {
                Text(value)
                    .font(.ds.footnoteMedium)
                    .foregroundColor(.ds.text)
                    .monospacedDigit()
                Text(label)
                    .font(.system(size: 10))
                    .foregroundColor(.ds.textTertiary)
            }
        }
        .padding(.horizontal, 12)
        .padding(.vertical, 8)
        .background(
            Capsule()
                .fill(color.opacity(0.1))
                .overlay(
                    Capsule()
                        .stroke(color.opacity(0.2), lineWidth: 1)
                )
        )
        .onAppear {
            withAnimation(.spring(response: 0.5, dampingFraction: 0.6).delay(0.3)) {
                animateValue = true
            }
        }
    }
}
// MARK: - Visual Effects
struct HybridFeedVisualEffectBlur: UIViewRepresentable {
    var blurStyle: UIBlurEffect.Style
    func makeUIView(context: Context) -> UIVisualEffectView {
        UIVisualEffectView(effect: UIBlurEffect(style: blurStyle))
    }
    func updateUIView(_ uiView: UIVisualEffectView, context: Context) {
        uiView.effect = UIBlurEffect(style: blurStyle)
    }
}
struct NoiseTextureView: View {
    var body: some View {
        GeometryReader { geometry in
            Canvas { context, size in
                for _ in 0..<1000 {
                    let x = CGFloat.random(in: 0...size.width)
                    let y = CGFloat.random(in: 0...size.height)
                    let opacity = Double.random(in: 0.1...0.3)
                    context.fill(
                        Circle().path(in: CGRect(x: x, y: y, width: 1, height: 1)),
                        with: .color(.white.opacity(opacity))
                    )
                }
            }
        }
    }
}
// MARK: - Recent Articles Section
struct RecentArticlesSection: View {
    @ObservedObject var dataManager: HomeDataManager
    @EnvironmentObject var appState: AppState
    @State private var currentPage = 0
    @State private var selectedArticle: Article?
    @State private var showingArticleDetail = false
    var recentArticles: [Article] {
        // Get recent articles from DataStreamManager
        Array(appState.articles.prefix(5))
    }
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            // Section header
            HStack {
                Label("Recent articles", systemImage: "clock.fill")
                    .font(.ds.title2)
                    .fontWeight(.semibold)
                    .foregroundColor(.ds.text)
                Spacer()
                // Page indicators
                if !recentArticles.isEmpty {
                    HStack(spacing: 6) {
                        ForEach(0..<recentArticles.count, id: \.self) { index in
                            Circle()
                                .fill(currentPage == index ? Color.ds.primary : Color.ds.textTertiary.opacity(0.3))
                                .frame(width: 6, height: 6)
                                .scaleEffect(currentPage == index ? 1.2 : 1)
                                .animation(.spring(response: 0.3), value: currentPage)
                        }
                    }
                }
            }
            .padding(.horizontal, 16)
            // Portrait article cards carousel
            if !recentArticles.isEmpty {
                ScrollView(.horizontal, showsIndicators: false) {
                    LazyHStack(spacing: 12) {
                        ForEach(Array(recentArticles.enumerated()), id: \.element.id) { index, article in
                            Button(action: {
                                selectedArticle = article
                                showingArticleDetail = true
                                HapticManager.shared.impact(.medium)
                            }) {
                                RecentArticlePortraitCard(
                                    article: article,
                                    highlights: [],
                                    index: index
                                )
                                .frame(width: 280)
                            }
                            .buttonStyle(PlainButtonStyle())
                            .onAppear {
                                withAnimation {
                                    currentPage = index
                                }
                            }
                        }
                    }
                    .padding(.horizontal, 16)
                    .scrollTargetLayout()
                }
                .scrollTargetBehavior(.viewAligned)
                .sensoryFeedback(.selection, trigger: currentPage)
            }
        }
        .sheet(isPresented: $showingArticleDetail) {
            if let article = selectedArticle {
                ArticleView(article: article)
                    .presentationDragIndicator(.visible)
                    .presentationDetents([.large])
            }
        }
    }
}
struct RecentArticlePortraitCard: View {
    let article: Article
    let highlights: [HighlightEvent]
    let index: Int
    @Environment(\.colorScheme) var colorScheme
    var body: some View {
        ZStack(alignment: .bottom) {
            // Background image or gradient
            if let imageUrl = article.image {
                GeometryReader { geometry in
                    AsyncImage(url: URL(string: imageUrl)) { phase in
                        switch phase {
                        case .empty:
                            Color.ds.surfaceSecondary
                        case .success(let image):
                            image
                                .resizable()
                                .aspectRatio(contentMode: .fill)
                                .frame(width: geometry.size.width, height: geometry.size.height)
                                .clipped()
                        case .failure(_):
                            fallbackGradient
                        @unknown default:
                            fallbackGradient
                        }
                    }
                }
            } else {
                fallbackGradient
            }
            // Dark overlay gradient for text readability
            LinearGradient(
                colors: [
                    Color.black.opacity(0),
                    Color.black.opacity(0.3),
                    Color.black.opacity(0.8)
                ],
                startPoint: .top,
                endPoint: .bottom
            )
            // Content overlay
            VStack(alignment: .leading, spacing: 12) {
                Spacer()
                // Category/Topic badge
                if let firstTag = article.hashtags.first {
                    Text(firstTag.uppercased())
                        .font(.ds.caption)
                        .fontWeight(.semibold)
                        .foregroundColor(.white.opacity(0.9))
                        .padding(.horizontal, 12)
                        .padding(.vertical, 6)
                        .background(
                            Capsule()
                                .fill(.ultraThinMaterial)
                                .environment(\.colorScheme, .dark)
                        )
                }
                // Title
                Text(article.title)
                    .font(.system(size: 24, weight: .bold, design: .default))
                    .foregroundColor(.white)
                    .lineLimit(3)
                    .multilineTextAlignment(.leading)
                    .fixedSize(horizontal: false, vertical: true)
                // Summary or first highlight
                if let summary = article.summary {
                    Text(summary)
                        .font(.ds.body)
                        .foregroundColor(.white.opacity(0.9))
                        .lineLimit(2)
                } else if !highlights.isEmpty, let firstHighlight = highlights.first {
                    HStack(spacing: 8) {
                        Image(systemName: "quote.opening")
                            .font(.caption)
                            .foregroundColor(.yellow)
                        Text(firstHighlight.content)
                            .font(.ds.body)
                            .italic()
                            .foregroundColor(.white.opacity(0.9))
                            .lineLimit(2)
                    }
                }
                // Metadata bar
                HStack(spacing: 16) {
                    // Reading time
                    Label("\(article.estimatedReadingTime) min", systemImage: "clock")
                        .font(.ds.caption)
                        .foregroundColor(.white.opacity(0.8))
                    // Highlights count
                    Label("\(highlights.count)", systemImage: "highlighter")
                        .font(.ds.caption)
                        .foregroundColor(.yellow)
                    Spacer()
                    // Author avatar and time
                    HStack(spacing: 8) {
                        TappableAvatar(pubkey: article.author, size: 24)
                        Text(PubkeyFormatter.formatCompact(article.author))
                            .font(.ds.caption)
                            .foregroundColor(.white.opacity(0.8))
                    }
                }
            }
            .padding(16)
        }
        .frame(height: 357)
        .background(Color.ds.surfaceSecondary)
        .clipShape(RoundedRectangle(cornerRadius: 20, style: .continuous))
        .shadow(
            color: Color.black.opacity(colorScheme == .dark ? 0.3 : 0.15),
            radius: 20,
            x: 0,
            y: 10
        )
    }
    @ViewBuilder
    private var fallbackGradient: some View {
        let gradients: [[Color]] = [
            [Color.purple, Color.blue],
            [Color.orange, Color.pink],
            [Color.green, Color.teal],
            [Color.red, Color.orange],
            [Color.indigo, Color.purple]
        ]
        LinearGradient(
            colors: gradients[index % gradients.count],
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
        .overlay(
            // Subtle pattern overlay
            ZStack {
                ForEach(0..<3) { i in
                    Circle()
                        .fill(Color.white.opacity(0.05))
                        .frame(width: 200, height: 200)
                        .offset(
                            x: CGFloat(i * 50 - 50),
                            y: CGFloat(i * 80 - 100)
                        )
                        .blur(radius: 50)
                }
            }
        )
    }
}
// MARK: - View Modifiers
extension View {
    func revealAnimation(id: String, visibility: Binding<[String: Bool]>) -> some View {
        self
            .opacity(visibility.wrappedValue[id] ?? false ? 1 : 0)
            .offset(y: visibility.wrappedValue[id] ?? false ? 0 : 20)
            .onAppear {
                withAnimation(.spring(response: 0.6, dampingFraction: 0.8).delay(0.1)) {
                    visibility.wrappedValue[id] = true
                }
            }
    }
}
// MARK: - Preference Keys
struct ScrollOffsetKey: PreferenceKey {
    static var defaultValue: CGFloat = 0
    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {
        value = nextValue()
    }
}
// MARK: - Preview
struct HybridFeedView_Previews: PreviewProvider {
    static var previews: some View {
        HybridFeedView()
            .environmentObject(AppState())
    }
}
</file>

</files>
